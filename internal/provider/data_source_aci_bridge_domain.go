// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"fmt"

	customTypes "github.com/CiscoDevNet/terraform-provider-aci/v2/internal/custom_types"
	"github.com/ciscoecosystem/aci-go-client/v2/client"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &FvBDDataSource{}

func NewFvBDDataSource() datasource.DataSource {
	return &FvBDDataSource{}
}

// FvBDDataSource defines the data source implementation.
type FvBDDataSource struct {
	client *client.Client
}

func (d *FvBDDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of datasource: aci_bridge_domain")
	resp.TypeName = req.ProviderTypeName + "_bridge_domain"
	tflog.Debug(ctx, "End metadata of datasource: aci_bridge_domain")
}

func (d *FvBDDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of datasource: aci_bridge_domain")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The bridge_domain datasource for the 'fvBD' class",

		Attributes: map[string]schema.Attribute{
			// Deprecated attributes
			"arp_flood": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'arp_flood' is deprecated, please refer to 'arp_flooding' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ep_clear": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_clear' is deprecated, please refer to 'clear_remote_mac_entries' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ep_move_detect_mode": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_move_detect_mode' is deprecated, please refer to 'endpoint_move_detection_mode' instead. The attribute will be removed in the next major version of the provider.",
			},
			"host_based_routing": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'host_based_routing' is deprecated, please refer to 'advertise_host_routes' instead. The attribute will be removed in the next major version of the provider.",
			},
			"intersite_bum_traffic_allow": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'intersite_bum_traffic_allow' is deprecated, please refer to 'enable_intersite_bum_traffic' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ipv6_mcast_allow": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ipv6_mcast_allow' is deprecated, please refer to 'pim_ipv6' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ll_addr": schema.StringAttribute{
				CustomType:         customTypes.IPv6AddressStringType{},
				Computed:           true,
				DeprecationMessage: "Attribute 'll_addr' is deprecated, please refer to 'link_local_ipv6_address' instead. The attribute will be removed in the next major version of the provider.",
			},
			"mac": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'mac' is deprecated, please refer to 'custom_mac_address' instead. The attribute will be removed in the next major version of the provider.",
			},
			"mcast_allow": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'mcast_allow' is deprecated, please refer to 'pim' instead. The attribute will be removed in the next major version of the provider.",
			},
			"multi_dst_pkt_act": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'multi_dst_pkt_act' is deprecated, please refer to 'multi_destination_flooding' instead. The attribute will be removed in the next major version of the provider.",
			},
			"tenant_dn": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'tenant_dn' is deprecated, please refer to 'parent_dn' instead. The attribute will be removed in the next major version of the provider.",
			},
			"unicast_route": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'unicast_route' is deprecated, please refer to 'unicast_routing' instead. The attribute will be removed in the next major version of the provider.",
			},
			"unk_mac_ucast_act": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'unk_mac_ucast_act' is deprecated, please refer to 'l2_unknown_unicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
			},
			"unk_mcast_act": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'unk_mcast_act' is deprecated, please refer to 'l3_unknown_multicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
			},
			"v6unk_mcast_act": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'v6unk_mcast_act' is deprecated, please refer to 'ipv6_l3_unknown_multicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
			},
			"vmac": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'vmac' is deprecated, please refer to 'virtual_mac_address' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_relay_p": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_relay_p' is deprecated, please refer to 'relation_to_dhcp_relay_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_ep_ret": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_ep_ret' is deprecated, please refer to 'relation_to_end_point_retention_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_fhs": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_fhs' is deprecated, please refer to 'relation_to_first_hop_security_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_out": schema.SetAttribute{
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_out' is deprecated, please refer to 'relation_to_l3_outsides' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_abd_pol_mon_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_abd_pol_mon_pol' is deprecated, please refer to 'relation_to_monitoring_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_nd_p": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_nd_p' is deprecated, please refer to 'relation_to_neighbor_discovery_interface_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_flood_to": schema.SetAttribute{
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute `relation_fv_rs_bd_flood_to` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_bd_to_profile": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_fv_rs_bd_to_profile` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_igmpsn": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_igmpsn' is deprecated, please refer to 'relation_to_igmp_snooping_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_mldsn": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_mldsn' is deprecated, please refer to 'relation_to_mld_snooping_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_fv_rs_ctx": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_ctx' is deprecated, please refer to 'relation_to_vrf' instead. The attribute will be removed in the next major version of the provider.",
			},
			// End of deprecated attributes
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the Bridge Domain object.",
			},
			"parent_dn": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
			},
			"optimize_wan_bandwidth": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Optimize WAN Bandwidth for the Bridge Domain object.`,
			},
			"annotation": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The annotation of the Bridge Domain object.`,
			},
			"arp_flooding": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable ARP flooding for the Bridge Domain object. If flooding is disabled, ARP requests for unknown endpoints will be forwarded by the leaf switch to the spine proxy for resolution and might trigger an ARP glean if the endpoint is not present in the COOP database.`,
			},
			"description": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The description of the Bridge Domain object.`,
			},
			"enable_rogue_exception_mac": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable rogue exception based on MAC wildcard for the Bridge Domain object.`,
			},
			"clear_remote_mac_entries": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Clear all endpoints in leaf switches for the Bridge Domain object.`,
			},
			"endpoint_move_detection_mode": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The End Point move detection option uses the Gratuitous Address Resolution Protocol (GARP). A gratuitous ARP is an ARP broadcast-type of packet that is used to verify that no other device on the network has the same IP address as the sending device.`,
			},
			"advertise_host_routes": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Advertise host routes (/32 prefixes) out of the L3Out(s) associated to the Bridge Domain object.`,
			},
			"enable_intersite_bum_traffic": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable intersite Broadcast, Unknown-Unicast and Multicast (BUM) traffic between sites for the Bridge Domain object.`,
			},
			"intersite_l2_stretch": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable L2 stretch between sites for the Bridge Domain object.`,
			},
			"ip_learning": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The IP learning setting of the Bridge Domain object.`,
			},
			"pim_ipv6": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable IPv6 Protocol Independent Multicast (PIM) traffic for the Bridge Domain object.`,
			},
			"limit_ip_learn_to_subnets": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Limit IP address learning to subnets for the Bridge Domain object. Every Bridge Domain object can have multiple subnets associated with it.`,
			},
			"link_local_ipv6_address": schema.StringAttribute{
				CustomType:          customTypes.IPv6AddressStringType{},
				Computed:            true,
				MarkdownDescription: `The override of the system generated IPv6 link-local address.`,
			},
			"custom_mac_address": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The MAC address of the Bridge Domain object.`,
			},
			"drop_arp_with_multicast_smac": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Drop rogue multicast ARP packets for the Bridge Domain object.`,
			},
			"pim": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable IPv4 Protocol Independent Multicast (PIM) traffic for the Bridge Domain object.`,
			},
			"multi_destination_flooding": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The multiple destination forwarding method for L2 Multicast, Broadcast, and Link Layer traffic types.`,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the Bridge Domain object.`,
			},
			"name_alias": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The name alias of the Bridge Domain object.`,
			},
			"owner_key": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
			},
			"owner_tag": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
			},
			"pc_tag": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The classification tag used for policy enforcement and zoning.`,
			},
			"scope": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The scope ID (L3-VNI) of the Bridge Domain object.`,
			},
			"segment": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The segment ID (L2-VNI) of the Bridge Domain object.`,
			},
			"service_bd_routing_disable": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Disable Routing on service BD.`,
			},
			"bridge_domain_type": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The domain type of the Bridge Domain object.`,
			},
			"unicast_routing": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enables L3 routing and endpoint IP learning for the Bridge Domain object.`,
			},
			"l2_unknown_unicast_flooding": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The forwarding method for unknown layer 2 destinations.`,
			},
			"l3_unknown_multicast_flooding": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The forwarding method for unknown layer 3 multicast destinations.`,
			},
			"ipv6_l3_unknown_multicast_flooding": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The forwarding method for unknown IPv6 multicast destinations.`,
			},
			"virtual_mac_address": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The virtual MAC address of the Bridge Domain object. This is used when the the BD/SVI is extended to multiple sites using a L2 Outside.`,
			},
			"legacy_mode": schema.SingleNestedAttribute{
				MarkdownDescription: `The bridge domain (BD) access profile. When created over a BD, contracts are not enforced for the BD, and the encap will be applied to all endpoint groups on this BD.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Legacy Mode object.`,
					},
					"description": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The description of the Legacy Mode object.`,
					},
					"encapsulation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The VLAN or VXLAN encapsulation of the Legacy Mode object.`,
					},
					"name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the Legacy Mode object.`,
					},
					"name_alias": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name alias of the Legacy Mode object.`,
					},
					"owner_key": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
					},
					"owner_tag": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"rogue_coop_exceptions": schema.SetNestedAttribute{
				MarkdownDescription: `Configuration of MAC address to be excepted from Rogue processing`,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The annotation of the Rogue Coop Exception object.`,
						},
						"description": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The description of the Rogue Coop Exception object.`,
						},
						"mac": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The MAC address of the Rogue Coop Exception object.`,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The name of the Rogue Coop Exception object.`,
						},
						"name_alias": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The name alias of the Rogue Coop Exception object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
			"relation_to_monitoring_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the monitoring policy model for the endpoint group semantic scope. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Monitoring Policy object.`,
					},
					"monitoring_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the Monitoring Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_first_hop_security_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relation to FHS BD policy`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To First Hop Security Policy object.`,
					},
					"first_hop_security_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the First Hop Security Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_neighbor_discovery_interface_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `The neighbor discovery policy.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Neighbor Discovery Interface Policy object.`,
					},
					"neighbor_discovery_interface_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the Neighbor Discovery Interface Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_netflow_monitor_policies": schema.SetNestedAttribute{
				MarkdownDescription: `Relation to Netflow Monitor policy`,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The annotation of the Relation From Bridge Domain To NetFlow Monitor Policy object.`,
						},
						"filter_type": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The filter type of the NetFlow Monitor Policy object.`,
						},
						"netflow_monitor_policy_name": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The name of the NetFlow Monitor Policy object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
			"relation_to_l3_outsides": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to the policy controlling connectivity to the outside. This is an internal object.`,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The annotation of the Relation From Bridge Domain To L3 Outside object.`,
						},
						"l3_outside_name": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The name of the L3 Outside object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Computed:            true,
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
			"relation_to_route_control_profile": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to external networks that are routed via Layer 3 networks outside the fabric that are reachable by a tenant's applications. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Route Control Profile object.`,
					},
					"l3_outside_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the L3 Outside object.`,
					},
					"route_control_profile_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the Route Control Profile object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_dhcp_relay_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the DHCP relay profile. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To DHCP Relay Policy object.`,
					},
					"dhcp_relay_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the DHCP Relay Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_end_point_retention_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the endpoint retention policy providing the parameters for the lifecycle of the endpoint group. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To End Point Retention Policy object.`,
					},
					"resolve_action": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The action to take for resolving the Endpoint Retention Policy object.`,
					},
					"end_point_retention_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the Endpoint Retention Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_vrf": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to a private layer 3 network context that either belongs to a specific tenant or is shared. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To VRF object.`,
					},
					"vrf_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the VRF object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_igmp_snooping_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the Internet Group Management Protocol (IGMP) snooping policy. This is an internal object.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To IGMP Snooping Policy object.`,
					},
					"igmp_snooping_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the IGMP Snooping Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_mld_snooping_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relation to an MLD Snoop policy`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To MLD Snooping Policy object.`,
					},
					"mld_snooping_policy_name": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name of the MLD Snooping Policy object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{
			"relation_fv_rs_bd_to_netflow_monitor_pol": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"flt_type": schema.StringAttribute{
							Computed:           true,
							DeprecationMessage: "Attribute 'flt_type' will be deprecated soon, please refer to 'relation_to_netflow_monitor_policies.filter_type' instead",
						},
						"tn_netflow_monitor_pol_name": schema.StringAttribute{
							Computed:           true,
							DeprecationMessage: "Attribute 'tn_netflow_monitor_pol_name' will be deprecated soon, please refer to 'relation_to_netflow_monitor_policies.netflow_monitor_policy_name' instead",
						},
					},
				},
			},
		},
	}
	tflog.Debug(ctx, "End schema of datasource: aci_bridge_domain")
}

func (d *FvBDDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of datasource: aci_bridge_domain")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = client
	tflog.Debug(ctx, "End configure of datasource: aci_bridge_domain")
}

func (d *FvBDDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	tflog.Debug(ctx, "Start read of datasource: aci_bridge_domain")
	var data *FvBDResourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	setFvBDId(ctx, data)

	// Create a copy of the Id for when not found during getAndSetFvBDAttributes
	cachedId := data.Id.ValueString()

	tflog.Debug(ctx, fmt.Sprintf("Read of datasource aci_bridge_domain with id '%s'", data.Id.ValueString()))

	getAndSetFvBDAttributes(ctx, &resp.Diagnostics, d.client, data)

	if data.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Failed to read aci_bridge_domain data source",
			fmt.Sprintf("The aci_bridge_domain data source with id '%s' has not been found", cachedId),
		)
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End read of datasource aci_bridge_domain with id '%s'", data.Id.ValueString()))
}
