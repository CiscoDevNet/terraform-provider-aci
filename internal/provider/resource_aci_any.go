// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"encoding/json"
	"fmt"

	customTypes "github.com/CiscoDevNet/terraform-provider-aci/v2/internal/custom_types"
	"github.com/CiscoDevNet/terraform-provider-aci/v2/internal/validators"
	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &VzAnyResource{}
var _ resource.ResourceWithImportState = &VzAnyResource{}

func NewVzAnyResource() resource.Resource {
	return &VzAnyResource{}
}

// VzAnyResource defines the resource implementation.
type VzAnyResource struct {
	client *client.Client
}

// VzAnyResourceModel describes the resource data model.
type VzAnyResourceModel struct {
	Id                        types.String `tfsdk:"id"`
	ParentDn                  types.String `tfsdk:"parent_dn"`
	Annotation                types.String `tfsdk:"annotation"`
	Descr                     types.String `tfsdk:"description"`
	MatchT                    types.String `tfsdk:"match_criteria"`
	Name                      types.String `tfsdk:"name"`
	NameAlias                 types.String `tfsdk:"name_alias"`
	PrefGrMemb                types.String `tfsdk:"preferred_group_member"`
	TagAnnotation             types.Set    `tfsdk:"annotations"`
	TagTag                    types.Set    `tfsdk:"tags"`
	VzRsAnyToCons             types.Set    `tfsdk:"relation_to_consumer_contracts"`
	VzRsAnyToConsIf           types.Set    `tfsdk:"relation_to_contract_interfaces"`
	VzRsAnyToProv             types.Set    `tfsdk:"relation_to_provider_contracts"`
	DeprecatedMatchT          types.String `tfsdk:"match_t"`
	DeprecatedParentDn        types.String `tfsdk:"vrf_dn"`
	DeprecatedPrefGrMemb      types.String `tfsdk:"pref_gr_memb"`
	DeprecatedVzRsAnyToCons   types.Set    `tfsdk:"relation_vz_rs_any_to_cons"`
	DeprecatedVzRsAnyToConsIf types.Set    `tfsdk:"relation_vz_rs_any_to_cons_if"`
	DeprecatedVzRsAnyToProv   types.Set    `tfsdk:"relation_vz_rs_any_to_prov"`
}

func getEmptyVzAnyResourceModel() *VzAnyResourceModel {
	return &VzAnyResourceModel{
		Id:         basetypes.NewStringNull(),
		ParentDn:   basetypes.NewStringNull(),
		Annotation: basetypes.NewStringNull(),
		Descr:      basetypes.NewStringNull(),
		MatchT:     basetypes.NewStringNull(),
		Name:       basetypes.NewStringNull(),
		NameAlias:  basetypes.NewStringNull(),
		PrefGrMemb: basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		VzRsAnyToCons: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":    types.StringType,
				"priority":      types.StringType,
				"contract_name": types.StringType,
				"annotations":   types.SetType{ElemType: TagAnnotationVzRsAnyToConsVzAnyType},
				"tags":          types.SetType{ElemType: TagTagVzRsAnyToConsVzAnyType},
			},
		}),
		VzRsAnyToConsIf: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":             types.StringType,
				"priority":               types.StringType,
				"imported_contract_name": types.StringType,
				"annotations":            types.SetType{ElemType: TagAnnotationVzRsAnyToConsIfVzAnyType},
				"tags":                   types.SetType{ElemType: TagTagVzRsAnyToConsIfVzAnyType},
			},
		}),
		VzRsAnyToProv: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":     types.StringType,
				"match_criteria": types.StringType,
				"priority":       types.StringType,
				"contract_name":  types.StringType,
				"annotations":    types.SetType{ElemType: TagAnnotationVzRsAnyToProvVzAnyType},
				"tags":           types.SetType{ElemType: TagTagVzRsAnyToProvVzAnyType},
			},
		}),
		DeprecatedMatchT:          types.String{},
		DeprecatedParentDn:        types.String{},
		DeprecatedPrefGrMemb:      types.String{},
		DeprecatedVzRsAnyToCons:   types.SetNull(types.StringType),
		DeprecatedVzRsAnyToConsIf: types.SetNull(types.StringType),
		DeprecatedVzRsAnyToProv:   types.SetNull(types.StringType),
	}
}

// TagAnnotationVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationVzAnyResourceModel() TagAnnotationVzAnyResourceModel {
	return TagAnnotationVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagAnnotationVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// TagTagVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagTagVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagVzAnyResourceModel() TagTagVzAnyResourceModel {
	return TagTagVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagTagVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// VzRsAnyToConsVzAnyResourceModel describes the resource data model for the children without relation ships.
type VzRsAnyToConsVzAnyResourceModel struct {
	Annotation    types.String                             `tfsdk:"annotation"`
	Prio          customTypes.VzRsAnyToConsPrioStringValue `tfsdk:"priority"`
	TnVzBrCPName  types.String                             `tfsdk:"contract_name"`
	TagAnnotation types.Set                                `tfsdk:"annotations"`
	TagTag        types.Set                                `tfsdk:"tags"`
}

func getEmptyVzRsAnyToConsVzAnyResourceModel() VzRsAnyToConsVzAnyResourceModel {
	return VzRsAnyToConsVzAnyResourceModel{
		Annotation:   basetypes.NewStringNull(),
		Prio:         customTypes.NewVzRsAnyToConsPrioStringNull(),
		TnVzBrCPName: basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
	}
}

var VzRsAnyToConsVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"annotation":    types.StringType,
		"priority":      types.StringType,
		"contract_name": types.StringType,
		"annotations":   types.SetType{ElemType: TagAnnotationVzRsAnyToConsVzAnyType},
		"tags":          types.SetType{ElemType: TagTagVzRsAnyToConsVzAnyType},
	},
}

func VzRsAnyToConsVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(ctx context.Context, planValue, stateValue types.Set) basetypes.SetValue {
	//  Function is needed to handle the case that an attribute is not yet supported in a version and gets set to null during read
	var planSetValues, stateSetValues []VzRsAnyToConsVzAnyResourceModel
	stateValue.ElementsAs(ctx, &stateSetValues, false)
	planValue.ElementsAs(ctx, &planSetValues, false)

	// If the length of the state and plan values are different a change is already detected the loop can be skipped
	if len(stateSetValues) == len(planSetValues) {
		for index, stateValue := range stateSetValues {
			nullInStateFound := false
			if stateValue.Annotation.IsNull() {
				nullInStateFound = true
				planSetValues[index].Annotation = basetypes.NewStringNull()
			}
			if stateValue.Prio.IsNull() {
				nullInStateFound = true
				planSetValues[index].Prio = customTypes.NewVzRsAnyToConsPrioStringNull()
			}
			if stateValue.TnVzBrCPName.IsNull() {
				nullInStateFound = true
				planSetValues[index].TnVzBrCPName = basetypes.NewStringNull()
			}
			if !nullInStateFound {
				// when there are no null fields we can conclude the version supports all attributes in set
				break
			}
		}
	}
	planSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsVzAnyType, planSetValues)
	return planSet

}

// TagAnnotationVzRsAnyToConsVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationVzRsAnyToConsVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationVzRsAnyToConsVzAnyResourceModel() TagAnnotationVzRsAnyToConsVzAnyResourceModel {
	return TagAnnotationVzRsAnyToConsVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagAnnotationVzRsAnyToConsVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// TagTagVzRsAnyToConsVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagTagVzRsAnyToConsVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagVzRsAnyToConsVzAnyResourceModel() TagTagVzRsAnyToConsVzAnyResourceModel {
	return TagTagVzRsAnyToConsVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagTagVzRsAnyToConsVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// VzRsAnyToConsIfVzAnyResourceModel describes the resource data model for the children without relation ships.
type VzRsAnyToConsIfVzAnyResourceModel struct {
	Annotation    types.String                               `tfsdk:"annotation"`
	Prio          customTypes.VzRsAnyToConsIfPrioStringValue `tfsdk:"priority"`
	TnVzCPIfName  types.String                               `tfsdk:"imported_contract_name"`
	TagAnnotation types.Set                                  `tfsdk:"annotations"`
	TagTag        types.Set                                  `tfsdk:"tags"`
}

func getEmptyVzRsAnyToConsIfVzAnyResourceModel() VzRsAnyToConsIfVzAnyResourceModel {
	return VzRsAnyToConsIfVzAnyResourceModel{
		Annotation:   basetypes.NewStringNull(),
		Prio:         customTypes.NewVzRsAnyToConsIfPrioStringNull(),
		TnVzCPIfName: basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
	}
}

var VzRsAnyToConsIfVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"annotation":             types.StringType,
		"priority":               types.StringType,
		"imported_contract_name": types.StringType,
		"annotations":            types.SetType{ElemType: TagAnnotationVzRsAnyToConsIfVzAnyType},
		"tags":                   types.SetType{ElemType: TagTagVzRsAnyToConsIfVzAnyType},
	},
}

func VzRsAnyToConsIfVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(ctx context.Context, planValue, stateValue types.Set) basetypes.SetValue {
	//  Function is needed to handle the case that an attribute is not yet supported in a version and gets set to null during read
	var planSetValues, stateSetValues []VzRsAnyToConsIfVzAnyResourceModel
	stateValue.ElementsAs(ctx, &stateSetValues, false)
	planValue.ElementsAs(ctx, &planSetValues, false)

	// If the length of the state and plan values are different a change is already detected the loop can be skipped
	if len(stateSetValues) == len(planSetValues) {
		for index, stateValue := range stateSetValues {
			nullInStateFound := false
			if stateValue.Annotation.IsNull() {
				nullInStateFound = true
				planSetValues[index].Annotation = basetypes.NewStringNull()
			}
			if stateValue.Prio.IsNull() {
				nullInStateFound = true
				planSetValues[index].Prio = customTypes.NewVzRsAnyToConsIfPrioStringNull()
			}
			if stateValue.TnVzCPIfName.IsNull() {
				nullInStateFound = true
				planSetValues[index].TnVzCPIfName = basetypes.NewStringNull()
			}
			if !nullInStateFound {
				// when there are no null fields we can conclude the version supports all attributes in set
				break
			}
		}
	}
	planSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsIfVzAnyType, planSetValues)
	return planSet

}

// TagAnnotationVzRsAnyToConsIfVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationVzRsAnyToConsIfVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationVzRsAnyToConsIfVzAnyResourceModel() TagAnnotationVzRsAnyToConsIfVzAnyResourceModel {
	return TagAnnotationVzRsAnyToConsIfVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagAnnotationVzRsAnyToConsIfVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// TagTagVzRsAnyToConsIfVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagTagVzRsAnyToConsIfVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagVzRsAnyToConsIfVzAnyResourceModel() TagTagVzRsAnyToConsIfVzAnyResourceModel {
	return TagTagVzRsAnyToConsIfVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagTagVzRsAnyToConsIfVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// VzRsAnyToProvVzAnyResourceModel describes the resource data model for the children without relation ships.
type VzRsAnyToProvVzAnyResourceModel struct {
	Annotation    types.String                             `tfsdk:"annotation"`
	MatchT        types.String                             `tfsdk:"match_criteria"`
	Prio          customTypes.VzRsAnyToProvPrioStringValue `tfsdk:"priority"`
	TnVzBrCPName  types.String                             `tfsdk:"contract_name"`
	TagAnnotation types.Set                                `tfsdk:"annotations"`
	TagTag        types.Set                                `tfsdk:"tags"`
}

func getEmptyVzRsAnyToProvVzAnyResourceModel() VzRsAnyToProvVzAnyResourceModel {
	return VzRsAnyToProvVzAnyResourceModel{
		Annotation:   basetypes.NewStringNull(),
		MatchT:       basetypes.NewStringNull(),
		Prio:         customTypes.NewVzRsAnyToProvPrioStringNull(),
		TnVzBrCPName: basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
	}
}

var VzRsAnyToProvVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"annotation":     types.StringType,
		"match_criteria": types.StringType,
		"priority":       types.StringType,
		"contract_name":  types.StringType,
		"annotations":    types.SetType{ElemType: TagAnnotationVzRsAnyToProvVzAnyType},
		"tags":           types.SetType{ElemType: TagTagVzRsAnyToProvVzAnyType},
	},
}

func VzRsAnyToProvVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(ctx context.Context, planValue, stateValue types.Set) basetypes.SetValue {
	//  Function is needed to handle the case that an attribute is not yet supported in a version and gets set to null during read
	var planSetValues, stateSetValues []VzRsAnyToProvVzAnyResourceModel
	stateValue.ElementsAs(ctx, &stateSetValues, false)
	planValue.ElementsAs(ctx, &planSetValues, false)

	// If the length of the state and plan values are different a change is already detected the loop can be skipped
	if len(stateSetValues) == len(planSetValues) {
		for index, stateValue := range stateSetValues {
			nullInStateFound := false
			if stateValue.Annotation.IsNull() {
				nullInStateFound = true
				planSetValues[index].Annotation = basetypes.NewStringNull()
			}
			if stateValue.MatchT.IsNull() {
				nullInStateFound = true
				planSetValues[index].MatchT = basetypes.NewStringNull()
			}
			if stateValue.Prio.IsNull() {
				nullInStateFound = true
				planSetValues[index].Prio = customTypes.NewVzRsAnyToProvPrioStringNull()
			}
			if stateValue.TnVzBrCPName.IsNull() {
				nullInStateFound = true
				planSetValues[index].TnVzBrCPName = basetypes.NewStringNull()
			}
			if !nullInStateFound {
				// when there are no null fields we can conclude the version supports all attributes in set
				break
			}
		}
	}
	planSet, _ := types.SetValueFrom(ctx, VzRsAnyToProvVzAnyType, planSetValues)
	return planSet

}

// TagAnnotationVzRsAnyToProvVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationVzRsAnyToProvVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationVzRsAnyToProvVzAnyResourceModel() TagAnnotationVzRsAnyToProvVzAnyResourceModel {
	return TagAnnotationVzRsAnyToProvVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagAnnotationVzRsAnyToProvVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// TagTagVzRsAnyToProvVzAnyResourceModel describes the resource data model for the children without relation ships.
type TagTagVzRsAnyToProvVzAnyResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagVzRsAnyToProvVzAnyResourceModel() TagTagVzRsAnyToProvVzAnyResourceModel {
	return TagTagVzRsAnyToProvVzAnyResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagTagVzRsAnyToProvVzAnyType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

type VzAnyResourceModelV1 struct {
	Annotation      types.String `tfsdk:"annotation"`
	Descr           types.String `tfsdk:"description"`
	Id              types.String `tfsdk:"id"`
	MatchT          types.String `tfsdk:"match_t"`
	NameAlias       types.String `tfsdk:"name_alias"`
	ParentDn        types.String `tfsdk:"vrf_dn"`
	PrefGrMemb      types.String `tfsdk:"pref_gr_memb"`
	VzRsAnyToCons   types.Set    `tfsdk:"relation_vz_rs_any_to_cons"`
	VzRsAnyToConsIf types.Set    `tfsdk:"relation_vz_rs_any_to_cons_if"`
	VzRsAnyToProv   types.Set    `tfsdk:"relation_vz_rs_any_to_prov"`
}

func (r *VzAnyResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		1: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"description": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"id": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"match_t": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"name_alias": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"vrf_dn": schema.StringAttribute{
						Required: true,
						Optional: false,
						Computed: false,
					},
					"pref_gr_memb": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_vz_rs_any_to_cons": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_vz_rs_any_to_cons_if": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_vz_rs_any_to_prov": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
				},
				Blocks: map[string]schema.Block{},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData VzAnyResourceModelV1

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := VzAnyResourceModel{
					Id:                   priorStateData.Id,
					ParentDn:             priorStateData.ParentDn,
					Annotation:           priorStateData.Annotation,
					Descr:                priorStateData.Descr,
					MatchT:               priorStateData.MatchT,
					Name:                 basetypes.NewStringNull(),
					NameAlias:            priorStateData.NameAlias,
					PrefGrMemb:           priorStateData.PrefGrMemb,
					DeprecatedMatchT:     priorStateData.MatchT,
					DeprecatedParentDn:   priorStateData.ParentDn,
					DeprecatedPrefGrMemb: priorStateData.PrefGrMemb,
				}

				upgradedStateData.TagAnnotation = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				upgradedStateData.TagTag = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				VzRsAnyToConsList := make([]VzRsAnyToConsVzAnyResourceModel, 0)
				var priorStateDataVzRsAnyToConsList []string
				priorStateData.VzRsAnyToCons.ElementsAs(ctx, &priorStateDataVzRsAnyToConsList, false)
				for _, priorStateDataVzRsAnyToCons := range priorStateDataVzRsAnyToConsList {
					VzRsAnyToCons := VzRsAnyToConsVzAnyResourceModel{
						Annotation:   basetypes.NewStringNull(),
						Prio:         customTypes.NewVzRsAnyToConsPrioStringNull(),
						TnVzBrCPName: basetypes.NewStringValue(GetMOName(priorStateDataVzRsAnyToCons)),
						TagAnnotation: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
						TagTag: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
					}
					VzRsAnyToConsList = append(VzRsAnyToConsList, VzRsAnyToCons)
				}
				VzRsAnyToConsSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsVzAnyType, VzRsAnyToConsList)
				upgradedStateData.VzRsAnyToCons = VzRsAnyToConsSet

				VzRsAnyToConsIfList := make([]VzRsAnyToConsIfVzAnyResourceModel, 0)
				var priorStateDataVzRsAnyToConsIfList []string
				priorStateData.VzRsAnyToConsIf.ElementsAs(ctx, &priorStateDataVzRsAnyToConsIfList, false)
				for _, priorStateDataVzRsAnyToConsIf := range priorStateDataVzRsAnyToConsIfList {
					VzRsAnyToConsIf := VzRsAnyToConsIfVzAnyResourceModel{
						Annotation:   basetypes.NewStringNull(),
						Prio:         customTypes.NewVzRsAnyToConsIfPrioStringNull(),
						TnVzCPIfName: basetypes.NewStringValue(GetMOName(priorStateDataVzRsAnyToConsIf)),
						TagAnnotation: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
						TagTag: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
					}
					VzRsAnyToConsIfList = append(VzRsAnyToConsIfList, VzRsAnyToConsIf)
				}
				VzRsAnyToConsIfSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsIfVzAnyType, VzRsAnyToConsIfList)
				upgradedStateData.VzRsAnyToConsIf = VzRsAnyToConsIfSet

				VzRsAnyToProvList := make([]VzRsAnyToProvVzAnyResourceModel, 0)
				var priorStateDataVzRsAnyToProvList []string
				priorStateData.VzRsAnyToProv.ElementsAs(ctx, &priorStateDataVzRsAnyToProvList, false)
				for _, priorStateDataVzRsAnyToProv := range priorStateDataVzRsAnyToProvList {
					VzRsAnyToProv := VzRsAnyToProvVzAnyResourceModel{
						Annotation:   basetypes.NewStringNull(),
						Prio:         customTypes.NewVzRsAnyToProvPrioStringNull(),
						TnVzBrCPName: basetypes.NewStringValue(GetMOName(priorStateDataVzRsAnyToProv)),
						TagAnnotation: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
						TagTag: basetypes.NewSetNull(types.ObjectType{
							AttrTypes: map[string]attr.Type{
								"key":   types.StringType,
								"value": types.StringType,
							},
						}),
					}
					VzRsAnyToProvList = append(VzRsAnyToProvList, VzRsAnyToProv)
				}
				VzRsAnyToProvSet, _ := types.SetValueFrom(ctx, VzRsAnyToProvVzAnyType, VzRsAnyToProvList)
				upgradedStateData.VzRsAnyToProv = VzRsAnyToProvSet

				var deprecatedVzRsAnyToConsList []string
				priorStateData.VzRsAnyToCons.ElementsAs(ctx, &deprecatedVzRsAnyToConsList, false)
				DeprecatedVzRsAnyToConsSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedVzRsAnyToConsList)
				upgradedStateData.DeprecatedVzRsAnyToCons = DeprecatedVzRsAnyToConsSet

				var deprecatedVzRsAnyToConsIfList []string
				priorStateData.VzRsAnyToConsIf.ElementsAs(ctx, &deprecatedVzRsAnyToConsIfList, false)
				DeprecatedVzRsAnyToConsIfSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedVzRsAnyToConsIfList)
				upgradedStateData.DeprecatedVzRsAnyToConsIf = DeprecatedVzRsAnyToConsIfSet

				var deprecatedVzRsAnyToProvList []string
				priorStateData.VzRsAnyToProv.ElementsAs(ctx, &deprecatedVzRsAnyToProvList, false)
				DeprecatedVzRsAnyToProvSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedVzRsAnyToProvList)
				upgradedStateData.DeprecatedVzRsAnyToProv = DeprecatedVzRsAnyToProvSet

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
	}
}

func setVzAnyLegacyAttributes(ctx context.Context, diags *diag.Diagnostics, data, staticData *VzAnyResourceModel, classReadInfo []interface{}) {
	data.DeprecatedParentDn = data.ParentDn
	attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
	for attributeName, attributeValue := range attributes {
		if attributeName == "matchT" {
			data.DeprecatedMatchT = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "prefGrMemb" {
			data.DeprecatedPrefGrMemb = basetypes.NewStringValue(attributeValue.(string))
		}
	}
	DeprecatedVzRsAnyToConsVzAnyList := make([]string, 0)
	DeprecatedVzRsAnyToConsIfVzAnyList := make([]string, 0)
	DeprecatedVzRsAnyToProvVzAnyList := make([]string, 0)

	_, ok := classReadInfo[0].(map[string]interface{})["children"]
	if ok {
		children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
		for _, child := range children {
			for childClassName, childClassDetails := range child.(map[string]interface{}) {
				childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
				if childClassName == "vzRsAnyToCons" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedVzRsAnyToConsVzAnyList, childAttributeValue.(string)) {
							DeprecatedVzRsAnyToConsVzAnyList = append(DeprecatedVzRsAnyToConsVzAnyList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "vzRsAnyToConsIf" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedVzRsAnyToConsIfVzAnyList, childAttributeValue.(string)) {
							DeprecatedVzRsAnyToConsIfVzAnyList = append(DeprecatedVzRsAnyToConsIfVzAnyList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "vzRsAnyToProv" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedVzRsAnyToProvVzAnyList, childAttributeValue.(string)) {
							DeprecatedVzRsAnyToProvVzAnyList = append(DeprecatedVzRsAnyToProvVzAnyList, childAttributeValue.(string))
						}
					}
				}
			}
		}
		vzRsAnyToConsSet, _ := types.SetValueFrom(ctx, data.DeprecatedVzRsAnyToCons.ElementType(ctx), DeprecatedVzRsAnyToConsVzAnyList)
		data.DeprecatedVzRsAnyToCons = vzRsAnyToConsSet
		vzRsAnyToConsIfSet, _ := types.SetValueFrom(ctx, data.DeprecatedVzRsAnyToConsIf.ElementType(ctx), DeprecatedVzRsAnyToConsIfVzAnyList)
		data.DeprecatedVzRsAnyToConsIf = vzRsAnyToConsIfSet
		vzRsAnyToProvSet, _ := types.SetValueFrom(ctx, data.DeprecatedVzRsAnyToProv.ElementType(ctx), DeprecatedVzRsAnyToProvVzAnyList)
		data.DeprecatedVzRsAnyToProv = vzRsAnyToProvSet
	}
}

func (r *VzAnyResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if !req.Plan.Raw.IsNull() {
		var planData, stateData, configData *VzAnyResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		resp.Diagnostics.Append(req.Config.Get(ctx, &configData)...)

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) && !planData.ParentDn.IsUnknown() {
			setVzAnyId(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "vzAny", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !configData.DeprecatedMatchT.IsNull() {
			planData.MatchT = configData.DeprecatedMatchT
		}

		if !configData.DeprecatedParentDn.IsNull() {
			planData.ParentDn = configData.DeprecatedParentDn
		}

		if !configData.DeprecatedPrefGrMemb.IsNull() {
			planData.PrefGrMemb = configData.DeprecatedPrefGrMemb
		}

		if !configData.DeprecatedVzRsAnyToCons.IsNull() {
			VzRsAnyToConsList := make([]VzRsAnyToConsVzAnyResourceModel, 0)
			var attributeValues []basetypes.StringValue
			var newAttributeValues []VzRsAnyToConsVzAnyResourceModel
			planData.DeprecatedVzRsAnyToCons.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.VzRsAnyToCons.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				VzRsAnyToConsValue := VzRsAnyToConsVzAnyResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzBrCPName.ValueString() == GetMOName(attributeValue.ValueString()) {
						VzRsAnyToConsValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				tnVzBrCPNameValue := basetypes.NewStringUnknown()
				if !attributeValue.IsUnknown() {
					tnVzBrCPNameValue = basetypes.NewStringValue(GetMOName(attributeValue.ValueString()))
				}
				VzRsAnyToCons := VzRsAnyToConsVzAnyResourceModel{
					TnVzBrCPName: tnVzBrCPNameValue,
				}

				if foundAttributeValue {
					VzRsAnyToCons.Annotation = VzRsAnyToConsValue.Annotation
					VzRsAnyToCons.Prio = VzRsAnyToConsValue.Prio
				} else {
					VzRsAnyToCons.Annotation = planData.Annotation
					VzRsAnyToCons.Prio = customTypes.NewVzRsAnyToConsPrioStringUnknown()
				}
				tagAnnotationVzRsAnyToConsVzAnyValue, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToConsVzAnyType, make([]TagAnnotationVzRsAnyToConsVzAnyResourceModel, 0))
				VzRsAnyToCons.TagAnnotation = tagAnnotationVzRsAnyToConsVzAnyValue
				tagTagVzRsAnyToConsVzAnyValue, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToConsVzAnyType, make([]TagTagVzRsAnyToConsVzAnyResourceModel, 0))
				VzRsAnyToCons.TagTag = tagTagVzRsAnyToConsVzAnyValue
				VzRsAnyToConsList = append(VzRsAnyToConsList, VzRsAnyToCons)
			}
			VzRsAnyToConsSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsVzAnyType, VzRsAnyToConsList)
			planData.VzRsAnyToCons = VzRsAnyToConsSet
		}

		if !configData.DeprecatedVzRsAnyToConsIf.IsNull() {
			VzRsAnyToConsIfList := make([]VzRsAnyToConsIfVzAnyResourceModel, 0)
			var attributeValues []basetypes.StringValue
			var newAttributeValues []VzRsAnyToConsIfVzAnyResourceModel
			planData.DeprecatedVzRsAnyToConsIf.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.VzRsAnyToConsIf.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				VzRsAnyToConsIfValue := VzRsAnyToConsIfVzAnyResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzCPIfName.ValueString() == GetMOName(attributeValue.ValueString()) {
						VzRsAnyToConsIfValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				tnVzCPIfNameValue := basetypes.NewStringUnknown()
				if !attributeValue.IsUnknown() {
					tnVzCPIfNameValue = basetypes.NewStringValue(GetMOName(attributeValue.ValueString()))
				}
				VzRsAnyToConsIf := VzRsAnyToConsIfVzAnyResourceModel{
					TnVzCPIfName: tnVzCPIfNameValue,
				}

				if foundAttributeValue {
					VzRsAnyToConsIf.Annotation = VzRsAnyToConsIfValue.Annotation
					VzRsAnyToConsIf.Prio = VzRsAnyToConsIfValue.Prio
				} else {
					VzRsAnyToConsIf.Annotation = planData.Annotation
					VzRsAnyToConsIf.Prio = customTypes.NewVzRsAnyToConsIfPrioStringUnknown()
				}
				tagAnnotationVzRsAnyToConsIfVzAnyValue, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToConsIfVzAnyType, make([]TagAnnotationVzRsAnyToConsIfVzAnyResourceModel, 0))
				VzRsAnyToConsIf.TagAnnotation = tagAnnotationVzRsAnyToConsIfVzAnyValue
				tagTagVzRsAnyToConsIfVzAnyValue, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToConsIfVzAnyType, make([]TagTagVzRsAnyToConsIfVzAnyResourceModel, 0))
				VzRsAnyToConsIf.TagTag = tagTagVzRsAnyToConsIfVzAnyValue
				VzRsAnyToConsIfList = append(VzRsAnyToConsIfList, VzRsAnyToConsIf)
			}
			VzRsAnyToConsIfSet, _ := types.SetValueFrom(ctx, VzRsAnyToConsIfVzAnyType, VzRsAnyToConsIfList)
			planData.VzRsAnyToConsIf = VzRsAnyToConsIfSet
		}

		if !configData.DeprecatedVzRsAnyToProv.IsNull() {
			VzRsAnyToProvList := make([]VzRsAnyToProvVzAnyResourceModel, 0)
			var attributeValues []basetypes.StringValue
			var newAttributeValues []VzRsAnyToProvVzAnyResourceModel
			planData.DeprecatedVzRsAnyToProv.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.VzRsAnyToProv.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				VzRsAnyToProvValue := VzRsAnyToProvVzAnyResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzBrCPName.ValueString() == GetMOName(attributeValue.ValueString()) {
						VzRsAnyToProvValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				tnVzBrCPNameValue := basetypes.NewStringUnknown()
				if !attributeValue.IsUnknown() {
					tnVzBrCPNameValue = basetypes.NewStringValue(GetMOName(attributeValue.ValueString()))
				}
				VzRsAnyToProv := VzRsAnyToProvVzAnyResourceModel{
					TnVzBrCPName: tnVzBrCPNameValue,
				}

				if foundAttributeValue {
					VzRsAnyToProv.Annotation = VzRsAnyToProvValue.Annotation
					VzRsAnyToProv.MatchT = VzRsAnyToProvValue.MatchT
					VzRsAnyToProv.Prio = VzRsAnyToProvValue.Prio
				} else {
					VzRsAnyToProv.Annotation = planData.Annotation
					VzRsAnyToProv.MatchT = basetypes.NewStringUnknown()
					VzRsAnyToProv.Prio = customTypes.NewVzRsAnyToProvPrioStringUnknown()
				}
				tagAnnotationVzRsAnyToProvVzAnyValue, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToProvVzAnyType, make([]TagAnnotationVzRsAnyToProvVzAnyResourceModel, 0))
				VzRsAnyToProv.TagAnnotation = tagAnnotationVzRsAnyToProvVzAnyValue
				tagTagVzRsAnyToProvVzAnyValue, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToProvVzAnyType, make([]TagTagVzRsAnyToProvVzAnyResourceModel, 0))
				VzRsAnyToProv.TagTag = tagTagVzRsAnyToProvVzAnyValue
				VzRsAnyToProvList = append(VzRsAnyToProvList, VzRsAnyToProv)
			}
			VzRsAnyToProvSet, _ := types.SetValueFrom(ctx, VzRsAnyToProvVzAnyType, VzRsAnyToProvList)
			planData.VzRsAnyToProv = VzRsAnyToProvSet
		}

		// Workaround to compare the state with plan to avoid plan changes with only known after apply
		if stateData != nil {
			avoidVzAnyPlanChangeForKnownAfterApplyOnly(ctx, planData, stateData, configData)
		}

		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func avoidVzAnyPlanChangeForKnownAfterApplyOnly(ctx context.Context, planData, stateData, configData *VzAnyResourceModel) {
	// Set read-only and deprecated attributes in planData from stateData
	if configData.DeprecatedMatchT.IsNull() {
		planData.DeprecatedMatchT = stateData.DeprecatedMatchT
	}
	if configData.DeprecatedParentDn.IsNull() {
		planData.DeprecatedParentDn = stateData.DeprecatedParentDn
	}
	if configData.DeprecatedPrefGrMemb.IsNull() {
		planData.DeprecatedPrefGrMemb = stateData.DeprecatedPrefGrMemb
	}
	if configData.DeprecatedVzRsAnyToCons.IsNull() {
		planData.DeprecatedVzRsAnyToCons = stateData.DeprecatedVzRsAnyToCons
	}
	if configData.DeprecatedVzRsAnyToConsIf.IsNull() {
		planData.DeprecatedVzRsAnyToConsIf = stateData.DeprecatedVzRsAnyToConsIf
	}
	if configData.DeprecatedVzRsAnyToProv.IsNull() {
		planData.DeprecatedVzRsAnyToProv = stateData.DeprecatedVzRsAnyToProv
	}

	// Compare the string representation of the planData and stateData because structs cannot be compared directly
	if fmt.Sprintf("%s", planData) != fmt.Sprintf("%s", stateData) {
		if configData.DeprecatedMatchT.IsNull() {
			planData.DeprecatedMatchT = basetypes.NewStringUnknown()
		}
		if configData.DeprecatedParentDn.IsNull() {
			planData.DeprecatedParentDn = basetypes.NewStringUnknown()
		}
		if configData.DeprecatedPrefGrMemb.IsNull() {
			planData.DeprecatedPrefGrMemb = basetypes.NewStringUnknown()
		}
		if configData.DeprecatedVzRsAnyToCons.IsNull() {
			planData.DeprecatedVzRsAnyToCons = basetypes.NewSetUnknown(basetypes.StringType{})
		}
		if configData.DeprecatedVzRsAnyToConsIf.IsNull() {
			planData.DeprecatedVzRsAnyToConsIf = basetypes.NewSetUnknown(basetypes.StringType{})
		}
		if configData.DeprecatedVzRsAnyToProv.IsNull() {
			planData.DeprecatedVzRsAnyToProv = basetypes.NewSetUnknown(basetypes.StringType{})
		}
	}
}

func (r *VzAnyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_any")
	resp.TypeName = req.ProviderTypeName + "_any"
	tflog.Debug(ctx, "End metadata of resource: aci_any")
}

func (r *VzAnyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_any")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The any resource for the 'vzAny' class",
		Version:             2,

		Attributes: map[string]schema.Attribute{
			// Deprecated attributes
			"match_t": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'match_t' is deprecated, please refer to 'match_criteria' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("match_criteria"),
					}...),
				},
			},
			"vrf_dn": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'vrf_dn' is deprecated, please refer to 'parent_dn' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("parent_dn"),
					}...),
				},
			},
			"pref_gr_memb": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'pref_gr_memb' is deprecated, please refer to 'preferred_group_member' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("preferred_group_member"),
					}...),
				},
			},
			"relation_vz_rs_any_to_cons": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_vz_rs_any_to_cons' is deprecated, please refer to 'relation_to_consumer_contracts' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_consumer_contracts"),
					}...),
				},
			},
			"relation_vz_rs_any_to_cons_if": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_vz_rs_any_to_cons_if' is deprecated, please refer to 'relation_to_contract_interfaces' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_contract_interfaces"),
					}...),
				},
			},
			"relation_vz_rs_any_to_prov": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_vz_rs_any_to_prov' is deprecated, please refer to 'relation_to_provider_contracts' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_provider_contracts"),
					}...),
				},
			},
			// End of deprecated attributes
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the Any object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"parent_dn": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("vrf_dn"),
					}...),
				},
			},
			"annotation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Default:             stringdefault.StaticString(globalAnnotation),
				MarkdownDescription: `The annotation of the Any object.`,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The description of the Any object.`,
			},
			"match_criteria": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("All", "AtleastOne", "AtmostOne", "None"),
				},
				MarkdownDescription: `The provider label match criteria.`,
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The name of the Any object.`,
			},
			"name_alias": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The name alias of the Any object.`,
			},
			"preferred_group_member": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("disabled", "enabled"),
				},
				MarkdownDescription: `Parameter used to determine whether the EPG is part of the preferred group. Members of this group are allowed to communicate without contracts.`,
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"relation_to_consumer_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to the binary contract profile.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
					SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(VzRsAnyToConsVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Relation From Any To Consumer Contract object.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.VzRsAnyToConsPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"contract_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the Contract object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
			"relation_to_contract_interfaces": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to a contract interface. A contract interface can be used as a contract consumption interface when a consumer consumes the contract by associating it to a consumption interface provided by the provider in the consumer's domain. A consumer can associate with the contract consumption interface when it is provided by the provider in the consumer's domain. Note that a contract consumption interface represents one or more subjects defined under the contract. By associating to an interface, an endpoint group starts consuming all the subjects represented by the interface. Also note that a contract can be defined under one tenant, but its interfaces can be defined in other tenants. A contract's interface will be used by the entities (endpoint groups) present in other tenants to participate in that contract. By this flexibility, tenants we will be able to participate in a single contract, which is defined at some third place. A contract interface is parented by a tenant. Note that this relation is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
					SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(VzRsAnyToConsIfVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Relation From Any To Contract Interface object.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.VzRsAnyToConsIfPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"imported_contract_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the imported Contract object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
			"relation_to_provider_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to a binary contract profile.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
					SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(VzRsAnyToProvVzAnySetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Relation From Any To Provider Contract object.`,
						},
						"match_criteria": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("All", "AtleastOne", "AtmostOne", "None"),
							},
							MarkdownDescription: `The provider label match criteria.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.VzRsAnyToProvPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"contract_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the Contract object.`,
						},
						"annotations": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
						"tags": schema.SetNestedAttribute{
							MarkdownDescription: ``,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The key used to uniquely identify this configuration object.`,
									},
									"value": schema.StringAttribute{
										Required: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
										MarkdownDescription: `The value of the property.`,
									},
								},
							},
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
	tflog.Debug(ctx, "End schema of resource: aci_any")
}

func (r *VzAnyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_any")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_any")
}

func (r *VzAnyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_any")
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *VzAnyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		setVzAnyId(ctx, stateData)
	}
	getAndSetVzAnyAttributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The vzAny object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	}

	var data *VzAnyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Id.IsUnknown() || data.Id.IsNull() {
		setVzAnyId(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_any with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationVzAnyResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagVzAnyResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	var vzRsAnyToConsPlan, vzRsAnyToConsState []VzRsAnyToConsVzAnyResourceModel
	data.VzRsAnyToCons.ElementsAs(ctx, &vzRsAnyToConsPlan, false)
	stateData.VzRsAnyToCons.ElementsAs(ctx, &vzRsAnyToConsState, false)
	var vzRsAnyToConsIfPlan, vzRsAnyToConsIfState []VzRsAnyToConsIfVzAnyResourceModel
	data.VzRsAnyToConsIf.ElementsAs(ctx, &vzRsAnyToConsIfPlan, false)
	stateData.VzRsAnyToConsIf.ElementsAs(ctx, &vzRsAnyToConsIfState, false)
	var vzRsAnyToProvPlan, vzRsAnyToProvState []VzRsAnyToProvVzAnyResourceModel
	data.VzRsAnyToProv.ElementsAs(ctx, &vzRsAnyToProvPlan, false)
	stateData.VzRsAnyToProv.ElementsAs(ctx, &vzRsAnyToProvState, false)
	jsonPayload := getVzAnyCreateJsonPayload(ctx, &resp.Diagnostics, true, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState, vzRsAnyToConsPlan, vzRsAnyToConsState, vzRsAnyToConsIfPlan, vzRsAnyToConsIfState, vzRsAnyToProvPlan, vzRsAnyToProvState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetVzAnyAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_any with id '%s'", data.Id.ValueString()))
}

func (r *VzAnyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_any")
	var data *VzAnyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_any with id '%s'", data.Id.ValueString()))

	getAndSetVzAnyAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *VzAnyResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_any with id '%s'", data.Id.ValueString()))
}

func (r *VzAnyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_any")
	var data *VzAnyResourceModel
	var stateData *VzAnyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_any with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationVzAnyResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagVzAnyResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	var vzRsAnyToConsPlan, vzRsAnyToConsState []VzRsAnyToConsVzAnyResourceModel
	data.VzRsAnyToCons.ElementsAs(ctx, &vzRsAnyToConsPlan, false)
	stateData.VzRsAnyToCons.ElementsAs(ctx, &vzRsAnyToConsState, false)
	var vzRsAnyToConsIfPlan, vzRsAnyToConsIfState []VzRsAnyToConsIfVzAnyResourceModel
	data.VzRsAnyToConsIf.ElementsAs(ctx, &vzRsAnyToConsIfPlan, false)
	stateData.VzRsAnyToConsIf.ElementsAs(ctx, &vzRsAnyToConsIfState, false)
	var vzRsAnyToProvPlan, vzRsAnyToProvState []VzRsAnyToProvVzAnyResourceModel
	data.VzRsAnyToProv.ElementsAs(ctx, &vzRsAnyToProvPlan, false)
	stateData.VzRsAnyToProv.ElementsAs(ctx, &vzRsAnyToProvState, false)
	jsonPayload := getVzAnyCreateJsonPayload(ctx, &resp.Diagnostics, false, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState, vzRsAnyToConsPlan, vzRsAnyToConsState, vzRsAnyToConsIfPlan, vzRsAnyToConsIfState, vzRsAnyToProvPlan, vzRsAnyToProvState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetVzAnyAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_any with id '%s'", data.Id.ValueString()))
}

func (r *VzAnyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_any")
	var data *VzAnyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_any with id '%s'", data.Id.ValueString()))
	parentDnMessage := "Delete on apic is only possible when deleting the parent object with dn"
	parentDn := data.Id.ValueString()
	if parentDn == "" {
		parentDnMessage = fmt.Sprintf("%s.", parentDnMessage)
	} else {
		parentDnMessage = fmt.Sprintf("%s '%s'.", parentDnMessage, parentDn)
	}
	message := fmt.Sprintf("resource with dn '%s' not removed from apic", data.Id.ValueString())
	messageDetail := fmt.Sprintf("Only removing resource from state because apic does not allow deletion of class 'vzAny' objects. %s", parentDnMessage)
	resp.Diagnostics.AddWarning(message, messageDetail)
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_any with id '%s'", data.Id.ValueString()))
}

func (r *VzAnyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_any")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	var stateData *VzAnyResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_any with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_any")
}

func getAndSetVzAnyAttributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *VzAnyResourceModel) {
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=full&rsp-subtree-class=%s", data.Id.ValueString(), "vzAny,tagAnnotation,tagTag,vzRsAnyToCons,vzRsAnyToConsIf,vzRsAnyToProv,tagAnnotation,tagTag,tagAnnotation,tagTag,tagAnnotation,tagTag"), "GET", nil)

	readData := getEmptyVzAnyResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("vzAny").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("vzAny").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					readData.Id = basetypes.NewStringValue(attributeValue.(string))
					setVzAnyParentDn(ctx, attributeValue.(string), readData)
				}
				if attributeName == "annotation" {
					readData.Annotation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "descr" {
					readData.Descr = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "matchT" {
					readData.MatchT = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "name" {
					readData.Name = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "nameAlias" {
					readData.NameAlias = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "prefGrMemb" {
					readData.PrefGrMemb = basetypes.NewStringValue(attributeValue.(string))
				}
			}
			TagAnnotationVzAnyList := make([]TagAnnotationVzAnyResourceModel, 0)
			TagTagVzAnyList := make([]TagTagVzAnyResourceModel, 0)
			VzRsAnyToConsVzAnyList := make([]VzRsAnyToConsVzAnyResourceModel, 0)
			VzRsAnyToConsIfVzAnyList := make([]VzRsAnyToConsIfVzAnyResourceModel, 0)
			VzRsAnyToProvVzAnyList := make([]VzRsAnyToProvVzAnyResourceModel, 0)
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						if childClassName == "tagAnnotation" {
							TagAnnotationVzAny := getEmptyTagAnnotationVzAnyResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagAnnotationVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagAnnotationVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagAnnotationVzAnyList = append(TagAnnotationVzAnyList, TagAnnotationVzAny)
						}
						if childClassName == "tagTag" {
							TagTagVzAny := getEmptyTagTagVzAnyResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagTagVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagTagVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagTagVzAnyList = append(TagTagVzAnyList, TagTagVzAny)
						}
						if childClassName == "vzRsAnyToCons" {
							VzRsAnyToConsVzAny := getEmptyVzRsAnyToConsVzAnyResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									VzRsAnyToConsVzAny.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									VzRsAnyToConsVzAny.Prio = customTypes.NewVzRsAnyToConsPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzBrCPName" {
									VzRsAnyToConsVzAny.TnVzBrCPName = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagAnnotationVzRsAnyToConsVzAnyList := make([]TagAnnotationVzRsAnyToConsVzAnyResourceModel, 0)
							TagTagVzRsAnyToConsVzAnyList := make([]TagTagVzRsAnyToConsVzAnyResourceModel, 0)
							childrenOfVzRsAnyToConsVzAny, childrenOfVzRsAnyToConsVzAnyExist := childClassDetails.(map[string]interface{})["children"]
							if childrenOfVzRsAnyToConsVzAnyExist {
								for _, childVzRsAnyToConsVzAny := range childrenOfVzRsAnyToConsVzAny.([]interface{}) {
									for childClassNameVzRsAnyToConsVzAny, childClassDetailsVzRsAnyToConsVzAny := range childVzRsAnyToConsVzAny.(map[string]interface{}) {
										if childClassNameVzRsAnyToConsVzAny == "tagAnnotation" {
											TagAnnotationVzRsAnyToConsVzAny := getEmptyTagAnnotationVzRsAnyToConsVzAnyResourceModel()
											tagAnnotationchildAttributeValue := childClassDetailsVzRsAnyToConsVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagAnnotationchildAttributeValue {
												if childAttributeName == "key" {
													TagAnnotationVzRsAnyToConsVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagAnnotationVzRsAnyToConsVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagAnnotationVzRsAnyToConsVzAnyList = append(TagAnnotationVzRsAnyToConsVzAnyList, TagAnnotationVzRsAnyToConsVzAny)
										}
										if childClassNameVzRsAnyToConsVzAny == "tagTag" {
											TagTagVzRsAnyToConsVzAny := getEmptyTagTagVzRsAnyToConsVzAnyResourceModel()
											tagTagchildAttributeValue := childClassDetailsVzRsAnyToConsVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagTagchildAttributeValue {
												if childAttributeName == "key" {
													TagTagVzRsAnyToConsVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagTagVzRsAnyToConsVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagTagVzRsAnyToConsVzAnyList = append(TagTagVzRsAnyToConsVzAnyList, TagTagVzRsAnyToConsVzAny)
										}
									}
								}
							}
							TagAnnotationVzRsAnyToConsVzAnySet, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToConsVzAnyType, TagAnnotationVzRsAnyToConsVzAnyList)
							VzRsAnyToConsVzAny.TagAnnotation = TagAnnotationVzRsAnyToConsVzAnySet
							TagTagVzRsAnyToConsVzAnySet, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToConsVzAnyType, TagTagVzRsAnyToConsVzAnyList)
							VzRsAnyToConsVzAny.TagTag = TagTagVzRsAnyToConsVzAnySet
							VzRsAnyToConsVzAnyList = append(VzRsAnyToConsVzAnyList, VzRsAnyToConsVzAny)
						}
						if childClassName == "vzRsAnyToConsIf" {
							VzRsAnyToConsIfVzAny := getEmptyVzRsAnyToConsIfVzAnyResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									VzRsAnyToConsIfVzAny.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									VzRsAnyToConsIfVzAny.Prio = customTypes.NewVzRsAnyToConsIfPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzCPIfName" {
									VzRsAnyToConsIfVzAny.TnVzCPIfName = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagAnnotationVzRsAnyToConsIfVzAnyList := make([]TagAnnotationVzRsAnyToConsIfVzAnyResourceModel, 0)
							TagTagVzRsAnyToConsIfVzAnyList := make([]TagTagVzRsAnyToConsIfVzAnyResourceModel, 0)
							childrenOfVzRsAnyToConsIfVzAny, childrenOfVzRsAnyToConsIfVzAnyExist := childClassDetails.(map[string]interface{})["children"]
							if childrenOfVzRsAnyToConsIfVzAnyExist {
								for _, childVzRsAnyToConsIfVzAny := range childrenOfVzRsAnyToConsIfVzAny.([]interface{}) {
									for childClassNameVzRsAnyToConsIfVzAny, childClassDetailsVzRsAnyToConsIfVzAny := range childVzRsAnyToConsIfVzAny.(map[string]interface{}) {
										if childClassNameVzRsAnyToConsIfVzAny == "tagAnnotation" {
											TagAnnotationVzRsAnyToConsIfVzAny := getEmptyTagAnnotationVzRsAnyToConsIfVzAnyResourceModel()
											tagAnnotationchildAttributeValue := childClassDetailsVzRsAnyToConsIfVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagAnnotationchildAttributeValue {
												if childAttributeName == "key" {
													TagAnnotationVzRsAnyToConsIfVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagAnnotationVzRsAnyToConsIfVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagAnnotationVzRsAnyToConsIfVzAnyList = append(TagAnnotationVzRsAnyToConsIfVzAnyList, TagAnnotationVzRsAnyToConsIfVzAny)
										}
										if childClassNameVzRsAnyToConsIfVzAny == "tagTag" {
											TagTagVzRsAnyToConsIfVzAny := getEmptyTagTagVzRsAnyToConsIfVzAnyResourceModel()
											tagTagchildAttributeValue := childClassDetailsVzRsAnyToConsIfVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagTagchildAttributeValue {
												if childAttributeName == "key" {
													TagTagVzRsAnyToConsIfVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagTagVzRsAnyToConsIfVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagTagVzRsAnyToConsIfVzAnyList = append(TagTagVzRsAnyToConsIfVzAnyList, TagTagVzRsAnyToConsIfVzAny)
										}
									}
								}
							}
							TagAnnotationVzRsAnyToConsIfVzAnySet, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToConsIfVzAnyType, TagAnnotationVzRsAnyToConsIfVzAnyList)
							VzRsAnyToConsIfVzAny.TagAnnotation = TagAnnotationVzRsAnyToConsIfVzAnySet
							TagTagVzRsAnyToConsIfVzAnySet, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToConsIfVzAnyType, TagTagVzRsAnyToConsIfVzAnyList)
							VzRsAnyToConsIfVzAny.TagTag = TagTagVzRsAnyToConsIfVzAnySet
							VzRsAnyToConsIfVzAnyList = append(VzRsAnyToConsIfVzAnyList, VzRsAnyToConsIfVzAny)
						}
						if childClassName == "vzRsAnyToProv" {
							VzRsAnyToProvVzAny := getEmptyVzRsAnyToProvVzAnyResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									VzRsAnyToProvVzAny.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "matchT" {
									VzRsAnyToProvVzAny.MatchT = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									VzRsAnyToProvVzAny.Prio = customTypes.NewVzRsAnyToProvPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzBrCPName" {
									VzRsAnyToProvVzAny.TnVzBrCPName = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagAnnotationVzRsAnyToProvVzAnyList := make([]TagAnnotationVzRsAnyToProvVzAnyResourceModel, 0)
							TagTagVzRsAnyToProvVzAnyList := make([]TagTagVzRsAnyToProvVzAnyResourceModel, 0)
							childrenOfVzRsAnyToProvVzAny, childrenOfVzRsAnyToProvVzAnyExist := childClassDetails.(map[string]interface{})["children"]
							if childrenOfVzRsAnyToProvVzAnyExist {
								for _, childVzRsAnyToProvVzAny := range childrenOfVzRsAnyToProvVzAny.([]interface{}) {
									for childClassNameVzRsAnyToProvVzAny, childClassDetailsVzRsAnyToProvVzAny := range childVzRsAnyToProvVzAny.(map[string]interface{}) {
										if childClassNameVzRsAnyToProvVzAny == "tagAnnotation" {
											TagAnnotationVzRsAnyToProvVzAny := getEmptyTagAnnotationVzRsAnyToProvVzAnyResourceModel()
											tagAnnotationchildAttributeValue := childClassDetailsVzRsAnyToProvVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagAnnotationchildAttributeValue {
												if childAttributeName == "key" {
													TagAnnotationVzRsAnyToProvVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagAnnotationVzRsAnyToProvVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagAnnotationVzRsAnyToProvVzAnyList = append(TagAnnotationVzRsAnyToProvVzAnyList, TagAnnotationVzRsAnyToProvVzAny)
										}
										if childClassNameVzRsAnyToProvVzAny == "tagTag" {
											TagTagVzRsAnyToProvVzAny := getEmptyTagTagVzRsAnyToProvVzAnyResourceModel()
											tagTagchildAttributeValue := childClassDetailsVzRsAnyToProvVzAny.(map[string]interface{})["attributes"].(map[string]interface{})
											for childAttributeName, childAttributeValue := range tagTagchildAttributeValue {
												if childAttributeName == "key" {
													TagTagVzRsAnyToProvVzAny.Key = basetypes.NewStringValue(childAttributeValue.(string))
												}
												if childAttributeName == "value" {
													TagTagVzRsAnyToProvVzAny.Value = basetypes.NewStringValue(childAttributeValue.(string))
												}
											}
											TagTagVzRsAnyToProvVzAnyList = append(TagTagVzRsAnyToProvVzAnyList, TagTagVzRsAnyToProvVzAny)
										}
									}
								}
							}
							TagAnnotationVzRsAnyToProvVzAnySet, _ := types.SetValueFrom(ctx, TagAnnotationVzRsAnyToProvVzAnyType, TagAnnotationVzRsAnyToProvVzAnyList)
							VzRsAnyToProvVzAny.TagAnnotation = TagAnnotationVzRsAnyToProvVzAnySet
							TagTagVzRsAnyToProvVzAnySet, _ := types.SetValueFrom(ctx, TagTagVzRsAnyToProvVzAnyType, TagTagVzRsAnyToProvVzAnyList)
							VzRsAnyToProvVzAny.TagTag = TagTagVzRsAnyToProvVzAnySet
							VzRsAnyToProvVzAnyList = append(VzRsAnyToProvVzAnyList, VzRsAnyToProvVzAny)
						}
					}
				}
			}
			tagAnnotationSet, _ := types.SetValueFrom(ctx, readData.TagAnnotation.ElementType(ctx), TagAnnotationVzAnyList)
			readData.TagAnnotation = tagAnnotationSet
			tagTagSet, _ := types.SetValueFrom(ctx, readData.TagTag.ElementType(ctx), TagTagVzAnyList)
			readData.TagTag = tagTagSet
			vzRsAnyToConsSet, _ := types.SetValueFrom(ctx, readData.VzRsAnyToCons.ElementType(ctx), VzRsAnyToConsVzAnyList)
			readData.VzRsAnyToCons = vzRsAnyToConsSet
			vzRsAnyToConsIfSet, _ := types.SetValueFrom(ctx, readData.VzRsAnyToConsIf.ElementType(ctx), VzRsAnyToConsIfVzAnyList)
			readData.VzRsAnyToConsIf = vzRsAnyToConsIfSet
			vzRsAnyToProvSet, _ := types.SetValueFrom(ctx, readData.VzRsAnyToProv.ElementType(ctx), VzRsAnyToProvVzAnyList)
			readData.VzRsAnyToProv = vzRsAnyToProvSet
			setVzAnyLegacyAttributes(ctx, diags, readData, data, classReadInfo)
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class 'vzAny'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		readData.Id = basetypes.NewStringNull()
	}
	*data = *readData
}

func getVzAnyRn(ctx context.Context, data *VzAnyResourceModel) string {
	return fmt.Sprintf("any")
}

func setVzAnyParentDn(ctx context.Context, dn string, data *VzAnyResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
}

func setVzAnyId(ctx context.Context, data *VzAnyResourceModel) {
	rn := getVzAnyRn(ctx, data)
	data.Id = types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
}

func getVzAnyTagAnnotationChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *VzAnyResourceModel, tagAnnotationVzAnyPlan, tagAnnotationVzAnyState []TagAnnotationVzAnyResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.TagAnnotation.IsNull() && !data.TagAnnotation.IsUnknown() {
		tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
		for _, tagAnnotationVzAny := range tagAnnotationVzAnyPlan {
			childMap := NewAciObject()
			if !tagAnnotationVzAny.Key.IsNull() && !tagAnnotationVzAny.Key.IsUnknown() {
				childMap.Attributes["key"] = tagAnnotationVzAny.Key.ValueString()
			}
			if !tagAnnotationVzAny.Value.IsNull() && !tagAnnotationVzAny.Value.IsUnknown() {
				childMap.Attributes["value"] = tagAnnotationVzAny.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			tagAnnotationIdentifier := TagAnnotationIdentifier{}
			tagAnnotationIdentifier.Key = tagAnnotationVzAny.Key
			tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
		}
		for _, tagAnnotation := range tagAnnotationVzAnyState {
			delete := true
			for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
				if tagAnnotationIdentifier.Key == tagAnnotation.Key {
					delete = false
					break
				}
			}
			if delete {
				tagAnnotationChildMapForDelete := NewAciObject()
				tagAnnotationChildMapForDelete.Attributes["status"] = "deleted"
				tagAnnotationChildMapForDelete.Attributes["key"] = tagAnnotation.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": tagAnnotationChildMapForDelete})
			}
		}
	} else {
		data.TagAnnotation = types.SetNull(data.TagAnnotation.ElementType(ctx))
	}

	return childPayloads
}

func getVzAnyTagTagChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *VzAnyResourceModel, tagTagVzAnyPlan, tagTagVzAnyState []TagTagVzAnyResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.TagTag.IsNull() && !data.TagTag.IsUnknown() {
		tagTagIdentifiers := []TagTagIdentifier{}
		for _, tagTagVzAny := range tagTagVzAnyPlan {
			childMap := NewAciObject()
			if !tagTagVzAny.Key.IsNull() && !tagTagVzAny.Key.IsUnknown() {
				childMap.Attributes["key"] = tagTagVzAny.Key.ValueString()
			}
			if !tagTagVzAny.Value.IsNull() && !tagTagVzAny.Value.IsUnknown() {
				childMap.Attributes["value"] = tagTagVzAny.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			tagTagIdentifier := TagTagIdentifier{}
			tagTagIdentifier.Key = tagTagVzAny.Key
			tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
		}
		for _, tagTag := range tagTagVzAnyState {
			delete := true
			for _, tagTagIdentifier := range tagTagIdentifiers {
				if tagTagIdentifier.Key == tagTag.Key {
					delete = false
					break
				}
			}
			if delete {
				tagTagChildMapForDelete := NewAciObject()
				tagTagChildMapForDelete.Attributes["status"] = "deleted"
				tagTagChildMapForDelete.Attributes["key"] = tagTag.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagTag": tagTagChildMapForDelete})
			}
		}
	} else {
		data.TagTag = types.SetNull(data.TagTag.ElementType(ctx))
	}

	return childPayloads
}

func getVzAnyVzRsAnyToConsChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *VzAnyResourceModel, vzRsAnyToConsVzAnyPlan, vzRsAnyToConsVzAnyState []VzRsAnyToConsVzAnyResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.VzRsAnyToCons.IsNull() && !data.VzRsAnyToCons.IsUnknown() {
		vzRsAnyToConsIdentifiers := []VzRsAnyToConsIdentifier{}
		for _, vzRsAnyToConsVzAny := range vzRsAnyToConsVzAnyPlan {
			VzRsAnyToConsVzAnyChildren := make([]map[string]interface{}, 0)
			childMap := NewAciObject()
			if !vzRsAnyToConsVzAny.Annotation.IsNull() && !vzRsAnyToConsVzAny.Annotation.IsUnknown() {
				childMap.Attributes["annotation"] = vzRsAnyToConsVzAny.Annotation.ValueString()
			} else {
				childMap.Attributes["annotation"] = globalAnnotation
			}
			if !vzRsAnyToConsVzAny.Prio.IsNull() && !vzRsAnyToConsVzAny.Prio.IsUnknown() {
				childMap.Attributes["prio"] = vzRsAnyToConsVzAny.Prio.ValueString()
			}
			if !vzRsAnyToConsVzAny.TnVzBrCPName.IsNull() && !vzRsAnyToConsVzAny.TnVzBrCPName.IsUnknown() {
				childMap.Attributes["tnVzBrCPName"] = vzRsAnyToConsVzAny.TnVzBrCPName.ValueString()
			}

			var tagAnnotationVzRsAnyToConsVzAnyPlan, tagAnnotationVzRsAnyToConsVzAnyState []TagAnnotationVzRsAnyToConsVzAnyResourceModel
			vzRsAnyToConsVzAny.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToConsVzAnyPlan, false)
			for _, tagAnnotationVzRsAnyToConsVzAnystate := range vzRsAnyToConsVzAnyState {
				tagAnnotationVzRsAnyToConsVzAnystate.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToConsVzAnyState, false)
			}
			if !vzRsAnyToConsVzAny.TagAnnotation.IsNull() && !vzRsAnyToConsVzAny.TagAnnotation.IsUnknown() {
				tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
				for _, tagAnnotationVzRsAnyToConsVzAny := range tagAnnotationVzRsAnyToConsVzAnyPlan {
					tagAnnotationVzRsAnyToConsVzAnyChildMap := NewAciObject()
					if !tagAnnotationVzRsAnyToConsVzAny.Key.IsNull() && !tagAnnotationVzRsAnyToConsVzAny.Key.IsUnknown() {
						tagAnnotationVzRsAnyToConsVzAnyChildMap.Attributes["key"] = tagAnnotationVzRsAnyToConsVzAny.Key.ValueString()
					}
					if !tagAnnotationVzRsAnyToConsVzAny.Value.IsNull() && !tagAnnotationVzRsAnyToConsVzAny.Value.IsUnknown() {
						tagAnnotationVzRsAnyToConsVzAnyChildMap.Attributes["value"] = tagAnnotationVzRsAnyToConsVzAny.Value.ValueString()
					}
					VzRsAnyToConsVzAnyChildren = append(VzRsAnyToConsVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToConsVzAnyChildMap})
					tagAnnotationIdentifier := TagAnnotationIdentifier{}
					tagAnnotationIdentifier.Key = tagAnnotationVzRsAnyToConsVzAny.Key
					tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
				}
				for _, tagAnnotationVzRsAnyToConsVzAny := range tagAnnotationVzRsAnyToConsVzAnyState {
					delete := true
					for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
						if tagAnnotationIdentifier.Key == tagAnnotationVzRsAnyToConsVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagAnnotationVzRsAnyToConsVzAnyChildMapForDelete := NewAciObject()
						tagAnnotationVzRsAnyToConsVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagAnnotationVzRsAnyToConsVzAnyChildMapForDelete.Attributes["key"] = tagAnnotationVzRsAnyToConsVzAny.Key.ValueString()
						VzRsAnyToConsVzAnyChildren = append(VzRsAnyToConsVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToConsVzAnyChildMapForDelete})
					}
				}
			}

			var tagTagVzRsAnyToConsVzAnyPlan, tagTagVzRsAnyToConsVzAnyState []TagTagVzRsAnyToConsVzAnyResourceModel
			vzRsAnyToConsVzAny.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToConsVzAnyPlan, false)
			for _, tagTagVzRsAnyToConsVzAnystate := range vzRsAnyToConsVzAnyState {
				tagTagVzRsAnyToConsVzAnystate.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToConsVzAnyState, false)
			}
			if !vzRsAnyToConsVzAny.TagTag.IsNull() && !vzRsAnyToConsVzAny.TagTag.IsUnknown() {
				tagTagIdentifiers := []TagTagIdentifier{}
				for _, tagTagVzRsAnyToConsVzAny := range tagTagVzRsAnyToConsVzAnyPlan {
					tagTagVzRsAnyToConsVzAnyChildMap := NewAciObject()
					if !tagTagVzRsAnyToConsVzAny.Key.IsNull() && !tagTagVzRsAnyToConsVzAny.Key.IsUnknown() {
						tagTagVzRsAnyToConsVzAnyChildMap.Attributes["key"] = tagTagVzRsAnyToConsVzAny.Key.ValueString()
					}
					if !tagTagVzRsAnyToConsVzAny.Value.IsNull() && !tagTagVzRsAnyToConsVzAny.Value.IsUnknown() {
						tagTagVzRsAnyToConsVzAnyChildMap.Attributes["value"] = tagTagVzRsAnyToConsVzAny.Value.ValueString()
					}
					VzRsAnyToConsVzAnyChildren = append(VzRsAnyToConsVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToConsVzAnyChildMap})
					tagTagIdentifier := TagTagIdentifier{}
					tagTagIdentifier.Key = tagTagVzRsAnyToConsVzAny.Key
					tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
				}
				for _, tagTagVzRsAnyToConsVzAny := range tagTagVzRsAnyToConsVzAnyState {
					delete := true
					for _, tagTagIdentifier := range tagTagIdentifiers {
						if tagTagIdentifier.Key == tagTagVzRsAnyToConsVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagTagVzRsAnyToConsVzAnyChildMapForDelete := NewAciObject()
						tagTagVzRsAnyToConsVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagTagVzRsAnyToConsVzAnyChildMapForDelete.Attributes["key"] = tagTagVzRsAnyToConsVzAny.Key.ValueString()
						VzRsAnyToConsVzAnyChildren = append(VzRsAnyToConsVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToConsVzAnyChildMapForDelete})
					}
				}
			}
			childMap.Children = VzRsAnyToConsVzAnyChildren
			childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToCons": childMap})
			vzRsAnyToConsIdentifier := VzRsAnyToConsIdentifier{}
			vzRsAnyToConsIdentifier.TnVzBrCPName = vzRsAnyToConsVzAny.TnVzBrCPName
			vzRsAnyToConsIdentifiers = append(vzRsAnyToConsIdentifiers, vzRsAnyToConsIdentifier)
		}
		for _, vzRsAnyToCons := range vzRsAnyToConsVzAnyState {
			delete := true
			for _, vzRsAnyToConsIdentifier := range vzRsAnyToConsIdentifiers {
				if vzRsAnyToConsIdentifier.TnVzBrCPName == vzRsAnyToCons.TnVzBrCPName {
					delete = false
					break
				}
			}
			if delete {
				vzRsAnyToConsChildMapForDelete := NewAciObject()
				vzRsAnyToConsChildMapForDelete.Attributes["status"] = "deleted"
				vzRsAnyToConsChildMapForDelete.Attributes["tnVzBrCPName"] = vzRsAnyToCons.TnVzBrCPName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToCons": vzRsAnyToConsChildMapForDelete})
			}
		}
	} else {
		data.VzRsAnyToCons = types.SetNull(data.VzRsAnyToCons.ElementType(ctx))
	}

	return childPayloads
}

func getVzAnyVzRsAnyToConsIfChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *VzAnyResourceModel, vzRsAnyToConsIfVzAnyPlan, vzRsAnyToConsIfVzAnyState []VzRsAnyToConsIfVzAnyResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.VzRsAnyToConsIf.IsNull() && !data.VzRsAnyToConsIf.IsUnknown() {
		vzRsAnyToConsIfIdentifiers := []VzRsAnyToConsIfIdentifier{}
		for _, vzRsAnyToConsIfVzAny := range vzRsAnyToConsIfVzAnyPlan {
			VzRsAnyToConsIfVzAnyChildren := make([]map[string]interface{}, 0)
			childMap := NewAciObject()
			if !vzRsAnyToConsIfVzAny.Annotation.IsNull() && !vzRsAnyToConsIfVzAny.Annotation.IsUnknown() {
				childMap.Attributes["annotation"] = vzRsAnyToConsIfVzAny.Annotation.ValueString()
			} else {
				childMap.Attributes["annotation"] = globalAnnotation
			}
			if !vzRsAnyToConsIfVzAny.Prio.IsNull() && !vzRsAnyToConsIfVzAny.Prio.IsUnknown() {
				childMap.Attributes["prio"] = vzRsAnyToConsIfVzAny.Prio.ValueString()
			}
			if !vzRsAnyToConsIfVzAny.TnVzCPIfName.IsNull() && !vzRsAnyToConsIfVzAny.TnVzCPIfName.IsUnknown() {
				childMap.Attributes["tnVzCPIfName"] = vzRsAnyToConsIfVzAny.TnVzCPIfName.ValueString()
			}

			var tagAnnotationVzRsAnyToConsIfVzAnyPlan, tagAnnotationVzRsAnyToConsIfVzAnyState []TagAnnotationVzRsAnyToConsIfVzAnyResourceModel
			vzRsAnyToConsIfVzAny.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToConsIfVzAnyPlan, false)
			for _, tagAnnotationVzRsAnyToConsIfVzAnystate := range vzRsAnyToConsIfVzAnyState {
				tagAnnotationVzRsAnyToConsIfVzAnystate.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToConsIfVzAnyState, false)
			}
			if !vzRsAnyToConsIfVzAny.TagAnnotation.IsNull() && !vzRsAnyToConsIfVzAny.TagAnnotation.IsUnknown() {
				tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
				for _, tagAnnotationVzRsAnyToConsIfVzAny := range tagAnnotationVzRsAnyToConsIfVzAnyPlan {
					tagAnnotationVzRsAnyToConsIfVzAnyChildMap := NewAciObject()
					if !tagAnnotationVzRsAnyToConsIfVzAny.Key.IsNull() && !tagAnnotationVzRsAnyToConsIfVzAny.Key.IsUnknown() {
						tagAnnotationVzRsAnyToConsIfVzAnyChildMap.Attributes["key"] = tagAnnotationVzRsAnyToConsIfVzAny.Key.ValueString()
					}
					if !tagAnnotationVzRsAnyToConsIfVzAny.Value.IsNull() && !tagAnnotationVzRsAnyToConsIfVzAny.Value.IsUnknown() {
						tagAnnotationVzRsAnyToConsIfVzAnyChildMap.Attributes["value"] = tagAnnotationVzRsAnyToConsIfVzAny.Value.ValueString()
					}
					VzRsAnyToConsIfVzAnyChildren = append(VzRsAnyToConsIfVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToConsIfVzAnyChildMap})
					tagAnnotationIdentifier := TagAnnotationIdentifier{}
					tagAnnotationIdentifier.Key = tagAnnotationVzRsAnyToConsIfVzAny.Key
					tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
				}
				for _, tagAnnotationVzRsAnyToConsIfVzAny := range tagAnnotationVzRsAnyToConsIfVzAnyState {
					delete := true
					for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
						if tagAnnotationIdentifier.Key == tagAnnotationVzRsAnyToConsIfVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagAnnotationVzRsAnyToConsIfVzAnyChildMapForDelete := NewAciObject()
						tagAnnotationVzRsAnyToConsIfVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagAnnotationVzRsAnyToConsIfVzAnyChildMapForDelete.Attributes["key"] = tagAnnotationVzRsAnyToConsIfVzAny.Key.ValueString()
						VzRsAnyToConsIfVzAnyChildren = append(VzRsAnyToConsIfVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToConsIfVzAnyChildMapForDelete})
					}
				}
			}

			var tagTagVzRsAnyToConsIfVzAnyPlan, tagTagVzRsAnyToConsIfVzAnyState []TagTagVzRsAnyToConsIfVzAnyResourceModel
			vzRsAnyToConsIfVzAny.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToConsIfVzAnyPlan, false)
			for _, tagTagVzRsAnyToConsIfVzAnystate := range vzRsAnyToConsIfVzAnyState {
				tagTagVzRsAnyToConsIfVzAnystate.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToConsIfVzAnyState, false)
			}
			if !vzRsAnyToConsIfVzAny.TagTag.IsNull() && !vzRsAnyToConsIfVzAny.TagTag.IsUnknown() {
				tagTagIdentifiers := []TagTagIdentifier{}
				for _, tagTagVzRsAnyToConsIfVzAny := range tagTagVzRsAnyToConsIfVzAnyPlan {
					tagTagVzRsAnyToConsIfVzAnyChildMap := NewAciObject()
					if !tagTagVzRsAnyToConsIfVzAny.Key.IsNull() && !tagTagVzRsAnyToConsIfVzAny.Key.IsUnknown() {
						tagTagVzRsAnyToConsIfVzAnyChildMap.Attributes["key"] = tagTagVzRsAnyToConsIfVzAny.Key.ValueString()
					}
					if !tagTagVzRsAnyToConsIfVzAny.Value.IsNull() && !tagTagVzRsAnyToConsIfVzAny.Value.IsUnknown() {
						tagTagVzRsAnyToConsIfVzAnyChildMap.Attributes["value"] = tagTagVzRsAnyToConsIfVzAny.Value.ValueString()
					}
					VzRsAnyToConsIfVzAnyChildren = append(VzRsAnyToConsIfVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToConsIfVzAnyChildMap})
					tagTagIdentifier := TagTagIdentifier{}
					tagTagIdentifier.Key = tagTagVzRsAnyToConsIfVzAny.Key
					tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
				}
				for _, tagTagVzRsAnyToConsIfVzAny := range tagTagVzRsAnyToConsIfVzAnyState {
					delete := true
					for _, tagTagIdentifier := range tagTagIdentifiers {
						if tagTagIdentifier.Key == tagTagVzRsAnyToConsIfVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagTagVzRsAnyToConsIfVzAnyChildMapForDelete := NewAciObject()
						tagTagVzRsAnyToConsIfVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagTagVzRsAnyToConsIfVzAnyChildMapForDelete.Attributes["key"] = tagTagVzRsAnyToConsIfVzAny.Key.ValueString()
						VzRsAnyToConsIfVzAnyChildren = append(VzRsAnyToConsIfVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToConsIfVzAnyChildMapForDelete})
					}
				}
			}
			childMap.Children = VzRsAnyToConsIfVzAnyChildren
			childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToConsIf": childMap})
			vzRsAnyToConsIfIdentifier := VzRsAnyToConsIfIdentifier{}
			vzRsAnyToConsIfIdentifier.TnVzCPIfName = vzRsAnyToConsIfVzAny.TnVzCPIfName
			vzRsAnyToConsIfIdentifiers = append(vzRsAnyToConsIfIdentifiers, vzRsAnyToConsIfIdentifier)
		}
		for _, vzRsAnyToConsIf := range vzRsAnyToConsIfVzAnyState {
			delete := true
			for _, vzRsAnyToConsIfIdentifier := range vzRsAnyToConsIfIdentifiers {
				if vzRsAnyToConsIfIdentifier.TnVzCPIfName == vzRsAnyToConsIf.TnVzCPIfName {
					delete = false
					break
				}
			}
			if delete {
				vzRsAnyToConsIfChildMapForDelete := NewAciObject()
				vzRsAnyToConsIfChildMapForDelete.Attributes["status"] = "deleted"
				vzRsAnyToConsIfChildMapForDelete.Attributes["tnVzCPIfName"] = vzRsAnyToConsIf.TnVzCPIfName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToConsIf": vzRsAnyToConsIfChildMapForDelete})
			}
		}
	} else {
		data.VzRsAnyToConsIf = types.SetNull(data.VzRsAnyToConsIf.ElementType(ctx))
	}

	return childPayloads
}

func getVzAnyVzRsAnyToProvChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *VzAnyResourceModel, vzRsAnyToProvVzAnyPlan, vzRsAnyToProvVzAnyState []VzRsAnyToProvVzAnyResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.VzRsAnyToProv.IsNull() && !data.VzRsAnyToProv.IsUnknown() {
		vzRsAnyToProvIdentifiers := []VzRsAnyToProvIdentifier{}
		for _, vzRsAnyToProvVzAny := range vzRsAnyToProvVzAnyPlan {
			VzRsAnyToProvVzAnyChildren := make([]map[string]interface{}, 0)
			childMap := NewAciObject()
			if !vzRsAnyToProvVzAny.Annotation.IsNull() && !vzRsAnyToProvVzAny.Annotation.IsUnknown() {
				childMap.Attributes["annotation"] = vzRsAnyToProvVzAny.Annotation.ValueString()
			} else {
				childMap.Attributes["annotation"] = globalAnnotation
			}
			if !vzRsAnyToProvVzAny.MatchT.IsNull() && !vzRsAnyToProvVzAny.MatchT.IsUnknown() {
				childMap.Attributes["matchT"] = vzRsAnyToProvVzAny.MatchT.ValueString()
			}
			if !vzRsAnyToProvVzAny.Prio.IsNull() && !vzRsAnyToProvVzAny.Prio.IsUnknown() {
				childMap.Attributes["prio"] = vzRsAnyToProvVzAny.Prio.ValueString()
			}
			if !vzRsAnyToProvVzAny.TnVzBrCPName.IsNull() && !vzRsAnyToProvVzAny.TnVzBrCPName.IsUnknown() {
				childMap.Attributes["tnVzBrCPName"] = vzRsAnyToProvVzAny.TnVzBrCPName.ValueString()
			}

			var tagAnnotationVzRsAnyToProvVzAnyPlan, tagAnnotationVzRsAnyToProvVzAnyState []TagAnnotationVzRsAnyToProvVzAnyResourceModel
			vzRsAnyToProvVzAny.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToProvVzAnyPlan, false)
			for _, tagAnnotationVzRsAnyToProvVzAnystate := range vzRsAnyToProvVzAnyState {
				tagAnnotationVzRsAnyToProvVzAnystate.TagAnnotation.ElementsAs(ctx, &tagAnnotationVzRsAnyToProvVzAnyState, false)
			}
			if !vzRsAnyToProvVzAny.TagAnnotation.IsNull() && !vzRsAnyToProvVzAny.TagAnnotation.IsUnknown() {
				tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
				for _, tagAnnotationVzRsAnyToProvVzAny := range tagAnnotationVzRsAnyToProvVzAnyPlan {
					tagAnnotationVzRsAnyToProvVzAnyChildMap := NewAciObject()
					if !tagAnnotationVzRsAnyToProvVzAny.Key.IsNull() && !tagAnnotationVzRsAnyToProvVzAny.Key.IsUnknown() {
						tagAnnotationVzRsAnyToProvVzAnyChildMap.Attributes["key"] = tagAnnotationVzRsAnyToProvVzAny.Key.ValueString()
					}
					if !tagAnnotationVzRsAnyToProvVzAny.Value.IsNull() && !tagAnnotationVzRsAnyToProvVzAny.Value.IsUnknown() {
						tagAnnotationVzRsAnyToProvVzAnyChildMap.Attributes["value"] = tagAnnotationVzRsAnyToProvVzAny.Value.ValueString()
					}
					VzRsAnyToProvVzAnyChildren = append(VzRsAnyToProvVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToProvVzAnyChildMap})
					tagAnnotationIdentifier := TagAnnotationIdentifier{}
					tagAnnotationIdentifier.Key = tagAnnotationVzRsAnyToProvVzAny.Key
					tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
				}
				for _, tagAnnotationVzRsAnyToProvVzAny := range tagAnnotationVzRsAnyToProvVzAnyState {
					delete := true
					for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
						if tagAnnotationIdentifier.Key == tagAnnotationVzRsAnyToProvVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagAnnotationVzRsAnyToProvVzAnyChildMapForDelete := NewAciObject()
						tagAnnotationVzRsAnyToProvVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagAnnotationVzRsAnyToProvVzAnyChildMapForDelete.Attributes["key"] = tagAnnotationVzRsAnyToProvVzAny.Key.ValueString()
						VzRsAnyToProvVzAnyChildren = append(VzRsAnyToProvVzAnyChildren, map[string]interface{}{"tagAnnotation": tagAnnotationVzRsAnyToProvVzAnyChildMapForDelete})
					}
				}
			}

			var tagTagVzRsAnyToProvVzAnyPlan, tagTagVzRsAnyToProvVzAnyState []TagTagVzRsAnyToProvVzAnyResourceModel
			vzRsAnyToProvVzAny.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToProvVzAnyPlan, false)
			for _, tagTagVzRsAnyToProvVzAnystate := range vzRsAnyToProvVzAnyState {
				tagTagVzRsAnyToProvVzAnystate.TagTag.ElementsAs(ctx, &tagTagVzRsAnyToProvVzAnyState, false)
			}
			if !vzRsAnyToProvVzAny.TagTag.IsNull() && !vzRsAnyToProvVzAny.TagTag.IsUnknown() {
				tagTagIdentifiers := []TagTagIdentifier{}
				for _, tagTagVzRsAnyToProvVzAny := range tagTagVzRsAnyToProvVzAnyPlan {
					tagTagVzRsAnyToProvVzAnyChildMap := NewAciObject()
					if !tagTagVzRsAnyToProvVzAny.Key.IsNull() && !tagTagVzRsAnyToProvVzAny.Key.IsUnknown() {
						tagTagVzRsAnyToProvVzAnyChildMap.Attributes["key"] = tagTagVzRsAnyToProvVzAny.Key.ValueString()
					}
					if !tagTagVzRsAnyToProvVzAny.Value.IsNull() && !tagTagVzRsAnyToProvVzAny.Value.IsUnknown() {
						tagTagVzRsAnyToProvVzAnyChildMap.Attributes["value"] = tagTagVzRsAnyToProvVzAny.Value.ValueString()
					}
					VzRsAnyToProvVzAnyChildren = append(VzRsAnyToProvVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToProvVzAnyChildMap})
					tagTagIdentifier := TagTagIdentifier{}
					tagTagIdentifier.Key = tagTagVzRsAnyToProvVzAny.Key
					tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
				}
				for _, tagTagVzRsAnyToProvVzAny := range tagTagVzRsAnyToProvVzAnyState {
					delete := true
					for _, tagTagIdentifier := range tagTagIdentifiers {
						if tagTagIdentifier.Key == tagTagVzRsAnyToProvVzAny.Key {
							delete = false
							break
						}
					}
					if delete {
						tagTagVzRsAnyToProvVzAnyChildMapForDelete := NewAciObject()
						tagTagVzRsAnyToProvVzAnyChildMapForDelete.Attributes["status"] = "deleted"
						tagTagVzRsAnyToProvVzAnyChildMapForDelete.Attributes["key"] = tagTagVzRsAnyToProvVzAny.Key.ValueString()
						VzRsAnyToProvVzAnyChildren = append(VzRsAnyToProvVzAnyChildren, map[string]interface{}{"tagTag": tagTagVzRsAnyToProvVzAnyChildMapForDelete})
					}
				}
			}
			childMap.Children = VzRsAnyToProvVzAnyChildren
			childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToProv": childMap})
			vzRsAnyToProvIdentifier := VzRsAnyToProvIdentifier{}
			vzRsAnyToProvIdentifier.TnVzBrCPName = vzRsAnyToProvVzAny.TnVzBrCPName
			vzRsAnyToProvIdentifiers = append(vzRsAnyToProvIdentifiers, vzRsAnyToProvIdentifier)
		}
		for _, vzRsAnyToProv := range vzRsAnyToProvVzAnyState {
			delete := true
			for _, vzRsAnyToProvIdentifier := range vzRsAnyToProvIdentifiers {
				if vzRsAnyToProvIdentifier.TnVzBrCPName == vzRsAnyToProv.TnVzBrCPName {
					delete = false
					break
				}
			}
			if delete {
				vzRsAnyToProvChildMapForDelete := NewAciObject()
				vzRsAnyToProvChildMapForDelete.Attributes["status"] = "deleted"
				vzRsAnyToProvChildMapForDelete.Attributes["tnVzBrCPName"] = vzRsAnyToProv.TnVzBrCPName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"vzRsAnyToProv": vzRsAnyToProvChildMapForDelete})
			}
		}
	} else {
		data.VzRsAnyToProv = types.SetNull(data.VzRsAnyToProv.ElementType(ctx))
	}

	return childPayloads
}

func getVzAnyCreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *VzAnyResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationVzAnyResourceModel, tagTagPlan, tagTagState []TagTagVzAnyResourceModel, vzRsAnyToConsPlan, vzRsAnyToConsState []VzRsAnyToConsVzAnyResourceModel, vzRsAnyToConsIfPlan, vzRsAnyToConsIfState []VzRsAnyToConsIfVzAnyResourceModel, vzRsAnyToProvPlan, vzRsAnyToProvState []VzRsAnyToProvVzAnyResourceModel) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}
	childPayloads := []map[string]interface{}{}

	TagAnnotationchildPayloads := getVzAnyTagAnnotationChildPayloads(ctx, diags, data, tagAnnotationPlan, tagAnnotationState)
	if TagAnnotationchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagAnnotationchildPayloads...)

	TagTagchildPayloads := getVzAnyTagTagChildPayloads(ctx, diags, data, tagTagPlan, tagTagState)
	if TagTagchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagTagchildPayloads...)

	VzRsAnyToConschildPayloads := getVzAnyVzRsAnyToConsChildPayloads(ctx, diags, data, vzRsAnyToConsPlan, vzRsAnyToConsState)
	if VzRsAnyToConschildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, VzRsAnyToConschildPayloads...)

	VzRsAnyToConsIfchildPayloads := getVzAnyVzRsAnyToConsIfChildPayloads(ctx, diags, data, vzRsAnyToConsIfPlan, vzRsAnyToConsIfState)
	if VzRsAnyToConsIfchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, VzRsAnyToConsIfchildPayloads...)

	VzRsAnyToProvchildPayloads := getVzAnyVzRsAnyToProvChildPayloads(ctx, diags, data, vzRsAnyToProvPlan, vzRsAnyToProvState)
	if VzRsAnyToProvchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, VzRsAnyToProvchildPayloads...)

	payloadMap["children"] = childPayloads
	if !data.Annotation.IsNull() && !data.Annotation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["annotation"] = data.Annotation.ValueString()
	}
	if !data.Descr.IsNull() && !data.Descr.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["descr"] = data.Descr.ValueString()
	}
	if !data.MatchT.IsNull() && !data.MatchT.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["matchT"] = data.MatchT.ValueString()
	}
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["name"] = data.Name.ValueString()
	}
	if !data.NameAlias.IsNull() && !data.NameAlias.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["nameAlias"] = data.NameAlias.ValueString()
	}
	if !data.PrefGrMemb.IsNull() && !data.PrefGrMemb.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["prefGrMemb"] = data.PrefGrMemb.ValueString()
	}
	payload, err := json.Marshal(map[string]interface{}{"vzAny": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
