// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	customTypes "github.com/CiscoDevNet/terraform-provider-aci/v2/internal/custom_types"
	"github.com/CiscoDevNet/terraform-provider-aci/v2/internal/validators"
	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &FvAEPgResource{}
var _ resource.ResourceWithImportState = &FvAEPgResource{}

func NewFvAEPgResource() resource.Resource {
	return &FvAEPgResource{}
}

// FvAEPgResource defines the resource implementation.
type FvAEPgResource struct {
	client *client.Client
}

// FvAEPgResourceModel describes the resource data model.
type FvAEPgResourceModel struct {
	Id                                 types.String                      `tfsdk:"id"`
	ParentDn                           types.String                      `tfsdk:"parent_dn"`
	Annotation                         types.String                      `tfsdk:"annotation"`
	Descr                              types.String                      `tfsdk:"description"`
	ExceptionTag                       types.String                      `tfsdk:"contract_exception_tag"`
	FloodOnEncap                       types.String                      `tfsdk:"flood_in_encapsulation"`
	FwdCtrl                            types.String                      `tfsdk:"forwarding_control"`
	HasMcastSource                     types.String                      `tfsdk:"has_multicast_source"`
	IsAttrBasedEPg                     types.String                      `tfsdk:"useg_epg"`
	MatchT                             types.String                      `tfsdk:"match_criteria"`
	Name                               types.String                      `tfsdk:"name"`
	NameAlias                          types.String                      `tfsdk:"name_alias"`
	PcEnfPref                          types.String                      `tfsdk:"intra_epg_isolation"`
	PcTag                              types.String                      `tfsdk:"pc_tag"`
	PrefGrMemb                         types.String                      `tfsdk:"preferred_group_member"`
	Prio                               customTypes.FvAEPgPrioStringValue `tfsdk:"priority"`
	Shutdown                           types.String                      `tfsdk:"admin_state"`
	FvCrtrn                            types.Object                      `tfsdk:"epg_useg_block_statement"`
	FvRsAEPgMonPol                     types.Object                      `tfsdk:"relation_to_application_epg_monitoring_policy"`
	FvRsBd                             types.Object                      `tfsdk:"relation_to_bridge_domain"`
	FvRsCons                           types.Set                         `tfsdk:"relation_to_consumed_contracts"`
	FvRsConsIf                         types.Set                         `tfsdk:"relation_to_imported_contracts"`
	FvRsCustQosPol                     types.Object                      `tfsdk:"relation_to_custom_qos_policy"`
	FvRsDomAtt                         types.Set                         `tfsdk:"relation_to_domains"`
	FvRsDppPol                         types.Object                      `tfsdk:"relation_to_data_plane_policing_policy"`
	FvRsFcPathAtt                      types.Set                         `tfsdk:"relation_to_fibre_channel_paths"`
	FvRsIntraEpg                       types.Set                         `tfsdk:"relation_to_intra_epg_contracts"`
	FvRsNodeAtt                        types.Set                         `tfsdk:"relation_to_static_leafs"`
	FvRsPathAtt                        types.Set                         `tfsdk:"relation_to_static_paths"`
	FvRsProtBy                         types.Set                         `tfsdk:"relation_to_taboo_contracts"`
	FvRsProv                           types.Set                         `tfsdk:"relation_to_provided_contracts"`
	FvRsSecInherited                   types.Set                         `tfsdk:"relation_to_contract_masters"`
	FvRsTrustCtrl                      types.Object                      `tfsdk:"relation_to_trust_control_policy"`
	TagAnnotation                      types.Set                         `tfsdk:"annotations"`
	TagTag                             types.Set                         `tfsdk:"tags"`
	DeprecatedExceptionTag             types.String                      `tfsdk:"exception_tag"`
	DeprecatedFloodOnEncap             types.String                      `tfsdk:"flood_on_encap"`
	DeprecatedFwdCtrl                  types.String                      `tfsdk:"fwd_ctrl"`
	DeprecatedHasMcastSource           types.String                      `tfsdk:"has_mcast_source"`
	DeprecatedIsAttrBasedEPg           types.String                      `tfsdk:"is_attr_based_epg"`
	DeprecatedMatchT                   types.String                      `tfsdk:"match_t"`
	DeprecatedParentDn                 types.String                      `tfsdk:"application_profile_dn"`
	DeprecatedPcEnfPref                types.String                      `tfsdk:"pc_enf_pref"`
	DeprecatedPrefGrMemb               types.String                      `tfsdk:"pref_gr_memb"`
	DeprecatedPrio                     types.String                      `tfsdk:"prio"`
	DeprecatedShutdown                 types.String                      `tfsdk:"shutdown"`
	Deprecated_relation_fv_rs_prov_def types.Set                         `tfsdk:"relation_fv_rs_prov_def"`
	DeprecatedFvRsAEPgMonPol           types.String                      `tfsdk:"relation_fv_rs_aepg_mon_pol"`
	DeprecatedFvRsBd                   types.String                      `tfsdk:"relation_fv_rs_bd"`
	DeprecatedFvRsCons                 types.Set                         `tfsdk:"relation_fv_rs_cons"`
	DeprecatedFvRsSecInherited         types.Set                         `tfsdk:"relation_fv_rs_sec_inherited"`
	DeprecatedFvRsCustQosPol           types.String                      `tfsdk:"relation_fv_rs_cust_qos_pol"`
	DeprecatedFvRsDppPol               types.String                      `tfsdk:"relation_fv_rs_dpp_pol"`
	DeprecatedFvRsFcPathAtt            types.Set                         `tfsdk:"relation_fv_rs_fc_path_att"`
	DeprecatedFvRsConsIf               types.Set                         `tfsdk:"relation_fv_rs_cons_if"`
	DeprecatedFvRsIntraEpg             types.Set                         `tfsdk:"relation_fv_rs_intra_epg"`
	DeprecatedFvRsProv                 types.Set                         `tfsdk:"relation_fv_rs_prov"`
	DeprecatedFvRsPathAtt              types.Set                         `tfsdk:"relation_fv_rs_path_att"`
	DeprecatedFvRsProtBy               types.Set                         `tfsdk:"relation_fv_rs_prot_by"`
	DeprecatedFvRsTrustCtrl            types.String                      `tfsdk:"relation_fv_rs_trust_ctrl"`
	DeprecatedFvRsNodeAtt              types.Set                         `tfsdk:"relation_fv_rs_node_att"`
}

func getEmptyFvAEPgResourceModel() *FvAEPgResourceModel {
	return &FvAEPgResourceModel{
		Id:             basetypes.NewStringNull(),
		ParentDn:       basetypes.NewStringNull(),
		Annotation:     basetypes.NewStringNull(),
		Descr:          basetypes.NewStringNull(),
		ExceptionTag:   basetypes.NewStringNull(),
		FloodOnEncap:   basetypes.NewStringNull(),
		FwdCtrl:        basetypes.NewStringNull(),
		HasMcastSource: basetypes.NewStringNull(),
		IsAttrBasedEPg: basetypes.NewStringNull(),
		MatchT:         basetypes.NewStringNull(),
		Name:           basetypes.NewStringNull(),
		NameAlias:      basetypes.NewStringNull(),
		PcEnfPref:      basetypes.NewStringNull(),
		PcTag:          basetypes.NewStringNull(),
		PrefGrMemb:     basetypes.NewStringNull(),
		Prio:           customTypes.NewFvAEPgPrioStringNull(),
		Shutdown:       basetypes.NewStringNull(),
		FvCrtrn: types.ObjectNull(map[string]attr.Type{
			"annotation":  types.StringType,
			"description": types.StringType,
			"match":       types.StringType,
			"name":        types.StringType,
			"name_alias":  types.StringType,
			"owner_key":   types.StringType,
			"owner_tag":   types.StringType,
			"precedence":  types.StringType,
			"scope":       types.StringType,
		}),
		FvRsAEPgMonPol: types.ObjectNull(map[string]attr.Type{
			"annotation":             types.StringType,
			"monitoring_policy_name": types.StringType,
		}),
		FvRsBd: types.ObjectNull(map[string]attr.Type{
			"annotation":         types.StringType,
			"bridge_domain_name": types.StringType,
		}),
		FvRsCons: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":    types.StringType,
				"priority":      types.StringType,
				"contract_name": types.StringType,
			},
		}),
		FvRsConsIf: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":             types.StringType,
				"priority":               types.StringType,
				"imported_contract_name": types.StringType,
			},
		}),
		FvRsCustQosPol: types.ObjectNull(map[string]attr.Type{
			"annotation":             types.StringType,
			"custom_qos_policy_name": types.StringType,
		}),
		FvRsDomAtt: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":                    types.StringType,
				"binding_type":                  types.StringType,
				"class_preference":              types.StringType,
				"custom_epg_name":               types.StringType,
				"delimiter":                     types.StringType,
				"encapsulation":                 types.StringType,
				"encapsulation_mode":            types.StringType,
				"epg_cos":                       types.StringType,
				"epg_cos_pref":                  types.StringType,
				"deployment_immediacy":          types.StringType,
				"ipam_dhcp_override":            types.StringType,
				"ipam_enabled":                  types.StringType,
				"ipam_gateway":                  types.StringType,
				"lag_policy_name":               types.StringType,
				"netflow_direction":             types.StringType,
				"enable_netflow":                types.StringType,
				"number_of_ports":               types.StringType,
				"port_allocation":               types.StringType,
				"primary_encapsulation":         types.StringType,
				"primary_encapsulation_inner":   types.StringType,
				"resolution_immediacy":          types.StringType,
				"secondary_encapsulation_inner": types.StringType,
				"switching_mode":                types.StringType,
				"target_dn":                     types.StringType,
				"untagged":                      types.StringType,
			},
		}),
		FvRsDppPol: types.ObjectNull(map[string]attr.Type{
			"annotation":                      types.StringType,
			"data_plane_policing_policy_name": types.StringType,
		}),
		FvRsFcPathAtt: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":  types.StringType,
				"description": types.StringType,
				"target_dn":   types.StringType,
				"vsan":        types.StringType,
				"vsan_mode":   types.StringType,
			},
		}),
		FvRsIntraEpg: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":    types.StringType,
				"contract_name": types.StringType,
			},
		}),
		FvRsNodeAtt: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":           types.StringType,
				"description":          types.StringType,
				"encapsulation":        types.StringType,
				"deployment_immediacy": types.StringType,
				"mode":                 types.StringType,
				"target_dn":            types.StringType,
			},
		}),
		FvRsPathAtt: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":            types.StringType,
				"description":           types.StringType,
				"encapsulation":         types.StringType,
				"deployment_immediacy":  types.StringType,
				"mode":                  types.StringType,
				"primary_encapsulation": types.StringType,
				"target_dn":             types.StringType,
			},
		}),
		FvRsProtBy: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":          types.StringType,
				"taboo_contract_name": types.StringType,
			},
		}),
		FvRsProv: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":     types.StringType,
				"match_criteria": types.StringType,
				"priority":       types.StringType,
				"contract_name":  types.StringType,
			},
		}),
		FvRsSecInherited: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation": types.StringType,
				"target_dn":  types.StringType,
			},
		}),
		FvRsTrustCtrl: types.ObjectNull(map[string]attr.Type{
			"annotation":                types.StringType,
			"trust_control_policy_name": types.StringType,
		}),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		DeprecatedExceptionTag:             types.String{},
		DeprecatedFloodOnEncap:             types.String{},
		DeprecatedFwdCtrl:                  types.String{},
		DeprecatedHasMcastSource:           types.String{},
		DeprecatedIsAttrBasedEPg:           types.String{},
		DeprecatedMatchT:                   types.String{},
		DeprecatedParentDn:                 types.String{},
		DeprecatedPcEnfPref:                types.String{},
		DeprecatedPrefGrMemb:               types.String{},
		DeprecatedPrio:                     types.String{},
		DeprecatedShutdown:                 types.String{},
		Deprecated_relation_fv_rs_prov_def: types.SetNull(types.StringType),
		DeprecatedFvRsAEPgMonPol:           types.String{},
		DeprecatedFvRsBd:                   types.String{},
		DeprecatedFvRsCons:                 types.SetNull(types.StringType),
		DeprecatedFvRsSecInherited:         types.SetNull(types.StringType),
		DeprecatedFvRsCustQosPol:           types.String{},
		DeprecatedFvRsDppPol:               types.String{},
		DeprecatedFvRsFcPathAtt:            types.SetNull(types.StringType),
		DeprecatedFvRsConsIf:               types.SetNull(types.StringType),
		DeprecatedFvRsIntraEpg:             types.SetNull(types.StringType),
		DeprecatedFvRsProv:                 types.SetNull(types.StringType),
		DeprecatedFvRsPathAtt:              types.SetNull(types.StringType),
		DeprecatedFvRsProtBy:               types.SetNull(types.StringType),
		DeprecatedFvRsTrustCtrl:            types.String{},
		DeprecatedFvRsNodeAtt:              types.SetNull(deprecatedFvRsNodeAttType),
	}
}

// FvCrtrnFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvCrtrnFvAEPgResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	Descr      types.String `tfsdk:"description"`
	Match      types.String `tfsdk:"match"`
	Name       types.String `tfsdk:"name"`
	NameAlias  types.String `tfsdk:"name_alias"`
	OwnerKey   types.String `tfsdk:"owner_key"`
	OwnerTag   types.String `tfsdk:"owner_tag"`
	Prec       types.String `tfsdk:"precedence"`
	Scope      types.String `tfsdk:"scope"`
}

func getEmptyFvCrtrnFvAEPgResourceModel() FvCrtrnFvAEPgResourceModel {
	return FvCrtrnFvAEPgResourceModel{
		Annotation: basetypes.NewStringNull(),
		Descr:      basetypes.NewStringNull(),
		Match:      basetypes.NewStringNull(),
		Name:       basetypes.NewStringNull(),
		NameAlias:  basetypes.NewStringNull(),
		OwnerKey:   basetypes.NewStringNull(),
		OwnerTag:   basetypes.NewStringNull(),
		Prec:       basetypes.NewStringNull(),
		Scope:      basetypes.NewStringNull(),
	}
}

var FvCrtrnFvAEPgType = map[string]attr.Type{
	"annotation":  types.StringType,
	"description": types.StringType,
	"match":       types.StringType,
	"name":        types.StringType,
	"name_alias":  types.StringType,
	"owner_key":   types.StringType,
	"owner_tag":   types.StringType,
	"precedence":  types.StringType,
	"scope":       types.StringType,
}

// FvRsAEPgMonPolFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsAEPgMonPolFvAEPgResourceModel struct {
	Annotation      types.String `tfsdk:"annotation"`
	TnMonEPGPolName types.String `tfsdk:"monitoring_policy_name"`
}

func getEmptyFvRsAEPgMonPolFvAEPgResourceModel() FvRsAEPgMonPolFvAEPgResourceModel {
	return FvRsAEPgMonPolFvAEPgResourceModel{
		Annotation:      basetypes.NewStringNull(),
		TnMonEPGPolName: basetypes.NewStringNull(),
	}
}

var FvRsAEPgMonPolFvAEPgType = map[string]attr.Type{
	"annotation":             types.StringType,
	"monitoring_policy_name": types.StringType,
}

// FvRsBdFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsBdFvAEPgResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	TnFvBDName types.String `tfsdk:"bridge_domain_name"`
}

func getEmptyFvRsBdFvAEPgResourceModel() FvRsBdFvAEPgResourceModel {
	return FvRsBdFvAEPgResourceModel{
		Annotation: basetypes.NewStringNull(),
		TnFvBDName: basetypes.NewStringNull(),
	}
}

var FvRsBdFvAEPgType = map[string]attr.Type{
	"annotation":         types.StringType,
	"bridge_domain_name": types.StringType,
}

// FvRsConsFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsConsFvAEPgResourceModel struct {
	Annotation   types.String                        `tfsdk:"annotation"`
	Prio         customTypes.FvRsConsPrioStringValue `tfsdk:"priority"`
	TnVzBrCPName types.String                        `tfsdk:"contract_name"`
}

func getEmptyFvRsConsFvAEPgResourceModel() FvRsConsFvAEPgResourceModel {
	return FvRsConsFvAEPgResourceModel{
		Annotation:   basetypes.NewStringNull(),
		Prio:         customTypes.NewFvRsConsPrioStringNull(),
		TnVzBrCPName: basetypes.NewStringNull(),
	}
}

// FvRsConsIfFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsConsIfFvAEPgResourceModel struct {
	Annotation   types.String                          `tfsdk:"annotation"`
	Prio         customTypes.FvRsConsIfPrioStringValue `tfsdk:"priority"`
	TnVzCPIfName types.String                          `tfsdk:"imported_contract_name"`
}

func getEmptyFvRsConsIfFvAEPgResourceModel() FvRsConsIfFvAEPgResourceModel {
	return FvRsConsIfFvAEPgResourceModel{
		Annotation:   basetypes.NewStringNull(),
		Prio:         customTypes.NewFvRsConsIfPrioStringNull(),
		TnVzCPIfName: basetypes.NewStringNull(),
	}
}

// FvRsCustQosPolFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsCustQosPolFvAEPgResourceModel struct {
	Annotation         types.String `tfsdk:"annotation"`
	TnQosCustomPolName types.String `tfsdk:"custom_qos_policy_name"`
}

func getEmptyFvRsCustQosPolFvAEPgResourceModel() FvRsCustQosPolFvAEPgResourceModel {
	return FvRsCustQosPolFvAEPgResourceModel{
		Annotation:         basetypes.NewStringNull(),
		TnQosCustomPolName: basetypes.NewStringNull(),
	}
}

var FvRsCustQosPolFvAEPgType = map[string]attr.Type{
	"annotation":             types.StringType,
	"custom_qos_policy_name": types.StringType,
}

// FvRsDomAttFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsDomAttFvAEPgResourceModel struct {
	Annotation          types.String `tfsdk:"annotation"`
	BindingType         types.String `tfsdk:"binding_type"`
	ClassPref           types.String `tfsdk:"class_preference"`
	CustomEpgName       types.String `tfsdk:"custom_epg_name"`
	Delimiter           types.String `tfsdk:"delimiter"`
	Encap               types.String `tfsdk:"encapsulation"`
	EncapMode           types.String `tfsdk:"encapsulation_mode"`
	EpgCos              types.String `tfsdk:"epg_cos"`
	EpgCosPref          types.String `tfsdk:"epg_cos_pref"`
	InstrImedcy         types.String `tfsdk:"deployment_immediacy"`
	IpamDhcpOverride    types.String `tfsdk:"ipam_dhcp_override"`
	IpamEnabled         types.String `tfsdk:"ipam_enabled"`
	IpamGateway         types.String `tfsdk:"ipam_gateway"`
	LagPolicyName       types.String `tfsdk:"lag_policy_name"`
	NetflowDir          types.String `tfsdk:"netflow_direction"`
	NetflowPref         types.String `tfsdk:"enable_netflow"`
	NumPorts            types.String `tfsdk:"number_of_ports"`
	PortAllocation      types.String `tfsdk:"port_allocation"`
	PrimaryEncap        types.String `tfsdk:"primary_encapsulation"`
	PrimaryEncapInner   types.String `tfsdk:"primary_encapsulation_inner"`
	ResImedcy           types.String `tfsdk:"resolution_immediacy"`
	SecondaryEncapInner types.String `tfsdk:"secondary_encapsulation_inner"`
	SwitchingMode       types.String `tfsdk:"switching_mode"`
	TDn                 types.String `tfsdk:"target_dn"`
	Untagged            types.String `tfsdk:"untagged"`
}

func getEmptyFvRsDomAttFvAEPgResourceModel() FvRsDomAttFvAEPgResourceModel {
	return FvRsDomAttFvAEPgResourceModel{
		Annotation:          basetypes.NewStringNull(),
		BindingType:         basetypes.NewStringNull(),
		ClassPref:           basetypes.NewStringNull(),
		CustomEpgName:       basetypes.NewStringNull(),
		Delimiter:           basetypes.NewStringNull(),
		Encap:               basetypes.NewStringNull(),
		EncapMode:           basetypes.NewStringNull(),
		EpgCos:              basetypes.NewStringNull(),
		EpgCosPref:          basetypes.NewStringNull(),
		InstrImedcy:         basetypes.NewStringNull(),
		IpamDhcpOverride:    basetypes.NewStringNull(),
		IpamEnabled:         basetypes.NewStringNull(),
		IpamGateway:         basetypes.NewStringNull(),
		LagPolicyName:       basetypes.NewStringNull(),
		NetflowDir:          basetypes.NewStringNull(),
		NetflowPref:         basetypes.NewStringNull(),
		NumPorts:            basetypes.NewStringNull(),
		PortAllocation:      basetypes.NewStringNull(),
		PrimaryEncap:        basetypes.NewStringNull(),
		PrimaryEncapInner:   basetypes.NewStringNull(),
		ResImedcy:           basetypes.NewStringNull(),
		SecondaryEncapInner: basetypes.NewStringNull(),
		SwitchingMode:       basetypes.NewStringNull(),
		TDn:                 basetypes.NewStringNull(),
		Untagged:            basetypes.NewStringNull(),
	}
}

// FvRsDppPolFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsDppPolFvAEPgResourceModel struct {
	Annotation      types.String `tfsdk:"annotation"`
	TnQosDppPolName types.String `tfsdk:"data_plane_policing_policy_name"`
}

func getEmptyFvRsDppPolFvAEPgResourceModel() FvRsDppPolFvAEPgResourceModel {
	return FvRsDppPolFvAEPgResourceModel{
		Annotation:      basetypes.NewStringNull(),
		TnQosDppPolName: basetypes.NewStringNull(),
	}
}

var FvRsDppPolFvAEPgType = map[string]attr.Type{
	"annotation":                      types.StringType,
	"data_plane_policing_policy_name": types.StringType,
}

// FvRsFcPathAttFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsFcPathAttFvAEPgResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	Descr      types.String `tfsdk:"description"`
	TDn        types.String `tfsdk:"target_dn"`
	Vsan       types.String `tfsdk:"vsan"`
	VsanMode   types.String `tfsdk:"vsan_mode"`
}

func getEmptyFvRsFcPathAttFvAEPgResourceModel() FvRsFcPathAttFvAEPgResourceModel {
	return FvRsFcPathAttFvAEPgResourceModel{
		Annotation: basetypes.NewStringNull(),
		Descr:      basetypes.NewStringNull(),
		TDn:        basetypes.NewStringNull(),
		Vsan:       basetypes.NewStringNull(),
		VsanMode:   basetypes.NewStringNull(),
	}
}

// FvRsIntraEpgFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsIntraEpgFvAEPgResourceModel struct {
	Annotation   types.String `tfsdk:"annotation"`
	TnVzBrCPName types.String `tfsdk:"contract_name"`
}

func getEmptyFvRsIntraEpgFvAEPgResourceModel() FvRsIntraEpgFvAEPgResourceModel {
	return FvRsIntraEpgFvAEPgResourceModel{
		Annotation:   basetypes.NewStringNull(),
		TnVzBrCPName: basetypes.NewStringNull(),
	}
}

// FvRsNodeAttFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsNodeAttFvAEPgResourceModel struct {
	Annotation  types.String `tfsdk:"annotation"`
	Descr       types.String `tfsdk:"description"`
	Encap       types.String `tfsdk:"encapsulation"`
	InstrImedcy types.String `tfsdk:"deployment_immediacy"`
	Mode        types.String `tfsdk:"mode"`
	TDn         types.String `tfsdk:"target_dn"`
}

func getEmptyFvRsNodeAttFvAEPgResourceModel() FvRsNodeAttFvAEPgResourceModel {
	return FvRsNodeAttFvAEPgResourceModel{
		Annotation:  basetypes.NewStringNull(),
		Descr:       basetypes.NewStringNull(),
		Encap:       basetypes.NewStringNull(),
		InstrImedcy: basetypes.NewStringNull(),
		Mode:        basetypes.NewStringNull(),
		TDn:         basetypes.NewStringNull(),
	}
}

// FvRsPathAttFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsPathAttFvAEPgResourceModel struct {
	Annotation   types.String `tfsdk:"annotation"`
	Descr        types.String `tfsdk:"description"`
	Encap        types.String `tfsdk:"encapsulation"`
	InstrImedcy  types.String `tfsdk:"deployment_immediacy"`
	Mode         types.String `tfsdk:"mode"`
	PrimaryEncap types.String `tfsdk:"primary_encapsulation"`
	TDn          types.String `tfsdk:"target_dn"`
}

func getEmptyFvRsPathAttFvAEPgResourceModel() FvRsPathAttFvAEPgResourceModel {
	return FvRsPathAttFvAEPgResourceModel{
		Annotation:   basetypes.NewStringNull(),
		Descr:        basetypes.NewStringNull(),
		Encap:        basetypes.NewStringNull(),
		InstrImedcy:  basetypes.NewStringNull(),
		Mode:         basetypes.NewStringNull(),
		PrimaryEncap: basetypes.NewStringNull(),
		TDn:          basetypes.NewStringNull(),
	}
}

// FvRsProtByFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsProtByFvAEPgResourceModel struct {
	Annotation    types.String `tfsdk:"annotation"`
	TnVzTabooName types.String `tfsdk:"taboo_contract_name"`
}

func getEmptyFvRsProtByFvAEPgResourceModel() FvRsProtByFvAEPgResourceModel {
	return FvRsProtByFvAEPgResourceModel{
		Annotation:    basetypes.NewStringNull(),
		TnVzTabooName: basetypes.NewStringNull(),
	}
}

// FvRsProvFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsProvFvAEPgResourceModel struct {
	Annotation   types.String                        `tfsdk:"annotation"`
	MatchT       types.String                        `tfsdk:"match_criteria"`
	Prio         customTypes.FvRsProvPrioStringValue `tfsdk:"priority"`
	TnVzBrCPName types.String                        `tfsdk:"contract_name"`
}

func getEmptyFvRsProvFvAEPgResourceModel() FvRsProvFvAEPgResourceModel {
	return FvRsProvFvAEPgResourceModel{
		Annotation:   basetypes.NewStringNull(),
		MatchT:       basetypes.NewStringNull(),
		Prio:         customTypes.NewFvRsProvPrioStringNull(),
		TnVzBrCPName: basetypes.NewStringNull(),
	}
}

// FvRsSecInheritedFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsSecInheritedFvAEPgResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	TDn        types.String `tfsdk:"target_dn"`
}

func getEmptyFvRsSecInheritedFvAEPgResourceModel() FvRsSecInheritedFvAEPgResourceModel {
	return FvRsSecInheritedFvAEPgResourceModel{
		Annotation: basetypes.NewStringNull(),
		TDn:        basetypes.NewStringNull(),
	}
}

// FvRsTrustCtrlFvAEPgResourceModel describes the resource data model for the children without relation ships.
type FvRsTrustCtrlFvAEPgResourceModel struct {
	Annotation            types.String `tfsdk:"annotation"`
	TnFhsTrustCtrlPolName types.String `tfsdk:"trust_control_policy_name"`
}

func getEmptyFvRsTrustCtrlFvAEPgResourceModel() FvRsTrustCtrlFvAEPgResourceModel {
	return FvRsTrustCtrlFvAEPgResourceModel{
		Annotation:            basetypes.NewStringNull(),
		TnFhsTrustCtrlPolName: basetypes.NewStringNull(),
	}
}

var FvRsTrustCtrlFvAEPgType = map[string]attr.Type{
	"annotation":                types.StringType,
	"trust_control_policy_name": types.StringType,
}

// TagAnnotationFvAEPgResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationFvAEPgResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationFvAEPgResourceModel() TagAnnotationFvAEPgResourceModel {
	return TagAnnotationFvAEPgResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

// TagTagFvAEPgResourceModel describes the resource data model for the children without relation ships.
type TagTagFvAEPgResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagFvAEPgResourceModel() TagTagFvAEPgResourceModel {
	return TagTagFvAEPgResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

type FvAEPgIdentifier struct {
	Name types.String
}

var deprecatedFvRsNodeAttType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"deployment_immediacy": basetypes.StringType{},
		"description":          basetypes.StringType{},
		"encap":                basetypes.StringType{},
		"mode":                 basetypes.StringType{},
		"node_dn":              basetypes.StringType{},
	},
}

type FvAEPgResourceModelV1 struct {
	Annotation                         types.String `tfsdk:"annotation"`
	Descr                              types.String `tfsdk:"description"`
	ExceptionTag                       types.String `tfsdk:"exception_tag"`
	FloodOnEncap                       types.String `tfsdk:"flood_on_encap"`
	FwdCtrl                            types.String `tfsdk:"fwd_ctrl"`
	HasMcastSource                     types.String `tfsdk:"has_mcast_source"`
	Id                                 types.String `tfsdk:"id"`
	IsAttrBasedEPg                     types.String `tfsdk:"is_attr_based_epg"`
	MatchT                             types.String `tfsdk:"match_t"`
	Name                               types.String `tfsdk:"name"`
	NameAlias                          types.String `tfsdk:"name_alias"`
	ParentDn                           types.String `tfsdk:"application_profile_dn"`
	PcEnfPref                          types.String `tfsdk:"pc_enf_pref"`
	PrefGrMemb                         types.String `tfsdk:"pref_gr_memb"`
	Prio                               types.String `tfsdk:"prio"`
	Shutdown                           types.String `tfsdk:"shutdown"`
	Deprecated_relation_fv_rs_prov_def types.Set    `tfsdk:"relation_fv_rs_prov_def"`
	FvRsAEPgMonPol                     types.String `tfsdk:"relation_fv_rs_aepg_mon_pol"`
	FvRsBd                             types.String `tfsdk:"relation_fv_rs_bd"`
	FvRsCons                           types.Set    `tfsdk:"relation_fv_rs_cons"`
	FvRsSecInherited                   types.Set    `tfsdk:"relation_fv_rs_sec_inherited"`
	FvRsCustQosPol                     types.String `tfsdk:"relation_fv_rs_cust_qos_pol"`
	FvRsDppPol                         types.String `tfsdk:"relation_fv_rs_dpp_pol"`
	FvRsFcPathAtt                      types.Set    `tfsdk:"relation_fv_rs_fc_path_att"`
	FvRsConsIf                         types.Set    `tfsdk:"relation_fv_rs_cons_if"`
	FvRsIntraEpg                       types.Set    `tfsdk:"relation_fv_rs_intra_epg"`
	FvRsProv                           types.Set    `tfsdk:"relation_fv_rs_prov"`
	FvRsPathAtt                        types.Set    `tfsdk:"relation_fv_rs_path_att"`
	FvRsProtBy                         types.Set    `tfsdk:"relation_fv_rs_prot_by"`
	FvRsTrustCtrl                      types.String `tfsdk:"relation_fv_rs_trust_ctrl"`
	FvRsNodeAtt                        types.Set    `tfsdk:"relation_fv_rs_node_att"`
}

type FvRsNodeAttFvAEPgResourceModelV1 struct {
	InstrImedcy types.String `tfsdk:"deployment_immediacy"`
	Descr       types.String `tfsdk:"description"`
	Encap       types.String `tfsdk:"encap"`
	Mode        types.String `tfsdk:"mode"`
	TDn         types.String `tfsdk:"node_dn"`
}

func (r *FvAEPgResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		1: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"description": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"exception_tag": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"flood_on_encap": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"fwd_ctrl": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"has_mcast_source": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"id": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"is_attr_based_epg": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"match_t": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Optional: false,
						Computed: false,
					},
					"name_alias": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"application_profile_dn": schema.StringAttribute{
						Required: true,
						Optional: false,
						Computed: false,
					},
					"pc_enf_pref": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"pref_gr_memb": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"prio": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"shutdown": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_prov_def": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_aepg_mon_pol": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_bd": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_cons": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_sec_inherited": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_cust_qos_pol": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_dpp_pol": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_fc_path_att": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_cons_if": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_intra_epg": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_prov": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_path_att": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_prot_by": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_trust_ctrl": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
				},
				Blocks: map[string]schema.Block{
					"relation_fv_rs_node_att": schema.SetNestedBlock{
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"deployment_immediacy": schema.StringAttribute{
									Required: false,
									Optional: true,
									Computed: false,
								},
								"description": schema.StringAttribute{
									Required: false,
									Optional: true,
									Computed: true,
								},
								"encap": schema.StringAttribute{
									Required: true,
									Optional: false,
									Computed: false,
								},
								"mode": schema.StringAttribute{
									Required: false,
									Optional: true,
									Computed: false,
								},
								"node_dn": schema.StringAttribute{
									Required: true,
									Optional: false,
									Computed: false,
								},
							},
						},
					},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData FvAEPgResourceModelV1

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := FvAEPgResourceModel{
					Id:                                 priorStateData.Id,
					ParentDn:                           priorStateData.ParentDn,
					Annotation:                         priorStateData.Annotation,
					Descr:                              priorStateData.Descr,
					ExceptionTag:                       priorStateData.ExceptionTag,
					FloodOnEncap:                       priorStateData.FloodOnEncap,
					FwdCtrl:                            priorStateData.FwdCtrl,
					HasMcastSource:                     priorStateData.HasMcastSource,
					IsAttrBasedEPg:                     priorStateData.IsAttrBasedEPg,
					MatchT:                             priorStateData.MatchT,
					Name:                               priorStateData.Name,
					NameAlias:                          priorStateData.NameAlias,
					PcEnfPref:                          priorStateData.PcEnfPref,
					PcTag:                              basetypes.NewStringNull(),
					PrefGrMemb:                         priorStateData.PrefGrMemb,
					Prio:                               customTypes.FvAEPgPrioStringValue{StringValue: priorStateData.Prio},
					Shutdown:                           priorStateData.Shutdown,
					DeprecatedExceptionTag:             priorStateData.ExceptionTag,
					DeprecatedFloodOnEncap:             priorStateData.FloodOnEncap,
					DeprecatedFwdCtrl:                  priorStateData.FwdCtrl,
					DeprecatedHasMcastSource:           priorStateData.HasMcastSource,
					DeprecatedIsAttrBasedEPg:           priorStateData.IsAttrBasedEPg,
					DeprecatedMatchT:                   priorStateData.MatchT,
					DeprecatedParentDn:                 priorStateData.ParentDn,
					DeprecatedPcEnfPref:                priorStateData.PcEnfPref,
					DeprecatedPrefGrMemb:               priorStateData.PrefGrMemb,
					DeprecatedPrio:                     priorStateData.Prio,
					DeprecatedShutdown:                 priorStateData.Shutdown,
					Deprecated_relation_fv_rs_prov_def: priorStateData.Deprecated_relation_fv_rs_prov_def,
					DeprecatedFvRsAEPgMonPol:           priorStateData.FvRsAEPgMonPol,
					DeprecatedFvRsBd:                   priorStateData.FvRsBd,
					DeprecatedFvRsCustQosPol:           priorStateData.FvRsCustQosPol,
					DeprecatedFvRsDppPol:               priorStateData.FvRsDppPol,
					DeprecatedFvRsTrustCtrl:            priorStateData.FvRsTrustCtrl,
				}

				upgradedStateData.FvCrtrn = types.ObjectNull(FvCrtrnFvAEPgType)

				FvRsAEPgMonPolObject := FvRsAEPgMonPolFvAEPgResourceModel{
					Annotation:      basetypes.NewStringNull(),
					TnMonEPGPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsAEPgMonPol.ValueString())),
				}
				fvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, FvRsAEPgMonPolObject)
				upgradedStateData.FvRsAEPgMonPol = fvRsAEPgMonPolObject

				FvRsBdObject := FvRsBdFvAEPgResourceModel{
					Annotation: basetypes.NewStringNull(),
					TnFvBDName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBd.ValueString())),
				}
				fvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, FvRsBdObject)
				upgradedStateData.FvRsBd = fvRsBdObject

				FvRsConsList := make([]FvRsConsFvAEPgResourceModel, 0)
				var priorStateDataFvRsConsList []string
				priorStateData.FvRsCons.ElementsAs(ctx, &priorStateDataFvRsConsList, false)
				for _, priorStateDataFvRsCons := range priorStateDataFvRsConsList {
					FvRsCons := FvRsConsFvAEPgResourceModel{
						Annotation:   basetypes.NewStringNull(),
						TnVzBrCPName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsCons)),
					}
					FvRsConsList = append(FvRsConsList, FvRsCons)
				}
				FvRsConsType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":    basetypes.StringType{},
						"priority":      basetypes.StringType{},
						"contract_name": basetypes.StringType{},
					},
				}
				FvRsConsSet, _ := types.SetValueFrom(ctx, FvRsConsType, FvRsConsList)
				upgradedStateData.FvRsCons = FvRsConsSet

				FvRsConsIfList := make([]FvRsConsIfFvAEPgResourceModel, 0)
				var priorStateDataFvRsConsIfList []string
				priorStateData.FvRsConsIf.ElementsAs(ctx, &priorStateDataFvRsConsIfList, false)
				for _, priorStateDataFvRsConsIf := range priorStateDataFvRsConsIfList {
					FvRsConsIf := FvRsConsIfFvAEPgResourceModel{
						Annotation:   basetypes.NewStringNull(),
						TnVzCPIfName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsConsIf)),
					}
					FvRsConsIfList = append(FvRsConsIfList, FvRsConsIf)
				}
				FvRsConsIfType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":             basetypes.StringType{},
						"priority":               basetypes.StringType{},
						"imported_contract_name": basetypes.StringType{},
					},
				}
				FvRsConsIfSet, _ := types.SetValueFrom(ctx, FvRsConsIfType, FvRsConsIfList)
				upgradedStateData.FvRsConsIf = FvRsConsIfSet

				FvRsCustQosPolObject := FvRsCustQosPolFvAEPgResourceModel{
					Annotation:         basetypes.NewStringNull(),
					TnQosCustomPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsCustQosPol.ValueString())),
				}
				fvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, FvRsCustQosPolObject)
				upgradedStateData.FvRsCustQosPol = fvRsCustQosPolObject

				upgradedStateData.FvRsDomAtt = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"annotation":                    basetypes.StringType{},
							"binding_type":                  basetypes.StringType{},
							"class_preference":              basetypes.StringType{},
							"custom_epg_name":               basetypes.StringType{},
							"delimiter":                     basetypes.StringType{},
							"encapsulation":                 basetypes.StringType{},
							"encapsulation_mode":            basetypes.StringType{},
							"epg_cos":                       basetypes.StringType{},
							"epg_cos_pref":                  basetypes.StringType{},
							"deployment_immediacy":          basetypes.StringType{},
							"ipam_dhcp_override":            basetypes.StringType{},
							"ipam_enabled":                  basetypes.StringType{},
							"ipam_gateway":                  basetypes.StringType{},
							"lag_policy_name":               basetypes.StringType{},
							"netflow_direction":             basetypes.StringType{},
							"enable_netflow":                basetypes.StringType{},
							"number_of_ports":               basetypes.StringType{},
							"port_allocation":               basetypes.StringType{},
							"primary_encapsulation":         basetypes.StringType{},
							"primary_encapsulation_inner":   basetypes.StringType{},
							"resolution_immediacy":          basetypes.StringType{},
							"secondary_encapsulation_inner": basetypes.StringType{},
							"switching_mode":                basetypes.StringType{},
							"target_dn":                     basetypes.StringType{},
							"untagged":                      basetypes.StringType{},
						},
					},
				)

				FvRsDppPolObject := FvRsDppPolFvAEPgResourceModel{
					Annotation:      basetypes.NewStringNull(),
					TnQosDppPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsDppPol.ValueString())),
				}
				fvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, FvRsDppPolObject)
				upgradedStateData.FvRsDppPol = fvRsDppPolObject

				FvRsFcPathAttList := make([]FvRsFcPathAttFvAEPgResourceModel, 0)
				var priorStateDataFvRsFcPathAttList []string
				priorStateData.FvRsFcPathAtt.ElementsAs(ctx, &priorStateDataFvRsFcPathAttList, false)
				for _, priorStateDataFvRsFcPathAtt := range priorStateDataFvRsFcPathAttList {
					FvRsFcPathAtt := FvRsFcPathAttFvAEPgResourceModel{
						Annotation: basetypes.NewStringNull(),
						Descr:      basetypes.NewStringNull(),
						TDn:        basetypes.NewStringValue(priorStateDataFvRsFcPathAtt),
						Vsan:       basetypes.NewStringNull(),
						VsanMode:   basetypes.NewStringNull(),
					}
					FvRsFcPathAttList = append(FvRsFcPathAttList, FvRsFcPathAtt)
				}
				FvRsFcPathAttType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":  basetypes.StringType{},
						"description": basetypes.StringType{},
						"target_dn":   basetypes.StringType{},
						"vsan":        basetypes.StringType{},
						"vsan_mode":   basetypes.StringType{},
					},
				}
				FvRsFcPathAttSet, _ := types.SetValueFrom(ctx, FvRsFcPathAttType, FvRsFcPathAttList)
				upgradedStateData.FvRsFcPathAtt = FvRsFcPathAttSet

				FvRsIntraEpgList := make([]FvRsIntraEpgFvAEPgResourceModel, 0)
				var priorStateDataFvRsIntraEpgList []string
				priorStateData.FvRsIntraEpg.ElementsAs(ctx, &priorStateDataFvRsIntraEpgList, false)
				for _, priorStateDataFvRsIntraEpg := range priorStateDataFvRsIntraEpgList {
					FvRsIntraEpg := FvRsIntraEpgFvAEPgResourceModel{
						Annotation:   basetypes.NewStringNull(),
						TnVzBrCPName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsIntraEpg)),
					}
					FvRsIntraEpgList = append(FvRsIntraEpgList, FvRsIntraEpg)
				}
				FvRsIntraEpgType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":    basetypes.StringType{},
						"contract_name": basetypes.StringType{},
					},
				}
				FvRsIntraEpgSet, _ := types.SetValueFrom(ctx, FvRsIntraEpgType, FvRsIntraEpgList)
				upgradedStateData.FvRsIntraEpg = FvRsIntraEpgSet

				FvRsNodeAttList := make([]FvRsNodeAttFvAEPgResourceModel, 0)
				var priorStateDataFvRsNodeAttList []FvRsNodeAttFvAEPgResourceModelV1
				priorStateData.FvRsNodeAtt.ElementsAs(ctx, &priorStateDataFvRsNodeAttList, false)
				for _, priorStateDataFvRsNodeAtt := range priorStateDataFvRsNodeAttList {
					FvRsNodeAtt := FvRsNodeAttFvAEPgResourceModel{
						Annotation:  basetypes.NewStringNull(),
						Descr:       priorStateDataFvRsNodeAtt.Descr,
						Encap:       priorStateDataFvRsNodeAtt.Encap,
						InstrImedcy: priorStateDataFvRsNodeAtt.InstrImedcy,
						Mode:        priorStateDataFvRsNodeAtt.Mode,
						TDn:         priorStateDataFvRsNodeAtt.TDn,
					}
					FvRsNodeAttList = append(FvRsNodeAttList, FvRsNodeAtt)
				}
				FvRsNodeAttType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":           basetypes.StringType{},
						"description":          basetypes.StringType{},
						"encapsulation":        basetypes.StringType{},
						"deployment_immediacy": basetypes.StringType{},
						"mode":                 basetypes.StringType{},
						"target_dn":            basetypes.StringType{},
					},
				}
				FvRsNodeAttSet, _ := types.SetValueFrom(ctx, FvRsNodeAttType, FvRsNodeAttList)
				upgradedStateData.FvRsNodeAtt = FvRsNodeAttSet

				FvRsPathAttList := make([]FvRsPathAttFvAEPgResourceModel, 0)
				var priorStateDataFvRsPathAttList []string
				priorStateData.FvRsPathAtt.ElementsAs(ctx, &priorStateDataFvRsPathAttList, false)
				for _, priorStateDataFvRsPathAtt := range priorStateDataFvRsPathAttList {
					FvRsPathAtt := FvRsPathAttFvAEPgResourceModel{
						Annotation:   basetypes.NewStringNull(),
						Descr:        basetypes.NewStringNull(),
						InstrImedcy:  basetypes.NewStringNull(),
						Mode:         basetypes.NewStringNull(),
						PrimaryEncap: basetypes.NewStringNull(),
						TDn:          basetypes.NewStringValue(priorStateDataFvRsPathAtt),
					}
					FvRsPathAttList = append(FvRsPathAttList, FvRsPathAtt)
				}
				FvRsPathAttType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":            basetypes.StringType{},
						"description":           basetypes.StringType{},
						"encapsulation":         basetypes.StringType{},
						"deployment_immediacy":  basetypes.StringType{},
						"mode":                  basetypes.StringType{},
						"primary_encapsulation": basetypes.StringType{},
						"target_dn":             basetypes.StringType{},
					},
				}
				FvRsPathAttSet, _ := types.SetValueFrom(ctx, FvRsPathAttType, FvRsPathAttList)
				upgradedStateData.FvRsPathAtt = FvRsPathAttSet

				FvRsProtByList := make([]FvRsProtByFvAEPgResourceModel, 0)
				var priorStateDataFvRsProtByList []string
				priorStateData.FvRsProtBy.ElementsAs(ctx, &priorStateDataFvRsProtByList, false)
				for _, priorStateDataFvRsProtBy := range priorStateDataFvRsProtByList {
					FvRsProtBy := FvRsProtByFvAEPgResourceModel{
						Annotation:    basetypes.NewStringNull(),
						TnVzTabooName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsProtBy)),
					}
					FvRsProtByList = append(FvRsProtByList, FvRsProtBy)
				}
				FvRsProtByType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":          basetypes.StringType{},
						"taboo_contract_name": basetypes.StringType{},
					},
				}
				FvRsProtBySet, _ := types.SetValueFrom(ctx, FvRsProtByType, FvRsProtByList)
				upgradedStateData.FvRsProtBy = FvRsProtBySet

				FvRsProvList := make([]FvRsProvFvAEPgResourceModel, 0)
				var priorStateDataFvRsProvList []string
				priorStateData.FvRsProv.ElementsAs(ctx, &priorStateDataFvRsProvList, false)
				for _, priorStateDataFvRsProv := range priorStateDataFvRsProvList {
					FvRsProv := FvRsProvFvAEPgResourceModel{
						Annotation:   basetypes.NewStringNull(),
						TnVzBrCPName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsProv)),
					}
					FvRsProvList = append(FvRsProvList, FvRsProv)
				}
				FvRsProvType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":     basetypes.StringType{},
						"match_criteria": basetypes.StringType{},
						"priority":       basetypes.StringType{},
						"contract_name":  basetypes.StringType{},
					},
				}
				FvRsProvSet, _ := types.SetValueFrom(ctx, FvRsProvType, FvRsProvList)
				upgradedStateData.FvRsProv = FvRsProvSet

				FvRsSecInheritedList := make([]FvRsSecInheritedFvAEPgResourceModel, 0)
				var priorStateDataFvRsSecInheritedList []string
				priorStateData.FvRsSecInherited.ElementsAs(ctx, &priorStateDataFvRsSecInheritedList, false)
				for _, priorStateDataFvRsSecInherited := range priorStateDataFvRsSecInheritedList {
					FvRsSecInherited := FvRsSecInheritedFvAEPgResourceModel{
						Annotation: basetypes.NewStringNull(),
						TDn:        basetypes.NewStringValue(priorStateDataFvRsSecInherited),
					}
					FvRsSecInheritedList = append(FvRsSecInheritedList, FvRsSecInherited)
				}
				FvRsSecInheritedType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation": basetypes.StringType{},
						"target_dn":  basetypes.StringType{},
					},
				}
				FvRsSecInheritedSet, _ := types.SetValueFrom(ctx, FvRsSecInheritedType, FvRsSecInheritedList)
				upgradedStateData.FvRsSecInherited = FvRsSecInheritedSet

				FvRsTrustCtrlObject := FvRsTrustCtrlFvAEPgResourceModel{
					Annotation:            basetypes.NewStringNull(),
					TnFhsTrustCtrlPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsTrustCtrl.ValueString())),
				}
				fvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, FvRsTrustCtrlObject)
				upgradedStateData.FvRsTrustCtrl = fvRsTrustCtrlObject

				upgradedStateData.TagAnnotation = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				upgradedStateData.TagTag = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				var deprecatedFvRsConsList []string
				priorStateData.FvRsCons.ElementsAs(ctx, &deprecatedFvRsConsList, false)
				DeprecatedFvRsConsSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsConsList)
				upgradedStateData.DeprecatedFvRsCons = DeprecatedFvRsConsSet

				var deprecatedFvRsSecInheritedList []string
				priorStateData.FvRsSecInherited.ElementsAs(ctx, &deprecatedFvRsSecInheritedList, false)
				DeprecatedFvRsSecInheritedSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsSecInheritedList)
				upgradedStateData.DeprecatedFvRsSecInherited = DeprecatedFvRsSecInheritedSet

				var deprecatedFvRsFcPathAttList []string
				priorStateData.FvRsFcPathAtt.ElementsAs(ctx, &deprecatedFvRsFcPathAttList, false)
				DeprecatedFvRsFcPathAttSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsFcPathAttList)
				upgradedStateData.DeprecatedFvRsFcPathAtt = DeprecatedFvRsFcPathAttSet

				var deprecatedFvRsConsIfList []string
				priorStateData.FvRsConsIf.ElementsAs(ctx, &deprecatedFvRsConsIfList, false)
				DeprecatedFvRsConsIfSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsConsIfList)
				upgradedStateData.DeprecatedFvRsConsIf = DeprecatedFvRsConsIfSet

				var deprecatedFvRsIntraEpgList []string
				priorStateData.FvRsIntraEpg.ElementsAs(ctx, &deprecatedFvRsIntraEpgList, false)
				DeprecatedFvRsIntraEpgSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsIntraEpgList)
				upgradedStateData.DeprecatedFvRsIntraEpg = DeprecatedFvRsIntraEpgSet

				var deprecatedFvRsProvList []string
				priorStateData.FvRsProv.ElementsAs(ctx, &deprecatedFvRsProvList, false)
				DeprecatedFvRsProvSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsProvList)
				upgradedStateData.DeprecatedFvRsProv = DeprecatedFvRsProvSet

				var deprecatedFvRsPathAttList []string
				priorStateData.FvRsPathAtt.ElementsAs(ctx, &deprecatedFvRsPathAttList, false)
				DeprecatedFvRsPathAttSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsPathAttList)
				upgradedStateData.DeprecatedFvRsPathAtt = DeprecatedFvRsPathAttSet

				var deprecatedFvRsProtByList []string
				priorStateData.FvRsProtBy.ElementsAs(ctx, &deprecatedFvRsProtByList, false)
				DeprecatedFvRsProtBySet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsProtByList)
				upgradedStateData.DeprecatedFvRsProtBy = DeprecatedFvRsProtBySet

				var FvRsNodeAttV1List []FvRsNodeAttFvAEPgResourceModelV1
				priorStateData.FvRsNodeAtt.ElementsAs(ctx, &FvRsNodeAttV1List, false)
				FvRsNodeAttV1Set, _ := types.SetValueFrom(ctx, deprecatedFvRsNodeAttType, FvRsNodeAttV1List)
				upgradedStateData.DeprecatedFvRsNodeAtt = FvRsNodeAttV1Set

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
	}
}

func setFvAEPgLegacyAttributes(ctx context.Context, diags *diag.Diagnostics, data, staticData *FvAEPgResourceModel, classReadInfo []interface{}) {
	data.DeprecatedParentDn = data.ParentDn
	if !staticData.Deprecated_relation_fv_rs_prov_def.IsUnknown() && !staticData.Deprecated_relation_fv_rs_prov_def.IsNull() {
		data.Deprecated_relation_fv_rs_prov_def = staticData.Deprecated_relation_fv_rs_prov_def
	} else {
		Deprecated_relation_fv_rs_prov_defSet, _ := types.SetValueFrom(ctx, types.StringType, []string{})
		data.Deprecated_relation_fv_rs_prov_def = Deprecated_relation_fv_rs_prov_defSet
	}
	attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
	for attributeName, attributeValue := range attributes {
		if attributeName == "exceptionTag" {
			data.DeprecatedExceptionTag = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "floodOnEncap" {
			data.DeprecatedFloodOnEncap = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "fwdCtrl" && attributeValue.(string) == "" {
			data.DeprecatedFwdCtrl = basetypes.NewStringValue("none")
		} else if attributeName == "fwdCtrl" {
			data.DeprecatedFwdCtrl = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "hasMcastSource" {
			data.DeprecatedHasMcastSource = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "isAttrBasedEPg" {
			data.DeprecatedIsAttrBasedEPg = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "matchT" {
			data.DeprecatedMatchT = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "pcEnfPref" {
			data.DeprecatedPcEnfPref = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "prefGrMemb" {
			data.DeprecatedPrefGrMemb = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "prio" {
			data.DeprecatedPrio = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "shutdown" {
			data.DeprecatedShutdown = basetypes.NewStringValue(attributeValue.(string))
		}
	}
	data.DeprecatedFvRsAEPgMonPol = basetypes.NewStringNull()
	data.DeprecatedFvRsBd = basetypes.NewStringNull()
	DeprecatedFvRsConsFvAEPgList := make([]string, 0)
	DeprecatedFvRsConsIfFvAEPgList := make([]string, 0)
	data.DeprecatedFvRsCustQosPol = basetypes.NewStringNull()
	data.DeprecatedFvRsDppPol = basetypes.NewStringNull()
	DeprecatedFvRsFcPathAttFvAEPgList := make([]string, 0)
	DeprecatedFvRsIntraEpgFvAEPgList := make([]string, 0)
	DeprecatedFvRsPathAttFvAEPgList := make([]string, 0)
	DeprecatedFvRsProtByFvAEPgList := make([]string, 0)
	DeprecatedFvRsProvFvAEPgList := make([]string, 0)
	DeprecatedFvRsSecInheritedFvAEPgList := make([]string, 0)
	data.DeprecatedFvRsTrustCtrl = basetypes.NewStringNull()

	_, ok := classReadInfo[0].(map[string]interface{})["children"]
	if ok {
		children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
		for _, child := range children {
			for childClassName, childClassDetails := range child.(map[string]interface{}) {
				childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
				if childClassName == "fvRsAEPgMonPol" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsAEPgMonPol = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBd" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBd = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsCons" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsConsFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsConsFvAEPgList = append(DeprecatedFvRsConsFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsConsIf" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsConsIfFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsConsIfFvAEPgList = append(DeprecatedFvRsConsIfFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsCustQosPol" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsCustQosPol = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsDppPol" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsDppPol = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsFcPathAtt" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsFcPathAttFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsFcPathAttFvAEPgList = append(DeprecatedFvRsFcPathAttFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsIntraEpg" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsIntraEpgFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsIntraEpgFvAEPgList = append(DeprecatedFvRsIntraEpgFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsPathAtt" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsPathAttFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsPathAttFvAEPgList = append(DeprecatedFvRsPathAttFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsProtBy" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsProtByFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsProtByFvAEPgList = append(DeprecatedFvRsProtByFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsProv" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsProvFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsProvFvAEPgList = append(DeprecatedFvRsProvFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsSecInherited" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsSecInheritedFvAEPgList, childAttributeValue.(string)) {
							DeprecatedFvRsSecInheritedFvAEPgList = append(DeprecatedFvRsSecInheritedFvAEPgList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsTrustCtrl" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsTrustCtrl = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
			}
		}
		fvRsConsSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsCons.ElementType(ctx), DeprecatedFvRsConsFvAEPgList)
		data.DeprecatedFvRsCons = fvRsConsSet
		fvRsConsIfSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsConsIf.ElementType(ctx), DeprecatedFvRsConsIfFvAEPgList)
		data.DeprecatedFvRsConsIf = fvRsConsIfSet
		fvRsFcPathAttSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsFcPathAtt.ElementType(ctx), DeprecatedFvRsFcPathAttFvAEPgList)
		data.DeprecatedFvRsFcPathAtt = fvRsFcPathAttSet
		fvRsIntraEpgSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsIntraEpg.ElementType(ctx), DeprecatedFvRsIntraEpgFvAEPgList)
		data.DeprecatedFvRsIntraEpg = fvRsIntraEpgSet
		data.DeprecatedFvRsNodeAtt = types.SetNull(deprecatedFvRsNodeAttType)
		fvRsPathAttSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsPathAtt.ElementType(ctx), DeprecatedFvRsPathAttFvAEPgList)
		data.DeprecatedFvRsPathAtt = fvRsPathAttSet
		fvRsProtBySet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsProtBy.ElementType(ctx), DeprecatedFvRsProtByFvAEPgList)
		data.DeprecatedFvRsProtBy = fvRsProtBySet
		fvRsProvSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsProv.ElementType(ctx), DeprecatedFvRsProvFvAEPgList)
		data.DeprecatedFvRsProv = fvRsProvSet
		fvRsSecInheritedSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsSecInherited.ElementType(ctx), DeprecatedFvRsSecInheritedFvAEPgList)
		data.DeprecatedFvRsSecInherited = fvRsSecInheritedSet
	}
}

func (r *FvAEPgResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if !req.Plan.Raw.IsNull() {
		var planData, stateData, configData *FvAEPgResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		resp.Diagnostics.Append(req.Config.Get(ctx, &configData)...)

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) && !planData.ParentDn.IsUnknown() && !planData.Name.IsUnknown() {
			setFvAEPgId(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "fvAEPg", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}
		if !configData.FvCrtrn.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvCrtrn.Attributes()) {
				FvCrtrnObject, _ := types.ObjectValueFrom(ctx, FvCrtrnFvAEPgType, getEmptyFvCrtrnFvAEPgResourceModel())
				planData.FvCrtrn = FvCrtrnObject
			}
		}
		if !configData.FvRsAEPgMonPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsAEPgMonPol.Attributes()) {
				FvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, getEmptyFvRsAEPgMonPolFvAEPgResourceModel())
				planData.FvRsAEPgMonPol = FvRsAEPgMonPolObject
			}
		}
		if !configData.FvRsBd.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBd.Attributes()) {
				FvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, getEmptyFvRsBdFvAEPgResourceModel())
				planData.FvRsBd = FvRsBdObject
			}
		}
		if !configData.FvRsCustQosPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsCustQosPol.Attributes()) {
				FvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, getEmptyFvRsCustQosPolFvAEPgResourceModel())
				planData.FvRsCustQosPol = FvRsCustQosPolObject
			}
		}
		if !configData.FvRsDppPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsDppPol.Attributes()) {
				FvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, getEmptyFvRsDppPolFvAEPgResourceModel())
				planData.FvRsDppPol = FvRsDppPolObject
			}
		}
		if !configData.FvRsTrustCtrl.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsTrustCtrl.Attributes()) {
				FvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, getEmptyFvRsTrustCtrlFvAEPgResourceModel())
				planData.FvRsTrustCtrl = FvRsTrustCtrlObject
			}
		}

		if !configData.ExceptionTag.IsNull() {
			planData.DeprecatedExceptionTag = configData.ExceptionTag
		} else if !configData.DeprecatedExceptionTag.IsNull() {
			planData.ExceptionTag = configData.DeprecatedExceptionTag
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedExceptionTag = stateData.DeprecatedExceptionTag
		}

		if !configData.FloodOnEncap.IsNull() {
			planData.DeprecatedFloodOnEncap = configData.FloodOnEncap
		} else if !configData.DeprecatedFloodOnEncap.IsNull() {
			planData.FloodOnEncap = configData.DeprecatedFloodOnEncap
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFloodOnEncap = stateData.DeprecatedFloodOnEncap
		}

		if !configData.FwdCtrl.IsNull() {
			planData.DeprecatedFwdCtrl = configData.FwdCtrl
		} else if !configData.DeprecatedFwdCtrl.IsNull() {
			planData.FwdCtrl = configData.DeprecatedFwdCtrl
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFwdCtrl = stateData.DeprecatedFwdCtrl
		}

		if !configData.HasMcastSource.IsNull() {
			planData.DeprecatedHasMcastSource = configData.HasMcastSource
		} else if !configData.DeprecatedHasMcastSource.IsNull() {
			planData.HasMcastSource = configData.DeprecatedHasMcastSource
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedHasMcastSource = stateData.DeprecatedHasMcastSource
		}

		if !configData.IsAttrBasedEPg.IsNull() {
			planData.DeprecatedIsAttrBasedEPg = configData.IsAttrBasedEPg
		} else if !configData.DeprecatedIsAttrBasedEPg.IsNull() {
			planData.IsAttrBasedEPg = configData.DeprecatedIsAttrBasedEPg
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedIsAttrBasedEPg = stateData.DeprecatedIsAttrBasedEPg
		}

		if !configData.MatchT.IsNull() {
			planData.DeprecatedMatchT = configData.MatchT
		} else if !configData.DeprecatedMatchT.IsNull() {
			planData.MatchT = configData.DeprecatedMatchT
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedMatchT = stateData.DeprecatedMatchT
		}

		if !configData.ParentDn.IsNull() {
			planData.DeprecatedParentDn = configData.ParentDn
		} else if !configData.DeprecatedParentDn.IsNull() {
			planData.ParentDn = configData.DeprecatedParentDn
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedParentDn = stateData.DeprecatedParentDn
		}

		if !configData.PcEnfPref.IsNull() {
			planData.DeprecatedPcEnfPref = configData.PcEnfPref
		} else if !configData.DeprecatedPcEnfPref.IsNull() {
			planData.PcEnfPref = configData.DeprecatedPcEnfPref
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedPcEnfPref = stateData.DeprecatedPcEnfPref
		}

		if !configData.PrefGrMemb.IsNull() {
			planData.DeprecatedPrefGrMemb = configData.PrefGrMemb
		} else if !configData.DeprecatedPrefGrMemb.IsNull() {
			planData.PrefGrMemb = configData.DeprecatedPrefGrMemb
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedPrefGrMemb = stateData.DeprecatedPrefGrMemb
		}

		if !configData.Prio.IsNull() {
			matchMap := map[string]string{
				"0": "unspecified",
				"1": "level3",
				"2": "level2",
				"3": "level1",
				"7": "level6",
				"8": "level5",
				"9": "level4",
			}
			if configDataPrio, ok := matchMap[configData.Prio.ValueString()]; ok {
				planData.DeprecatedPrio = basetypes.NewStringValue(configDataPrio)
			} else {
				planData.DeprecatedPrio = configData.Prio.StringValue
			}
		} else if !configData.DeprecatedPrio.IsNull() {
			planData.Prio = customTypes.FvAEPgPrioStringValue{StringValue: configData.DeprecatedPrio}
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedPrio = stateData.DeprecatedPrio
		}

		if !configData.Shutdown.IsNull() {
			planData.DeprecatedShutdown = configData.Shutdown
		} else if !configData.DeprecatedShutdown.IsNull() {
			planData.Shutdown = configData.DeprecatedShutdown
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedShutdown = stateData.DeprecatedShutdown
		}

		if !configData.FvRsAEPgMonPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsAEPgMonPol.Attributes()) {
				planData.FvRsAEPgMonPol = configData.FvRsAEPgMonPol
				planData.DeprecatedFvRsAEPgMonPol = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsAEPgMonPolFvAEPgResourceModel
				configData.FvRsAEPgMonPol.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsAEPgMonPol.ValueString()) == attributeValues.TnMonEPGPolName.ValueString() && !attributeValues.TnMonEPGPolName.IsNull() {
					planData.DeprecatedFvRsAEPgMonPol = stateData.DeprecatedFvRsAEPgMonPol
				}
			}
		} else if !configData.DeprecatedFvRsAEPgMonPol.IsNull() {
			FvRsAEPgMonPol := FvRsAEPgMonPolFvAEPgResourceModel{
				Annotation:      planData.Annotation,
				TnMonEPGPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsAEPgMonPol.ValueString())),
			}
			FvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, FvRsAEPgMonPol)
			planData.FvRsAEPgMonPol = FvRsAEPgMonPolObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsAEPgMonPol = stateData.DeprecatedFvRsAEPgMonPol
		}

		if !configData.FvRsBd.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBd.Attributes()) {
				planData.FvRsBd = configData.FvRsBd
				planData.DeprecatedFvRsBd = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBdFvAEPgResourceModel
				configData.FvRsBd.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBd.ValueString()) == attributeValues.TnFvBDName.ValueString() && !attributeValues.TnFvBDName.IsNull() {
					planData.DeprecatedFvRsBd = stateData.DeprecatedFvRsBd
				}
			}
		} else if !configData.DeprecatedFvRsBd.IsNull() {
			FvRsBd := FvRsBdFvAEPgResourceModel{
				Annotation: planData.Annotation,
				TnFvBDName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBd.ValueString())),
			}
			FvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, FvRsBd)
			planData.FvRsBd = FvRsBdObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBd = stateData.DeprecatedFvRsBd
		}

		if !configData.FvRsCons.IsNull() && stateData != nil {
			var attributeValues []FvRsConsFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsCons.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsCons.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnVzBrCPName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsConsSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsCons = FvRsConsSet
				}
			}
		} else if !configData.DeprecatedFvRsCons.IsNull() {
			FvRsConsList := make([]FvRsConsFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsConsFvAEPgResourceModel
			configData.DeprecatedFvRsCons.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsCons.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsConsValue := FvRsConsFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzBrCPName.ValueString() == GetMOName(attributeValue) {
						FvRsConsValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsCons := FvRsConsFvAEPgResourceModel{
					TnVzBrCPName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsCons.Annotation = FvRsConsValue.Annotation
					FvRsCons.Prio = FvRsConsValue.Prio
				} else {
					FvRsCons.Annotation = planData.Annotation
					FvRsCons.Prio = customTypes.NewFvRsConsPrioStringValue("unspecified") // Default to default value from meta when not found
				}
				FvRsConsList = append(FvRsConsList, FvRsCons)
			}
			FvRsConsType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":    basetypes.StringType{},
					"priority":      basetypes.StringType{},
					"contract_name": basetypes.StringType{},
				},
			}
			FvRsConsSet, _ := types.SetValueFrom(ctx, FvRsConsType, FvRsConsList)
			planData.FvRsCons = FvRsConsSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsCons = stateData.DeprecatedFvRsCons
		}

		if !configData.FvRsSecInherited.IsNull() && stateData != nil {
			var attributeValues []FvRsSecInheritedFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsSecInherited.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsSecInherited.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TDn.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsSecInheritedSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsSecInherited = FvRsSecInheritedSet
				}
			}
		} else if !configData.DeprecatedFvRsSecInherited.IsNull() {
			FvRsSecInheritedList := make([]FvRsSecInheritedFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsSecInheritedFvAEPgResourceModel
			configData.DeprecatedFvRsSecInherited.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsSecInherited.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsSecInheritedValue := FvRsSecInheritedFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TDn.ValueString() == attributeValue {
						FvRsSecInheritedValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsSecInherited := FvRsSecInheritedFvAEPgResourceModel{
					TDn: basetypes.NewStringValue(attributeValue),
				}

				if foundAttributeValue {
					FvRsSecInherited.Annotation = FvRsSecInheritedValue.Annotation
				} else {
					FvRsSecInherited.Annotation = planData.Annotation
				}
				FvRsSecInheritedList = append(FvRsSecInheritedList, FvRsSecInherited)
			}
			FvRsSecInheritedType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation": basetypes.StringType{},
					"target_dn":  basetypes.StringType{},
				},
			}
			FvRsSecInheritedSet, _ := types.SetValueFrom(ctx, FvRsSecInheritedType, FvRsSecInheritedList)
			planData.FvRsSecInherited = FvRsSecInheritedSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsSecInherited = stateData.DeprecatedFvRsSecInherited
		}

		if !configData.FvRsCustQosPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsCustQosPol.Attributes()) {
				planData.FvRsCustQosPol = configData.FvRsCustQosPol
				planData.DeprecatedFvRsCustQosPol = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsCustQosPolFvAEPgResourceModel
				configData.FvRsCustQosPol.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsCustQosPol.ValueString()) == attributeValues.TnQosCustomPolName.ValueString() && !attributeValues.TnQosCustomPolName.IsNull() {
					planData.DeprecatedFvRsCustQosPol = stateData.DeprecatedFvRsCustQosPol
				}
			}
		} else if !configData.DeprecatedFvRsCustQosPol.IsNull() {
			FvRsCustQosPol := FvRsCustQosPolFvAEPgResourceModel{
				Annotation:         planData.Annotation,
				TnQosCustomPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsCustQosPol.ValueString())),
			}
			FvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, FvRsCustQosPol)
			planData.FvRsCustQosPol = FvRsCustQosPolObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsCustQosPol = stateData.DeprecatedFvRsCustQosPol
		}

		if !configData.FvRsDppPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsDppPol.Attributes()) {
				planData.FvRsDppPol = configData.FvRsDppPol
				planData.DeprecatedFvRsDppPol = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsDppPolFvAEPgResourceModel
				configData.FvRsDppPol.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsDppPol.ValueString()) == attributeValues.TnQosDppPolName.ValueString() && !attributeValues.TnQosDppPolName.IsNull() {
					planData.DeprecatedFvRsDppPol = stateData.DeprecatedFvRsDppPol
				}
			}
		} else if !configData.DeprecatedFvRsDppPol.IsNull() {
			FvRsDppPol := FvRsDppPolFvAEPgResourceModel{
				Annotation:      planData.Annotation,
				TnQosDppPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsDppPol.ValueString())),
			}
			FvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, FvRsDppPol)
			planData.FvRsDppPol = FvRsDppPolObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsDppPol = stateData.DeprecatedFvRsDppPol
		}

		if !configData.FvRsFcPathAtt.IsNull() && stateData != nil {
			var attributeValues []FvRsFcPathAttFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsFcPathAtt.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsFcPathAtt.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TDn.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsFcPathAttSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsFcPathAtt = FvRsFcPathAttSet
				}
			}
		} else if !configData.DeprecatedFvRsFcPathAtt.IsNull() {
			FvRsFcPathAttList := make([]FvRsFcPathAttFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsFcPathAttFvAEPgResourceModel
			configData.DeprecatedFvRsFcPathAtt.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsFcPathAtt.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsFcPathAttValue := FvRsFcPathAttFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TDn.ValueString() == attributeValue {
						FvRsFcPathAttValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsFcPathAtt := FvRsFcPathAttFvAEPgResourceModel{
					TDn: basetypes.NewStringValue(attributeValue),
				}

				if foundAttributeValue {
					FvRsFcPathAtt.Annotation = FvRsFcPathAttValue.Annotation
					FvRsFcPathAtt.Descr = FvRsFcPathAttValue.Descr
					FvRsFcPathAtt.Vsan = FvRsFcPathAttValue.Vsan
					FvRsFcPathAtt.VsanMode = FvRsFcPathAttValue.VsanMode
				} else {
					FvRsFcPathAtt.Annotation = planData.Annotation
					FvRsFcPathAtt.Vsan = basetypes.NewStringValue("unknown")     // Default to default value from meta when not found
					FvRsFcPathAtt.VsanMode = basetypes.NewStringValue("regular") // Default to default value from meta when not found
				}
				FvRsFcPathAttList = append(FvRsFcPathAttList, FvRsFcPathAtt)
			}
			FvRsFcPathAttType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":  basetypes.StringType{},
					"description": basetypes.StringType{},
					"target_dn":   basetypes.StringType{},
					"vsan":        basetypes.StringType{},
					"vsan_mode":   basetypes.StringType{},
				},
			}
			FvRsFcPathAttSet, _ := types.SetValueFrom(ctx, FvRsFcPathAttType, FvRsFcPathAttList)
			planData.FvRsFcPathAtt = FvRsFcPathAttSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsFcPathAtt = stateData.DeprecatedFvRsFcPathAtt
		}

		if !configData.FvRsConsIf.IsNull() && stateData != nil {
			var attributeValues []FvRsConsIfFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsConsIf.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsConsIf.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnVzCPIfName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsConsIfSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsConsIf = FvRsConsIfSet
				}
			}
		} else if !configData.DeprecatedFvRsConsIf.IsNull() {
			FvRsConsIfList := make([]FvRsConsIfFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsConsIfFvAEPgResourceModel
			configData.DeprecatedFvRsConsIf.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsConsIf.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsConsIfValue := FvRsConsIfFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzCPIfName.ValueString() == GetMOName(attributeValue) {
						FvRsConsIfValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsConsIf := FvRsConsIfFvAEPgResourceModel{
					TnVzCPIfName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsConsIf.Annotation = FvRsConsIfValue.Annotation
					FvRsConsIf.Prio = FvRsConsIfValue.Prio
				} else {
					FvRsConsIf.Annotation = planData.Annotation
					FvRsConsIf.Prio = customTypes.NewFvRsConsIfPrioStringValue("unspecified") // Default to default value from meta when not found
				}
				FvRsConsIfList = append(FvRsConsIfList, FvRsConsIf)
			}
			FvRsConsIfType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":             basetypes.StringType{},
					"priority":               basetypes.StringType{},
					"imported_contract_name": basetypes.StringType{},
				},
			}
			FvRsConsIfSet, _ := types.SetValueFrom(ctx, FvRsConsIfType, FvRsConsIfList)
			planData.FvRsConsIf = FvRsConsIfSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsConsIf = stateData.DeprecatedFvRsConsIf
		}

		if !configData.FvRsIntraEpg.IsNull() && stateData != nil {
			var attributeValues []FvRsIntraEpgFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsIntraEpg.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsIntraEpg.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnVzBrCPName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsIntraEpgSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsIntraEpg = FvRsIntraEpgSet
				}
			}
		} else if !configData.DeprecatedFvRsIntraEpg.IsNull() {
			FvRsIntraEpgList := make([]FvRsIntraEpgFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsIntraEpgFvAEPgResourceModel
			configData.DeprecatedFvRsIntraEpg.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsIntraEpg.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsIntraEpgValue := FvRsIntraEpgFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzBrCPName.ValueString() == GetMOName(attributeValue) {
						FvRsIntraEpgValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsIntraEpg := FvRsIntraEpgFvAEPgResourceModel{
					TnVzBrCPName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsIntraEpg.Annotation = FvRsIntraEpgValue.Annotation
				} else {
					FvRsIntraEpg.Annotation = planData.Annotation
				}
				FvRsIntraEpgList = append(FvRsIntraEpgList, FvRsIntraEpg)
			}
			FvRsIntraEpgType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":    basetypes.StringType{},
					"contract_name": basetypes.StringType{},
				},
			}
			FvRsIntraEpgSet, _ := types.SetValueFrom(ctx, FvRsIntraEpgType, FvRsIntraEpgList)
			planData.FvRsIntraEpg = FvRsIntraEpgSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsIntraEpg = stateData.DeprecatedFvRsIntraEpg
		}

		if !configData.FvRsProv.IsNull() && stateData != nil {
			var attributeValues []FvRsProvFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsProv.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsProv.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnVzBrCPName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsProvSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsProv = FvRsProvSet
				}
			}
		} else if !configData.DeprecatedFvRsProv.IsNull() {
			FvRsProvList := make([]FvRsProvFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsProvFvAEPgResourceModel
			configData.DeprecatedFvRsProv.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsProv.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsProvValue := FvRsProvFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzBrCPName.ValueString() == GetMOName(attributeValue) {
						FvRsProvValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsProv := FvRsProvFvAEPgResourceModel{
					TnVzBrCPName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsProv.Annotation = FvRsProvValue.Annotation
					FvRsProv.MatchT = FvRsProvValue.MatchT
					FvRsProv.Prio = FvRsProvValue.Prio
				} else {
					FvRsProv.Annotation = planData.Annotation
					FvRsProv.MatchT = basetypes.NewStringValue("AtleastOne")              // Default to default value from meta when not found
					FvRsProv.Prio = customTypes.NewFvRsProvPrioStringValue("unspecified") // Default to default value from meta when not found
				}
				FvRsProvList = append(FvRsProvList, FvRsProv)
			}
			FvRsProvType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":     basetypes.StringType{},
					"match_criteria": basetypes.StringType{},
					"priority":       basetypes.StringType{},
					"contract_name":  basetypes.StringType{},
				},
			}
			FvRsProvSet, _ := types.SetValueFrom(ctx, FvRsProvType, FvRsProvList)
			planData.FvRsProv = FvRsProvSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsProv = stateData.DeprecatedFvRsProv
		}

		if !configData.FvRsPathAtt.IsNull() && stateData != nil {
			var attributeValues []FvRsPathAttFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsPathAtt.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsPathAtt.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TDn.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsPathAttSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsPathAtt = FvRsPathAttSet
				}
			}
		} else if !configData.DeprecatedFvRsPathAtt.IsNull() {
			FvRsPathAttList := make([]FvRsPathAttFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsPathAttFvAEPgResourceModel
			configData.DeprecatedFvRsPathAtt.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsPathAtt.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsPathAttValue := FvRsPathAttFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TDn.ValueString() == attributeValue {
						FvRsPathAttValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsPathAtt := FvRsPathAttFvAEPgResourceModel{
					TDn: basetypes.NewStringValue(attributeValue),
				}

				if foundAttributeValue {
					FvRsPathAtt.Annotation = FvRsPathAttValue.Annotation
					FvRsPathAtt.Descr = FvRsPathAttValue.Descr
					FvRsPathAtt.Encap = FvRsPathAttValue.Encap
					FvRsPathAtt.InstrImedcy = FvRsPathAttValue.InstrImedcy
					FvRsPathAtt.Mode = FvRsPathAttValue.Mode
					FvRsPathAtt.PrimaryEncap = FvRsPathAttValue.PrimaryEncap
				} else {
					FvRsPathAtt.Annotation = planData.Annotation
					FvRsPathAtt.InstrImedcy = basetypes.NewStringValue("lazy") // Default to default value from meta when not found
					FvRsPathAtt.Mode = basetypes.NewStringValue("regular")     // Default to default value from meta when not found
				}
				FvRsPathAttList = append(FvRsPathAttList, FvRsPathAtt)
			}
			FvRsPathAttType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":            basetypes.StringType{},
					"description":           basetypes.StringType{},
					"encapsulation":         basetypes.StringType{},
					"deployment_immediacy":  basetypes.StringType{},
					"mode":                  basetypes.StringType{},
					"primary_encapsulation": basetypes.StringType{},
					"target_dn":             basetypes.StringType{},
				},
			}
			FvRsPathAttSet, _ := types.SetValueFrom(ctx, FvRsPathAttType, FvRsPathAttList)
			planData.FvRsPathAtt = FvRsPathAttSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsPathAtt = stateData.DeprecatedFvRsPathAtt
		}

		if !configData.FvRsProtBy.IsNull() && stateData != nil {
			var attributeValues []FvRsProtByFvAEPgResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsProtBy.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsProtBy.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnVzTabooName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsProtBySet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsProtBy = FvRsProtBySet
				}
			}
		} else if !configData.DeprecatedFvRsProtBy.IsNull() {
			FvRsProtByList := make([]FvRsProtByFvAEPgResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsProtByFvAEPgResourceModel
			configData.DeprecatedFvRsProtBy.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsProtBy.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsProtByValue := FvRsProtByFvAEPgResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnVzTabooName.ValueString() == GetMOName(attributeValue) {
						FvRsProtByValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsProtBy := FvRsProtByFvAEPgResourceModel{
					TnVzTabooName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsProtBy.Annotation = FvRsProtByValue.Annotation
				} else {
					FvRsProtBy.Annotation = planData.Annotation
				}
				FvRsProtByList = append(FvRsProtByList, FvRsProtBy)
			}
			FvRsProtByType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":          basetypes.StringType{},
					"taboo_contract_name": basetypes.StringType{},
				},
			}
			FvRsProtBySet, _ := types.SetValueFrom(ctx, FvRsProtByType, FvRsProtByList)
			planData.FvRsProtBy = FvRsProtBySet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsProtBy = stateData.DeprecatedFvRsProtBy
		}

		if !configData.FvRsTrustCtrl.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsTrustCtrl.Attributes()) {
				planData.FvRsTrustCtrl = configData.FvRsTrustCtrl
				planData.DeprecatedFvRsTrustCtrl = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsTrustCtrlFvAEPgResourceModel
				configData.FvRsTrustCtrl.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsTrustCtrl.ValueString()) == attributeValues.TnFhsTrustCtrlPolName.ValueString() && !attributeValues.TnFhsTrustCtrlPolName.IsNull() {
					planData.DeprecatedFvRsTrustCtrl = stateData.DeprecatedFvRsTrustCtrl
				}
			}
		} else if !configData.DeprecatedFvRsTrustCtrl.IsNull() {
			FvRsTrustCtrl := FvRsTrustCtrlFvAEPgResourceModel{
				Annotation:            planData.Annotation,
				TnFhsTrustCtrlPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsTrustCtrl.ValueString())),
			}
			FvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, FvRsTrustCtrl)
			planData.FvRsTrustCtrl = FvRsTrustCtrlObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsTrustCtrl = stateData.DeprecatedFvRsTrustCtrl
		}

		planData.DeprecatedFvRsNodeAtt = types.SetNull(deprecatedFvRsNodeAttType)
		if !configData.DeprecatedFvRsNodeAtt.IsNull() && stateData != nil {
			FvRsNodeAttList := make([]FvRsNodeAttFvAEPgResourceModel, 0)
			var attributeValues []FvRsNodeAttFvAEPgResourceModelV1
			var newAttributeValues []FvRsNodeAttFvAEPgResourceModel
			configData.DeprecatedFvRsNodeAtt.ElementsAs(ctx, &attributeValues, false)
			stateData.FvRsNodeAtt.ElementsAs(ctx, &newAttributeValues, false)
			for _, attributeValue := range attributeValues {

				FvRsNodeAtt := FvRsNodeAttFvAEPgResourceModel{
					Annotation:  planData.Annotation,
					Descr:       attributeValue.Descr,
					Encap:       attributeValue.Encap,
					InstrImedcy: attributeValue.InstrImedcy,
					Mode:        attributeValue.Mode,
					TDn:         attributeValue.TDn,
				}

				FvRsNodeAttList = append(FvRsNodeAttList, FvRsNodeAtt)
			}

			FvRsNodeAttType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":           basetypes.StringType{},
					"description":          basetypes.StringType{},
					"encapsulation":        basetypes.StringType{},
					"deployment_immediacy": basetypes.StringType{},
					"mode":                 basetypes.StringType{},
					"target_dn":            basetypes.StringType{},
				},
			}
			FvRsNodeAttSet, _ := types.SetValueFrom(ctx, FvRsNodeAttType, FvRsNodeAttList)
			planData.FvRsNodeAtt = FvRsNodeAttSet
		}

		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func (r *FvAEPgResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_application_epg")
	resp.TypeName = req.ProviderTypeName + "_application_epg"
	tflog.Debug(ctx, "End metadata of resource: aci_application_epg")
}

func (r *FvAEPgResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_application_epg")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The application_epg resource for the 'fvAEPg' class",
		Version:             2,

		Attributes: map[string]schema.Attribute{
			// Deprecated attributes
			"exception_tag": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'exception_tag' is deprecated, please refer to 'contract_exception_tag' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("contract_exception_tag"),
					}...),
				},
			},
			"flood_on_encap": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'flood_on_encap' is deprecated, please refer to 'flood_in_encapsulation' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("flood_in_encapsulation"),
					}...),
				},
			},
			"fwd_ctrl": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'fwd_ctrl' is deprecated, please refer to 'forwarding_control' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("forwarding_control"),
					}...),
				},
			},
			"has_mcast_source": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'has_mcast_source' is deprecated, please refer to 'has_multicast_source' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("has_multicast_source"),
					}...),
				},
			},
			"is_attr_based_epg": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'is_attr_based_epg' is deprecated, please refer to 'useg_epg' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("useg_epg"),
					}...),
				},
			},
			"match_t": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'match_t' is deprecated, please refer to 'match_criteria' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("match_criteria"),
					}...),
				},
			},
			"application_profile_dn": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'application_profile_dn' is deprecated, please refer to 'parent_dn' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("parent_dn"),
					}...),
				},
			},
			"pc_enf_pref": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'pc_enf_pref' is deprecated, please refer to 'intra_epg_isolation' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("intra_epg_isolation"),
					}...),
				},
			},
			"pref_gr_memb": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'pref_gr_memb' is deprecated, please refer to 'preferred_group_member' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("preferred_group_member"),
					}...),
				},
			},
			"prio": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'prio' is deprecated, please refer to 'priority' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("priority"),
					}...),
				},
			},
			"shutdown": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'shutdown' is deprecated, please refer to 'admin_state' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("admin_state"),
					}...),
				},
			},
			"relation_fv_rs_prov_def": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute `relation_fv_rs_prov_def` is deprecated. The attribute will be removed in the next major version of the provider.",
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
			"relation_fv_rs_aepg_mon_pol": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_aepg_mon_pol' is deprecated, please refer to 'relation_to_application_epg_monitoring_policy.monitoring_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_application_epg_monitoring_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd' is deprecated, please refer to 'relation_to_bridge_domain.bridge_domain_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_bridge_domain"),
					}...),
				},
			},
			"relation_fv_rs_cons": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_cons' is deprecated, please refer to 'relation_to_consumed_contracts.contract_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_consumed_contracts"),
					}...),
				},
			},
			"relation_fv_rs_sec_inherited": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_sec_inherited' is deprecated, please refer to 'relation_to_contract_masters.target_dn' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_contract_masters"),
					}...),
				},
			},
			"relation_fv_rs_cust_qos_pol": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_cust_qos_pol' is deprecated, please refer to 'relation_to_custom_qos_policy.custom_qos_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_custom_qos_policy"),
					}...),
				},
			},
			"relation_fv_rs_dpp_pol": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_dpp_pol' is deprecated, please refer to 'relation_to_data_plane_policing_policy.data_plane_policing_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_data_plane_policing_policy"),
					}...),
				},
			},
			"relation_fv_rs_fc_path_att": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_fc_path_att' is deprecated, please refer to 'relation_to_fibre_channel_paths.fibre_channel_path_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_fibre_channel_paths"),
					}...),
				},
			},
			"relation_fv_rs_cons_if": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_cons_if' is deprecated, please refer to 'relation_to_imported_contracts.imported_contract_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_imported_contracts"),
					}...),
				},
			},
			"relation_fv_rs_intra_epg": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_intra_epg' is deprecated, please refer to 'relation_to_intra_epg_contracts.contract_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_intra_epg_contracts"),
					}...),
				},
			},
			"relation_fv_rs_prov": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_prov' is deprecated, please refer to 'relation_to_provided_contracts.contract_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_provided_contracts"),
					}...),
				},
			},
			"relation_fv_rs_path_att": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_path_att' is deprecated, please refer to 'relation_to_static_paths.target_dn' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_static_paths"),
					}...),
				},
			},
			"relation_fv_rs_prot_by": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_prot_by' is deprecated, please refer to 'relation_to_taboo_contracts.taboo_contract_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_taboo_contracts"),
					}...),
				},
			},
			"relation_fv_rs_trust_ctrl": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_trust_ctrl' is deprecated, please refer to 'relation_to_trust_control_policy.trust_control_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_trust_control_policy"),
					}...),
				},
			},
			// End of deprecated attributes
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the Application EPG object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"parent_dn": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("application_profile_dn"),
					}...),
				},
			},
			"annotation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Default:             stringdefault.StaticString(globalAnnotation),
				MarkdownDescription: `The annotation of the Application EPG object.`,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The description of the Application EPG object.`,
			},
			"contract_exception_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators:          []validator.String{},
				MarkdownDescription: `The contract exception tag of the Application EPG object.`,
			},
			"flood_in_encapsulation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("disabled", "enabled"),
				},
				MarkdownDescription: `Flood L2 Multicast/Broadcast and Link Local Layer based on encapsulation.`,
			},
			"forwarding_control": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("none", "proxy-arp"),
				},
				MarkdownDescription: `The forwarding control of the Application EPG object.`,
			},
			"has_multicast_source": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The Application EPG object has a multicast source.`,
			},
			"useg_epg": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The Application EPG object is microsegmented (uSeg).`,
			},
			"match_criteria": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("All", "AtleastOne", "AtmostOne", "None"),
				},
				MarkdownDescription: `The provider label match criteria.`,
			},
			"name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The name of the Application EPG object.`,
			},
			"name_alias": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The name alias of the Application EPG object.`,
			},
			"intra_epg_isolation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("enforced", "unenforced"),
				},
				MarkdownDescription: `Parameter used to determine whether communication between endpoints within the EPG is blocked.`,
			},
			"pc_tag": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The classification tag used for policy enforcement and zoning.`,
			},
			"preferred_group_member": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("exclude", "include"),
				},
				MarkdownDescription: `Parameter used to determine whether the EPG is part of the preferred group. Members of this group are allowed to communicate without contracts.`,
			},
			"priority": schema.StringAttribute{
				CustomType: customTypes.FvAEPgPrioStringType{},
				Optional:   true,
				Computed:   true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.Any(
						stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
						validators.InBetweenFromString(0, 9),
					),
				},
				MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
			},
			"admin_state": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Withdraw AEPg Configuration from all Nodes in the Fabric.`,
			},
			"epg_useg_block_statement": schema.SingleNestedAttribute{
				MarkdownDescription: `A criterion.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the EPG uSeg Block Statement object.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The description of the EPG uSeg Block Statement object.`,
					},
					"match": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators: []validator.String{
							stringvalidator.OneOf("all", "any"),
						},
						MarkdownDescription: `The Matching Rule Type of the EPG uSeg Block Statement object.`,
					},
					"name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The name of the EPG uSeg Block Statement object.`,
					},
					"name_alias": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The name alias of the EPG uSeg Block Statement object.`,
					},
					"owner_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
					},
					"owner_tag": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
					},
					"precedence": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The precedence of the EPG uSeg Block Statement object.`,
					},
					"scope": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators: []validator.String{
							stringvalidator.OneOf("scope-bd", "scope-vrf"),
						},
						MarkdownDescription: `The scope of the EPG uSeg Block Statement object.`,
					},
				},
			},
			"relation_to_application_epg_monitoring_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the monitoring policy model for the endpoint group semantic scope. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the Relation To Application EPG Monitoring Policy object.`,
					},
					"monitoring_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The name of the monitoring policy.`,
					},
				},
			},
			"relation_to_bridge_domain": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the bridge domain associated to this endpoint group. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the Relation To Bridge Domain object.`,
					},
					"bridge_domain_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The name of the bridge domain associated with this EPG.`,
					},
				},
			},
			"relation_to_consumed_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `The Consumer contract profile information.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Consumed Contract object.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.FvRsConsPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"contract_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The consumer contract name.`,
						},
					},
				},
			},
			"relation_to_imported_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `A contract for which the EPG will be a consumer.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Imported Contract object.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.FvRsConsIfPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"imported_contract_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The contract interface name.`,
						},
					},
				},
			},
			"relation_to_custom_qos_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to a custom QoS policy that enables different levels of service to be assigned to network traffic, including specifications for the Differentiated Services Code Point (DSCP) value(s) and the 802.1p Dot1p priority. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the Relation To Custom Qos Policy object.`,
					},
					"custom_qos_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The Custom QoS traffic policy name.`,
					},
				},
			},
			"relation_to_domains": schema.SetNestedAttribute{
				MarkdownDescription: `An EPG can be linked to a domain profile via the Associated Domain Profiles. The domain profiles attached can be VMM, Physical, L2 External, or L3 External Domains.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Domain object.`,
						},
						"binding_type": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("dynamicBinding", "ephemeral", "none", "staticBinding"),
							},
							MarkdownDescription: `The binding type of the Relation To Domain object.`,
						},
						"class_preference": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("encap", "useg"),
							},
							MarkdownDescription: `The class preference of the Relation To Domain object. Set 'useg' to allow microsegmentation.`,
						},
						"custom_epg_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The display name of the user configured port-group.`,
						},
						"delimiter": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The delimiter of the Relation To Domain object.`,
						},
						"encapsulation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The encapsulation of the Relation To Domain object. The encapsulation refers to the EPG VLAN when class preference is set to 'encap, or to the Secondary VLAN when class preference is set to 'useg'.`,
						},
						"encapsulation_mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("auto", "vlan", "vxlan"),
							},
							MarkdownDescription: `The encapsulation mode of the Relation To Domain object.`,
						},
						"epg_cos": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("Cos0", "Cos1", "Cos2", "Cos3", "Cos4", "Cos5", "Cos6", "Cos7"),
							},
							MarkdownDescription: `The class of service (CoS) of the Relation To Domain object.`,
						},
						"epg_cos_pref": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("disabled", "enabled"),
							},
							MarkdownDescription: `The class of service (CoS) preference of the Relation To Domain object.`,
						},
						"deployment_immediacy": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("immediate", "lazy"),
							},
							MarkdownDescription: `The deployment immediacy of the Relation To Domain object. Specifies when the policy is pushed into the hardware policy content-addressable memory (CAM).`,
						},
						"ipam_dhcp_override": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The IP address management (IPAM) DHCP override of the Relation To Domain object. Only applicable for Nutanix domains.`,
						},
						"ipam_enabled": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("no", "yes"),
							},
							MarkdownDescription: `The IP address management (IPAM) enabled status of the Relation To Domain object. Only applicable for Nutanix domains.`,
						},
						"ipam_gateway": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The IP address management (IPAM) gateway of the Relation To Domain object. Only applicable for Nutanix domains.`,
						},
						"lag_policy_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The link aggregation group (LAG) policy name of the Relation To Domain object.`,
						},
						"netflow_direction": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("both", "egress", "ingress"),
							},
							MarkdownDescription: `The NetFlow monitoring direction of the Relation To Domain object.`,
						},
						"enable_netflow": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("disabled", "enabled"),
							},
							MarkdownDescription: `The Netflow enabled status for the Relation To Domain object.`,
						},
						"number_of_ports": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The number of ports of the Relation To Domain object.`,
						},
						"port_allocation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("elastic", "fixed", "none"),
							},
							MarkdownDescription: `Port allocation for ports.`,
						},
						"primary_encapsulation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The primary encapsulation of the Relation To Domain object. This is used when the class preference is set to 'useg'.`,
						},
						"primary_encapsulation_inner": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The primary inner encapsulation of the Relation To Domain object. This is used for the portgroup at the VMWare Distributed Virtual Switch (DVS). This VLAN is internal to the DVS and is used for communication between the other VMs and the AVE VM at a host. Traffic is not forwarded to the fabric over the VLAN. Only applicable for Cisco ACI Virtual Edge (AVE) domains.`,
						},
						"resolution_immediacy": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("immediate", "lazy", "pre-provision"),
							},
							MarkdownDescription: `The resolution immediacy of the Relation To Domain object. Specifies if policies are resolved immmediately or when needed.`,
						},
						"secondary_encapsulation_inner": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The secondary inner encapsulation of the Relation To Domain object. This is used for the portgroup at the VMWare Distributed Virtual Switch (DVS). This VLAN is internal to the DVS and is used for communication between the other VMs and the AVE VM at a host. Traffic is not forwarded to the fabric over the VLAN. Only applicable for Cisco ACI Virtual Edge (AVE) domains.`,
						},
						"switching_mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("AVE", "native"),
							},
							MarkdownDescription: `The switching mode of the Relation To Domain object.`,
						},
						"target_dn": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The distinguished name of the target Domain object.`,
						},
						"untagged": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("no", "yes"),
							},
							MarkdownDescription: `The untagged status of the Relation To Domain object.`,
						},
					},
				},
			},
			"relation_to_data_plane_policing_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relationship for Dpp QOS policy`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the Relation To Data Plane Policing Policy object.`,
					},
					"data_plane_policing_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `Name.`,
					},
				},
			},
			"relation_to_fibre_channel_paths": schema.SetNestedAttribute{
				MarkdownDescription: `this object is used for creation of static association
                     with a Path for fcoe. Existence of this implies that the
                     corresponding set of policies will be resolved into the
                     node to which the relationship points.`,
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Fibre Channel Path object.`,
						},
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The description of the Relation To Fibre Channel Path object.`,
						},
						"target_dn": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The distinguished name of the target.`,
						},
						"vsan": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The virtual storage area network (VSAN) of the Relation To Fibre Channel Path object.`,
						},
						"vsan_mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("native", "regular"),
							},
							MarkdownDescription: `The virtual storage area network (VSAN) mode of the Relation To Fibre Channel Path object.`,
						},
					},
				},
			},
			"relation_to_intra_epg_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `Intra EPg contract:
                      Represents that the EPg is moving from "allow all within epg" mode
                      to a "deny all within epg" mode.
                      The only type of traffic allowed between EPs in this EPg is the one
                      specified by contracts EPg associates to with this relation.`,
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Intra EPG Contract object.`,
						},
						"contract_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The contract name.`,
						},
					},
				},
			},
			"relation_to_static_leafs": schema.SetNestedAttribute{
				MarkdownDescription: `The static association with an access group is a bundled or unbundled group of ports. The existence of this object implies that the corresponding set of policies will be resolved into the node to which the relationship points.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Static Leaf object.`,
						},
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The description of the Relation To Static Leaf object.`,
						},
						"encapsulation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The VLAN encapsulation of the Relation To Static Leaf object.`,
						},
						"deployment_immediacy": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("immediate", "lazy"),
							},
							MarkdownDescription: `The deployment immediacy of the Relation To Static Leaf object. Specifies when the policy is pushed into the hardware policy content-addressable memory (CAM).`,
						},
						"mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("native", "regular", "untagged"),
							},
							MarkdownDescription: `The static association mode with the path of the Relation To Static Leaf object.`,
						},
						"target_dn": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The distinguished name of the target of this static binding.`,
						},
					},
				},
			},
			"relation_to_static_paths": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to an abstraction of a path endpoint.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Static Path object.`,
						},
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The description of the Relation To Static Path object.`,
						},
						"encapsulation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The VLAN encapsulation of the Relation To Static Path object.`,
						},
						"deployment_immediacy": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("immediate", "lazy"),
							},
							MarkdownDescription: `The deployment immediacy of the Relation To Static Path object. Specifies when the policy is pushed into the hardware policy content-addressable memory (CAM).`,
						},
						"mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("native", "regular", "untagged"),
							},
							MarkdownDescription: `The static association mode of the Relation To Static Path object.`,
						},
						"primary_encapsulation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The primary VLAN encapsulation of the Relation To Static Path object.`,
						},
						"target_dn": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `null.`,
						},
					},
				},
			},
			"relation_to_taboo_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `The taboo contract for which the EPG will be a provider and consumer.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Taboo Contract object.`,
						},
						"taboo_contract_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `A contract for denying specific classes of traffic. Taboo rules are applied in the hardware before applying the rules of regular contracts. Without a contract, the default forwarding policy is to not allow any communication between EPGs.`,
						},
					},
				},
			},
			"relation_to_provided_contracts": schema.SetNestedAttribute{
				MarkdownDescription: `A contract for which the EPG will be a provider.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Provided Contract object.`,
						},
						"match_criteria": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("All", "AtleastOne", "AtmostOne", "None"),
							},
							MarkdownDescription: `The provider label match criteria.`,
						},
						"priority": schema.StringAttribute{
							CustomType: customTypes.FvRsProvPrioStringType{},
							Optional:   true,
							Computed:   true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.Any(
									stringvalidator.OneOf("level1", "level2", "level3", "level4", "level5", "level6", "unspecified"),
									validators.InBetweenFromString(0, 9),
								),
							},
							MarkdownDescription: `The Quality of Service (QoS) priority class ID. QoS refers to the capability of a network to provide better service to selected network traffic over various technologies. The primary goal of QoS is to provide priority including dedicated bandwidth, controlled jitter and latency (required by some real-time and interactive traffic), and improved loss characteristics. You can configure the bandwidth of each QoS level using QoS profiles.`,
						},
						"contract_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The provider contract name.`,
						},
					},
				},
			},
			"relation_to_contract_masters": schema.SetNestedAttribute{
				MarkdownDescription: `Represents that the EPg is inheriting security configuration from another EPg`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators:          []validator.String{},
							MarkdownDescription: `The annotation of the Relation To Contract Master object.`,
						},
						"target_dn": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The distinguished name of the target.`,
						},
					},
				},
			},
			"relation_to_trust_control_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relationship for FHS trust control`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `The annotation of the Relation To Trust Control Policy object.`,
					},
					"trust_control_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators:          []validator.String{},
						MarkdownDescription: `Name.`,
					},
				},
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								MakeStringRequired(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{
			"relation_fv_rs_node_att": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"deployment_immediacy": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'deployment_immediacy' will be deprecated soon, please use 'relation_to_static_leafs.deployment_immediacy' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_static_leafs"),
								}...),
							},
						},
						"description": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'description' will be deprecated soon, please use 'relation_to_static_leafs.description' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_static_leafs"),
								}...),
							},
						},
						"encap": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'encap' will be deprecated soon, please use 'relation_to_static_leafs.encapsulation' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_static_leafs"),
								}...),
							},
						},
						"mode": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'mode' will be deprecated soon, please use 'relation_to_static_leafs.mode' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_static_leafs"),
								}...),
							},
						},
						"node_dn": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'node_dn' will be deprecated soon, please use 'relation_to_static_leafs.target_dn' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_static_leafs"),
								}...),
							},
						},
					},
				},
			},
		},
	}
	tflog.Debug(ctx, "End schema of resource: aci_application_epg")
}

func (r *FvAEPgResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_application_epg")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_application_epg")
}

func (r *FvAEPgResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_application_epg")
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *FvAEPgResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		setFvAEPgId(ctx, stateData)
	}
	getAndSetFvAEPgAttributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The fvAEPg object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	}

	var data *FvAEPgResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Id.IsUnknown() || data.Id.IsNull() {
		setFvAEPgId(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_application_epg with id '%s'", data.Id.ValueString()))

	var fvCrtrnPlan, fvCrtrnState FvCrtrnFvAEPgResourceModel
	data.FvCrtrn.As(ctx, &fvCrtrnPlan, basetypes.ObjectAsOptions{})
	stateData.FvCrtrn.As(ctx, &fvCrtrnState, basetypes.ObjectAsOptions{})
	var fvRsAEPgMonPolPlan, fvRsAEPgMonPolState FvRsAEPgMonPolFvAEPgResourceModel
	data.FvRsAEPgMonPol.As(ctx, &fvRsAEPgMonPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsAEPgMonPol.As(ctx, &fvRsAEPgMonPolState, basetypes.ObjectAsOptions{})
	var fvRsBdPlan, fvRsBdState FvRsBdFvAEPgResourceModel
	data.FvRsBd.As(ctx, &fvRsBdPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBd.As(ctx, &fvRsBdState, basetypes.ObjectAsOptions{})
	var fvRsConsPlan, fvRsConsState []FvRsConsFvAEPgResourceModel
	data.FvRsCons.ElementsAs(ctx, &fvRsConsPlan, false)
	stateData.FvRsCons.ElementsAs(ctx, &fvRsConsState, false)
	var fvRsConsIfPlan, fvRsConsIfState []FvRsConsIfFvAEPgResourceModel
	data.FvRsConsIf.ElementsAs(ctx, &fvRsConsIfPlan, false)
	stateData.FvRsConsIf.ElementsAs(ctx, &fvRsConsIfState, false)
	var fvRsCustQosPolPlan, fvRsCustQosPolState FvRsCustQosPolFvAEPgResourceModel
	data.FvRsCustQosPol.As(ctx, &fvRsCustQosPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsCustQosPol.As(ctx, &fvRsCustQosPolState, basetypes.ObjectAsOptions{})
	var fvRsDomAttPlan, fvRsDomAttState []FvRsDomAttFvAEPgResourceModel
	data.FvRsDomAtt.ElementsAs(ctx, &fvRsDomAttPlan, false)
	stateData.FvRsDomAtt.ElementsAs(ctx, &fvRsDomAttState, false)
	var fvRsDppPolPlan, fvRsDppPolState FvRsDppPolFvAEPgResourceModel
	data.FvRsDppPol.As(ctx, &fvRsDppPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsDppPol.As(ctx, &fvRsDppPolState, basetypes.ObjectAsOptions{})
	var fvRsFcPathAttPlan, fvRsFcPathAttState []FvRsFcPathAttFvAEPgResourceModel
	data.FvRsFcPathAtt.ElementsAs(ctx, &fvRsFcPathAttPlan, false)
	stateData.FvRsFcPathAtt.ElementsAs(ctx, &fvRsFcPathAttState, false)
	var fvRsIntraEpgPlan, fvRsIntraEpgState []FvRsIntraEpgFvAEPgResourceModel
	data.FvRsIntraEpg.ElementsAs(ctx, &fvRsIntraEpgPlan, false)
	stateData.FvRsIntraEpg.ElementsAs(ctx, &fvRsIntraEpgState, false)
	var fvRsNodeAttPlan, fvRsNodeAttState []FvRsNodeAttFvAEPgResourceModel
	data.FvRsNodeAtt.ElementsAs(ctx, &fvRsNodeAttPlan, false)
	stateData.FvRsNodeAtt.ElementsAs(ctx, &fvRsNodeAttState, false)
	var fvRsPathAttPlan, fvRsPathAttState []FvRsPathAttFvAEPgResourceModel
	data.FvRsPathAtt.ElementsAs(ctx, &fvRsPathAttPlan, false)
	stateData.FvRsPathAtt.ElementsAs(ctx, &fvRsPathAttState, false)
	var fvRsProtByPlan, fvRsProtByState []FvRsProtByFvAEPgResourceModel
	data.FvRsProtBy.ElementsAs(ctx, &fvRsProtByPlan, false)
	stateData.FvRsProtBy.ElementsAs(ctx, &fvRsProtByState, false)
	var fvRsProvPlan, fvRsProvState []FvRsProvFvAEPgResourceModel
	data.FvRsProv.ElementsAs(ctx, &fvRsProvPlan, false)
	stateData.FvRsProv.ElementsAs(ctx, &fvRsProvState, false)
	var fvRsSecInheritedPlan, fvRsSecInheritedState []FvRsSecInheritedFvAEPgResourceModel
	data.FvRsSecInherited.ElementsAs(ctx, &fvRsSecInheritedPlan, false)
	stateData.FvRsSecInherited.ElementsAs(ctx, &fvRsSecInheritedState, false)
	var fvRsTrustCtrlPlan, fvRsTrustCtrlState FvRsTrustCtrlFvAEPgResourceModel
	data.FvRsTrustCtrl.As(ctx, &fvRsTrustCtrlPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsTrustCtrl.As(ctx, &fvRsTrustCtrlState, basetypes.ObjectAsOptions{})
	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvAEPgResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvAEPgResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getFvAEPgCreateJsonPayload(ctx, &resp.Diagnostics, true, data, fvCrtrnPlan, fvCrtrnState, fvRsAEPgMonPolPlan, fvRsAEPgMonPolState, fvRsBdPlan, fvRsBdState, fvRsConsPlan, fvRsConsState, fvRsConsIfPlan, fvRsConsIfState, fvRsCustQosPolPlan, fvRsCustQosPolState, fvRsDomAttPlan, fvRsDomAttState, fvRsDppPolPlan, fvRsDppPolState, fvRsFcPathAttPlan, fvRsFcPathAttState, fvRsIntraEpgPlan, fvRsIntraEpgState, fvRsNodeAttPlan, fvRsNodeAttState, fvRsPathAttPlan, fvRsPathAttState, fvRsProtByPlan, fvRsProtByState, fvRsProvPlan, fvRsProvState, fvRsSecInheritedPlan, fvRsSecInheritedState, fvRsTrustCtrlPlan, fvRsTrustCtrlState, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvAEPgAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_application_epg with id '%s'", data.Id.ValueString()))
}

func (r *FvAEPgResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_application_epg")
	var data *FvAEPgResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_application_epg with id '%s'", data.Id.ValueString()))

	getAndSetFvAEPgAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *FvAEPgResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_application_epg with id '%s'", data.Id.ValueString()))
}

func (r *FvAEPgResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_application_epg")
	var data *FvAEPgResourceModel
	var stateData *FvAEPgResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	// Error out when child object fvRsBd is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsBd.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsBd.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsBd object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
	// Error out when child object fvRsCustQosPol is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsCustQosPol.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsCustQosPol.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsCustQosPol object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_application_epg with id '%s'", data.Id.ValueString()))

	var fvCrtrnPlan, fvCrtrnState FvCrtrnFvAEPgResourceModel
	data.FvCrtrn.As(ctx, &fvCrtrnPlan, basetypes.ObjectAsOptions{})
	stateData.FvCrtrn.As(ctx, &fvCrtrnState, basetypes.ObjectAsOptions{})
	var fvRsAEPgMonPolPlan, fvRsAEPgMonPolState FvRsAEPgMonPolFvAEPgResourceModel
	data.FvRsAEPgMonPol.As(ctx, &fvRsAEPgMonPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsAEPgMonPol.As(ctx, &fvRsAEPgMonPolState, basetypes.ObjectAsOptions{})
	var fvRsBdPlan, fvRsBdState FvRsBdFvAEPgResourceModel
	data.FvRsBd.As(ctx, &fvRsBdPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBd.As(ctx, &fvRsBdState, basetypes.ObjectAsOptions{})
	var fvRsConsPlan, fvRsConsState []FvRsConsFvAEPgResourceModel
	data.FvRsCons.ElementsAs(ctx, &fvRsConsPlan, false)
	stateData.FvRsCons.ElementsAs(ctx, &fvRsConsState, false)
	var fvRsConsIfPlan, fvRsConsIfState []FvRsConsIfFvAEPgResourceModel
	data.FvRsConsIf.ElementsAs(ctx, &fvRsConsIfPlan, false)
	stateData.FvRsConsIf.ElementsAs(ctx, &fvRsConsIfState, false)
	var fvRsCustQosPolPlan, fvRsCustQosPolState FvRsCustQosPolFvAEPgResourceModel
	data.FvRsCustQosPol.As(ctx, &fvRsCustQosPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsCustQosPol.As(ctx, &fvRsCustQosPolState, basetypes.ObjectAsOptions{})
	var fvRsDomAttPlan, fvRsDomAttState []FvRsDomAttFvAEPgResourceModel
	data.FvRsDomAtt.ElementsAs(ctx, &fvRsDomAttPlan, false)
	stateData.FvRsDomAtt.ElementsAs(ctx, &fvRsDomAttState, false)
	var fvRsDppPolPlan, fvRsDppPolState FvRsDppPolFvAEPgResourceModel
	data.FvRsDppPol.As(ctx, &fvRsDppPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsDppPol.As(ctx, &fvRsDppPolState, basetypes.ObjectAsOptions{})
	var fvRsFcPathAttPlan, fvRsFcPathAttState []FvRsFcPathAttFvAEPgResourceModel
	data.FvRsFcPathAtt.ElementsAs(ctx, &fvRsFcPathAttPlan, false)
	stateData.FvRsFcPathAtt.ElementsAs(ctx, &fvRsFcPathAttState, false)
	var fvRsIntraEpgPlan, fvRsIntraEpgState []FvRsIntraEpgFvAEPgResourceModel
	data.FvRsIntraEpg.ElementsAs(ctx, &fvRsIntraEpgPlan, false)
	stateData.FvRsIntraEpg.ElementsAs(ctx, &fvRsIntraEpgState, false)
	var fvRsNodeAttPlan, fvRsNodeAttState []FvRsNodeAttFvAEPgResourceModel
	data.FvRsNodeAtt.ElementsAs(ctx, &fvRsNodeAttPlan, false)
	stateData.FvRsNodeAtt.ElementsAs(ctx, &fvRsNodeAttState, false)
	var fvRsPathAttPlan, fvRsPathAttState []FvRsPathAttFvAEPgResourceModel
	data.FvRsPathAtt.ElementsAs(ctx, &fvRsPathAttPlan, false)
	stateData.FvRsPathAtt.ElementsAs(ctx, &fvRsPathAttState, false)
	var fvRsProtByPlan, fvRsProtByState []FvRsProtByFvAEPgResourceModel
	data.FvRsProtBy.ElementsAs(ctx, &fvRsProtByPlan, false)
	stateData.FvRsProtBy.ElementsAs(ctx, &fvRsProtByState, false)
	var fvRsProvPlan, fvRsProvState []FvRsProvFvAEPgResourceModel
	data.FvRsProv.ElementsAs(ctx, &fvRsProvPlan, false)
	stateData.FvRsProv.ElementsAs(ctx, &fvRsProvState, false)
	var fvRsSecInheritedPlan, fvRsSecInheritedState []FvRsSecInheritedFvAEPgResourceModel
	data.FvRsSecInherited.ElementsAs(ctx, &fvRsSecInheritedPlan, false)
	stateData.FvRsSecInherited.ElementsAs(ctx, &fvRsSecInheritedState, false)
	var fvRsTrustCtrlPlan, fvRsTrustCtrlState FvRsTrustCtrlFvAEPgResourceModel
	data.FvRsTrustCtrl.As(ctx, &fvRsTrustCtrlPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsTrustCtrl.As(ctx, &fvRsTrustCtrlState, basetypes.ObjectAsOptions{})
	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvAEPgResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvAEPgResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getFvAEPgCreateJsonPayload(ctx, &resp.Diagnostics, false, data, fvCrtrnPlan, fvCrtrnState, fvRsAEPgMonPolPlan, fvRsAEPgMonPolState, fvRsBdPlan, fvRsBdState, fvRsConsPlan, fvRsConsState, fvRsConsIfPlan, fvRsConsIfState, fvRsCustQosPolPlan, fvRsCustQosPolState, fvRsDomAttPlan, fvRsDomAttState, fvRsDppPolPlan, fvRsDppPolState, fvRsFcPathAttPlan, fvRsFcPathAttState, fvRsIntraEpgPlan, fvRsIntraEpgState, fvRsNodeAttPlan, fvRsNodeAttState, fvRsPathAttPlan, fvRsPathAttState, fvRsProtByPlan, fvRsProtByState, fvRsProvPlan, fvRsProvState, fvRsSecInheritedPlan, fvRsSecInheritedState, fvRsTrustCtrlPlan, fvRsTrustCtrlState, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvAEPgAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_application_epg with id '%s'", data.Id.ValueString()))
}

func (r *FvAEPgResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_application_epg")
	var data *FvAEPgResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_application_epg with id '%s'", data.Id.ValueString()))
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "fvAEPg", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_application_epg with id '%s'", data.Id.ValueString()))
}

func (r *FvAEPgResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_application_epg")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	var stateData *FvAEPgResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_application_epg with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_application_epg")
}

func getAndSetFvAEPgAttributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *FvAEPgResourceModel) {
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=children&rsp-subtree-class=%s", data.Id.ValueString(), "fvAEPg,fvCrtrn,fvRsAEPgMonPol,fvRsBd,fvRsCons,fvRsConsIf,fvRsCustQosPol,fvRsDomAtt,fvRsDppPol,fvRsFcPathAtt,fvRsIntraEpg,fvRsNodeAtt,fvRsPathAtt,fvRsProtBy,fvRsProv,fvRsSecInherited,fvRsTrustCtrl,tagAnnotation,tagTag"), "GET", nil)

	readData := getEmptyFvAEPgResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("fvAEPg").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("fvAEPg").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					readData.Id = basetypes.NewStringValue(attributeValue.(string))
					setFvAEPgParentDn(ctx, attributeValue.(string), readData)
				}
				if attributeName == "annotation" {
					readData.Annotation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "descr" {
					readData.Descr = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "exceptionTag" {
					readData.ExceptionTag = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "floodOnEncap" {
					readData.FloodOnEncap = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "fwdCtrl" && attributeValue.(string) == "" {
					readData.FwdCtrl = basetypes.NewStringValue("none")
				} else if attributeName == "fwdCtrl" {
					readData.FwdCtrl = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "hasMcastSource" {
					readData.HasMcastSource = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "isAttrBasedEPg" {
					readData.IsAttrBasedEPg = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "matchT" {
					readData.MatchT = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "name" {
					readData.Name = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "nameAlias" {
					readData.NameAlias = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "pcEnfPref" {
					readData.PcEnfPref = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "pcTag" {
					readData.PcTag = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "prefGrMemb" {
					readData.PrefGrMemb = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "prio" {
					readData.Prio = customTypes.NewFvAEPgPrioStringValue(attributeValue.(string))
				}
				if attributeName == "shutdown" {
					readData.Shutdown = basetypes.NewStringValue(attributeValue.(string))
				}
			}
			FvCrtrnFvAEPgList := make([]FvCrtrnFvAEPgResourceModel, 0)
			FvRsAEPgMonPolFvAEPgList := make([]FvRsAEPgMonPolFvAEPgResourceModel, 0)
			FvRsBdFvAEPgList := make([]FvRsBdFvAEPgResourceModel, 0)
			FvRsConsFvAEPgList := make([]FvRsConsFvAEPgResourceModel, 0)
			FvRsConsIfFvAEPgList := make([]FvRsConsIfFvAEPgResourceModel, 0)
			FvRsCustQosPolFvAEPgList := make([]FvRsCustQosPolFvAEPgResourceModel, 0)
			FvRsDomAttFvAEPgList := make([]FvRsDomAttFvAEPgResourceModel, 0)
			FvRsDppPolFvAEPgList := make([]FvRsDppPolFvAEPgResourceModel, 0)
			FvRsFcPathAttFvAEPgList := make([]FvRsFcPathAttFvAEPgResourceModel, 0)
			FvRsIntraEpgFvAEPgList := make([]FvRsIntraEpgFvAEPgResourceModel, 0)
			FvRsNodeAttFvAEPgList := make([]FvRsNodeAttFvAEPgResourceModel, 0)
			FvRsPathAttFvAEPgList := make([]FvRsPathAttFvAEPgResourceModel, 0)
			FvRsProtByFvAEPgList := make([]FvRsProtByFvAEPgResourceModel, 0)
			FvRsProvFvAEPgList := make([]FvRsProvFvAEPgResourceModel, 0)
			FvRsSecInheritedFvAEPgList := make([]FvRsSecInheritedFvAEPgResourceModel, 0)
			FvRsTrustCtrlFvAEPgList := make([]FvRsTrustCtrlFvAEPgResourceModel, 0)
			TagAnnotationFvAEPgList := make([]TagAnnotationFvAEPgResourceModel, 0)
			TagTagFvAEPgList := make([]TagTagFvAEPgResourceModel, 0)
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						if childClassName == "fvCrtrn" {
							FvCrtrnFvAEPg := getEmptyFvCrtrnFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvCrtrnFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvCrtrnFvAEPg.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "match" {
									FvCrtrnFvAEPg.Match = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "name" {
									FvCrtrnFvAEPg.Name = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "nameAlias" {
									FvCrtrnFvAEPg.NameAlias = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ownerKey" {
									FvCrtrnFvAEPg.OwnerKey = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ownerTag" {
									FvCrtrnFvAEPg.OwnerTag = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prec" {
									FvCrtrnFvAEPg.Prec = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "scope" {
									FvCrtrnFvAEPg.Scope = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvCrtrnFvAEPgList = append(FvCrtrnFvAEPgList, FvCrtrnFvAEPg)
						}
						if childClassName == "fvRsAEPgMonPol" {
							FvRsAEPgMonPolFvAEPg := getEmptyFvRsAEPgMonPolFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsAEPgMonPolFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnMonEPGPolName" {
									FvRsAEPgMonPolFvAEPg.TnMonEPGPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsAEPgMonPolFvAEPgList = append(FvRsAEPgMonPolFvAEPgList, FvRsAEPgMonPolFvAEPg)
						}
						if childClassName == "fvRsBd" {
							FvRsBdFvAEPg := getEmptyFvRsBdFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBdFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnFvBDName" {
									FvRsBdFvAEPg.TnFvBDName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBdFvAEPgList = append(FvRsBdFvAEPgList, FvRsBdFvAEPg)
						}
						if childClassName == "fvRsCons" {
							FvRsConsFvAEPg := getEmptyFvRsConsFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsConsFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									FvRsConsFvAEPg.Prio = customTypes.NewFvRsConsPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzBrCPName" {
									FvRsConsFvAEPg.TnVzBrCPName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsConsFvAEPgList = append(FvRsConsFvAEPgList, FvRsConsFvAEPg)
						}
						if childClassName == "fvRsConsIf" {
							FvRsConsIfFvAEPg := getEmptyFvRsConsIfFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsConsIfFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									FvRsConsIfFvAEPg.Prio = customTypes.NewFvRsConsIfPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzCPIfName" {
									FvRsConsIfFvAEPg.TnVzCPIfName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsConsIfFvAEPgList = append(FvRsConsIfFvAEPgList, FvRsConsIfFvAEPg)
						}
						if childClassName == "fvRsCustQosPol" {
							FvRsCustQosPolFvAEPg := getEmptyFvRsCustQosPolFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsCustQosPolFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnQosCustomPolName" {
									FvRsCustQosPolFvAEPg.TnQosCustomPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsCustQosPolFvAEPgList = append(FvRsCustQosPolFvAEPgList, FvRsCustQosPolFvAEPg)
						}
						if childClassName == "fvRsDomAtt" {
							FvRsDomAttFvAEPg := getEmptyFvRsDomAttFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsDomAttFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "bindingType" && childAttributeValue.(string) == "" {
									FvRsDomAttFvAEPg.BindingType = basetypes.NewStringValue("none")
								} else if childAttributeName == "bindingType" {
									FvRsDomAttFvAEPg.BindingType = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "classPref" {
									FvRsDomAttFvAEPg.ClassPref = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "customEpgName" {
									FvRsDomAttFvAEPg.CustomEpgName = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "delimiter" {
									FvRsDomAttFvAEPg.Delimiter = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "encap" {
									FvRsDomAttFvAEPg.Encap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "encapMode" {
									FvRsDomAttFvAEPg.EncapMode = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "epgCos" {
									FvRsDomAttFvAEPg.EpgCos = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "epgCosPref" {
									FvRsDomAttFvAEPg.EpgCosPref = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "instrImedcy" {
									FvRsDomAttFvAEPg.InstrImedcy = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ipamDhcpOverride" {
									FvRsDomAttFvAEPg.IpamDhcpOverride = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ipamEnabled" {
									FvRsDomAttFvAEPg.IpamEnabled = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ipamGateway" {
									FvRsDomAttFvAEPg.IpamGateway = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "lagPolicyName" {
									FvRsDomAttFvAEPg.LagPolicyName = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "netflowDir" {
									FvRsDomAttFvAEPg.NetflowDir = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "netflowPref" {
									FvRsDomAttFvAEPg.NetflowPref = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "numPorts" {
									FvRsDomAttFvAEPg.NumPorts = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "portAllocation" && childAttributeValue.(string) == "" {
									FvRsDomAttFvAEPg.PortAllocation = basetypes.NewStringValue("none")
								} else if childAttributeName == "portAllocation" {
									FvRsDomAttFvAEPg.PortAllocation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "primaryEncap" {
									FvRsDomAttFvAEPg.PrimaryEncap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "primaryEncapInner" {
									FvRsDomAttFvAEPg.PrimaryEncapInner = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "resImedcy" {
									FvRsDomAttFvAEPg.ResImedcy = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "secondaryEncapInner" {
									FvRsDomAttFvAEPg.SecondaryEncapInner = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "switchingMode" {
									FvRsDomAttFvAEPg.SwitchingMode = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tDn" {
									FvRsDomAttFvAEPg.TDn = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "untagged" {
									FvRsDomAttFvAEPg.Untagged = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsDomAttFvAEPgList = append(FvRsDomAttFvAEPgList, FvRsDomAttFvAEPg)
						}
						if childClassName == "fvRsDppPol" {
							FvRsDppPolFvAEPg := getEmptyFvRsDppPolFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsDppPolFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnQosDppPolName" {
									FvRsDppPolFvAEPg.TnQosDppPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsDppPolFvAEPgList = append(FvRsDppPolFvAEPgList, FvRsDppPolFvAEPg)
						}
						if childClassName == "fvRsFcPathAtt" {
							FvRsFcPathAttFvAEPg := getEmptyFvRsFcPathAttFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsFcPathAttFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvRsFcPathAttFvAEPg.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tDn" {
									FvRsFcPathAttFvAEPg.TDn = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "vsan" {
									FvRsFcPathAttFvAEPg.Vsan = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "vsanMode" {
									FvRsFcPathAttFvAEPg.VsanMode = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsFcPathAttFvAEPgList = append(FvRsFcPathAttFvAEPgList, FvRsFcPathAttFvAEPg)
						}
						if childClassName == "fvRsIntraEpg" {
							FvRsIntraEpgFvAEPg := getEmptyFvRsIntraEpgFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsIntraEpgFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzBrCPName" {
									FvRsIntraEpgFvAEPg.TnVzBrCPName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsIntraEpgFvAEPgList = append(FvRsIntraEpgFvAEPgList, FvRsIntraEpgFvAEPg)
						}
						if childClassName == "fvRsNodeAtt" {
							FvRsNodeAttFvAEPg := getEmptyFvRsNodeAttFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsNodeAttFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvRsNodeAttFvAEPg.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "encap" {
									FvRsNodeAttFvAEPg.Encap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "instrImedcy" {
									FvRsNodeAttFvAEPg.InstrImedcy = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "mode" {
									FvRsNodeAttFvAEPg.Mode = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tDn" {
									FvRsNodeAttFvAEPg.TDn = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsNodeAttFvAEPgList = append(FvRsNodeAttFvAEPgList, FvRsNodeAttFvAEPg)
						}
						if childClassName == "fvRsPathAtt" {
							FvRsPathAttFvAEPg := getEmptyFvRsPathAttFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsPathAttFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvRsPathAttFvAEPg.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "encap" {
									FvRsPathAttFvAEPg.Encap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "instrImedcy" {
									FvRsPathAttFvAEPg.InstrImedcy = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "mode" {
									FvRsPathAttFvAEPg.Mode = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "primaryEncap" {
									FvRsPathAttFvAEPg.PrimaryEncap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tDn" {
									FvRsPathAttFvAEPg.TDn = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsPathAttFvAEPgList = append(FvRsPathAttFvAEPgList, FvRsPathAttFvAEPg)
						}
						if childClassName == "fvRsProtBy" {
							FvRsProtByFvAEPg := getEmptyFvRsProtByFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsProtByFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzTabooName" {
									FvRsProtByFvAEPg.TnVzTabooName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsProtByFvAEPgList = append(FvRsProtByFvAEPgList, FvRsProtByFvAEPg)
						}
						if childClassName == "fvRsProv" {
							FvRsProvFvAEPg := getEmptyFvRsProvFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsProvFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "matchT" {
									FvRsProvFvAEPg.MatchT = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "prio" {
									FvRsProvFvAEPg.Prio = customTypes.NewFvRsProvPrioStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnVzBrCPName" {
									FvRsProvFvAEPg.TnVzBrCPName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsProvFvAEPgList = append(FvRsProvFvAEPgList, FvRsProvFvAEPg)
						}
						if childClassName == "fvRsSecInherited" {
							FvRsSecInheritedFvAEPg := getEmptyFvRsSecInheritedFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsSecInheritedFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tDn" {
									FvRsSecInheritedFvAEPg.TDn = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsSecInheritedFvAEPgList = append(FvRsSecInheritedFvAEPgList, FvRsSecInheritedFvAEPg)
						}
						if childClassName == "fvRsTrustCtrl" {
							FvRsTrustCtrlFvAEPg := getEmptyFvRsTrustCtrlFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsTrustCtrlFvAEPg.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnFhsTrustCtrlPolName" {
									FvRsTrustCtrlFvAEPg.TnFhsTrustCtrlPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsTrustCtrlFvAEPgList = append(FvRsTrustCtrlFvAEPgList, FvRsTrustCtrlFvAEPg)
						}
						if childClassName == "tagAnnotation" {
							TagAnnotationFvAEPg := getEmptyTagAnnotationFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagAnnotationFvAEPg.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagAnnotationFvAEPg.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagAnnotationFvAEPgList = append(TagAnnotationFvAEPgList, TagAnnotationFvAEPg)
						}
						if childClassName == "tagTag" {
							TagTagFvAEPg := getEmptyTagTagFvAEPgResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagTagFvAEPg.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagTagFvAEPg.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagTagFvAEPgList = append(TagTagFvAEPgList, TagTagFvAEPg)
						}
					}
				}
			}
			if len(FvCrtrnFvAEPgList) == 1 {
				fvCrtrnObject, _ := types.ObjectValueFrom(ctx, FvCrtrnFvAEPgType, FvCrtrnFvAEPgList[0])
				readData.FvCrtrn = fvCrtrnObject
			} else {
				fvCrtrnObject, _ := types.ObjectValueFrom(ctx, FvCrtrnFvAEPgType, getEmptyFvCrtrnFvAEPgResourceModel())
				readData.FvCrtrn = fvCrtrnObject
			}
			if len(FvRsAEPgMonPolFvAEPgList) == 1 {
				fvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, FvRsAEPgMonPolFvAEPgList[0])
				readData.FvRsAEPgMonPol = fvRsAEPgMonPolObject
			} else {
				fvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, getEmptyFvRsAEPgMonPolFvAEPgResourceModel())
				readData.FvRsAEPgMonPol = fvRsAEPgMonPolObject
			}
			if len(FvRsBdFvAEPgList) == 1 {
				fvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, FvRsBdFvAEPgList[0])
				readData.FvRsBd = fvRsBdObject
			} else {
				fvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, getEmptyFvRsBdFvAEPgResourceModel())
				readData.FvRsBd = fvRsBdObject
			}
			fvRsConsSet, _ := types.SetValueFrom(ctx, readData.FvRsCons.ElementType(ctx), FvRsConsFvAEPgList)
			readData.FvRsCons = fvRsConsSet
			fvRsConsIfSet, _ := types.SetValueFrom(ctx, readData.FvRsConsIf.ElementType(ctx), FvRsConsIfFvAEPgList)
			readData.FvRsConsIf = fvRsConsIfSet
			if len(FvRsCustQosPolFvAEPgList) == 1 {
				fvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, FvRsCustQosPolFvAEPgList[0])
				readData.FvRsCustQosPol = fvRsCustQosPolObject
			} else {
				fvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, getEmptyFvRsCustQosPolFvAEPgResourceModel())
				readData.FvRsCustQosPol = fvRsCustQosPolObject
			}
			fvRsDomAttSet, _ := types.SetValueFrom(ctx, readData.FvRsDomAtt.ElementType(ctx), FvRsDomAttFvAEPgList)
			readData.FvRsDomAtt = fvRsDomAttSet
			if len(FvRsDppPolFvAEPgList) == 1 {
				fvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, FvRsDppPolFvAEPgList[0])
				readData.FvRsDppPol = fvRsDppPolObject
			} else {
				fvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, getEmptyFvRsDppPolFvAEPgResourceModel())
				readData.FvRsDppPol = fvRsDppPolObject
			}
			fvRsFcPathAttSet, _ := types.SetValueFrom(ctx, readData.FvRsFcPathAtt.ElementType(ctx), FvRsFcPathAttFvAEPgList)
			readData.FvRsFcPathAtt = fvRsFcPathAttSet
			fvRsIntraEpgSet, _ := types.SetValueFrom(ctx, readData.FvRsIntraEpg.ElementType(ctx), FvRsIntraEpgFvAEPgList)
			readData.FvRsIntraEpg = fvRsIntraEpgSet
			fvRsNodeAttSet, _ := types.SetValueFrom(ctx, readData.FvRsNodeAtt.ElementType(ctx), FvRsNodeAttFvAEPgList)
			readData.FvRsNodeAtt = fvRsNodeAttSet
			fvRsPathAttSet, _ := types.SetValueFrom(ctx, readData.FvRsPathAtt.ElementType(ctx), FvRsPathAttFvAEPgList)
			readData.FvRsPathAtt = fvRsPathAttSet
			fvRsProtBySet, _ := types.SetValueFrom(ctx, readData.FvRsProtBy.ElementType(ctx), FvRsProtByFvAEPgList)
			readData.FvRsProtBy = fvRsProtBySet
			fvRsProvSet, _ := types.SetValueFrom(ctx, readData.FvRsProv.ElementType(ctx), FvRsProvFvAEPgList)
			readData.FvRsProv = fvRsProvSet
			fvRsSecInheritedSet, _ := types.SetValueFrom(ctx, readData.FvRsSecInherited.ElementType(ctx), FvRsSecInheritedFvAEPgList)
			readData.FvRsSecInherited = fvRsSecInheritedSet
			if len(FvRsTrustCtrlFvAEPgList) == 1 {
				fvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, FvRsTrustCtrlFvAEPgList[0])
				readData.FvRsTrustCtrl = fvRsTrustCtrlObject
			} else {
				fvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, getEmptyFvRsTrustCtrlFvAEPgResourceModel())
				readData.FvRsTrustCtrl = fvRsTrustCtrlObject
			}
			tagAnnotationSet, _ := types.SetValueFrom(ctx, readData.TagAnnotation.ElementType(ctx), TagAnnotationFvAEPgList)
			readData.TagAnnotation = tagAnnotationSet
			tagTagSet, _ := types.SetValueFrom(ctx, readData.TagTag.ElementType(ctx), TagTagFvAEPgList)
			readData.TagTag = tagTagSet
			setFvAEPgLegacyAttributes(ctx, diags, readData, data, classReadInfo)
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class 'fvAEPg'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		readData.Id = basetypes.NewStringNull()
	}
	*data = *readData
}

func getFvAEPgRn(ctx context.Context, data *FvAEPgResourceModel) string {
	rn := "epg-{name}"
	for _, identifier := range []string{"name"} {
		fieldName := fmt.Sprintf("%s%s", strings.ToUpper(identifier[:1]), identifier[1:])
		fieldValue := reflect.ValueOf(data).Elem().FieldByName(fieldName).Interface().(basetypes.StringValue).ValueString()
		rn = strings.ReplaceAll(rn, fmt.Sprintf("{%s}", identifier), fieldValue)
	}
	return rn
}

func setFvAEPgParentDn(ctx context.Context, dn string, data *FvAEPgResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
}

func setFvAEPgId(ctx context.Context, data *FvAEPgResourceModel) {
	rn := getFvAEPgRn(ctx, data)
	data.Id = types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
}

func getFvAEPgFvCrtrnChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvCrtrnPlan, fvCrtrnState FvCrtrnFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvCrtrn.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvCrtrn.Attributes()) {
			if !fvCrtrnPlan.Annotation.IsUnknown() && !fvCrtrnPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvCrtrnPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvCrtrnPlan.Descr.IsUnknown() && !fvCrtrnPlan.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvCrtrnPlan.Descr.ValueString()
			}
			if !fvCrtrnPlan.Match.IsUnknown() && !fvCrtrnPlan.Match.IsNull() {
				childMap["attributes"]["match"] = fvCrtrnPlan.Match.ValueString()
			}
			if !fvCrtrnPlan.Name.IsUnknown() && !fvCrtrnPlan.Name.IsNull() {
				childMap["attributes"]["name"] = fvCrtrnPlan.Name.ValueString()
			}
			if !fvCrtrnPlan.NameAlias.IsUnknown() && !fvCrtrnPlan.NameAlias.IsNull() {
				childMap["attributes"]["nameAlias"] = fvCrtrnPlan.NameAlias.ValueString()
			}
			if !fvCrtrnPlan.OwnerKey.IsUnknown() && !fvCrtrnPlan.OwnerKey.IsNull() {
				childMap["attributes"]["ownerKey"] = fvCrtrnPlan.OwnerKey.ValueString()
			}
			if !fvCrtrnPlan.OwnerTag.IsUnknown() && !fvCrtrnPlan.OwnerTag.IsNull() {
				childMap["attributes"]["ownerTag"] = fvCrtrnPlan.OwnerTag.ValueString()
			}
			if !fvCrtrnPlan.Prec.IsUnknown() && !fvCrtrnPlan.Prec.IsNull() {
				childMap["attributes"]["prec"] = fvCrtrnPlan.Prec.ValueString()
			}
			if !fvCrtrnPlan.Scope.IsUnknown() && !fvCrtrnPlan.Scope.IsNull() {
				childMap["attributes"]["scope"] = fvCrtrnPlan.Scope.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvCrtrn": childMap})
	} else {
		FvCrtrnObject, _ := types.ObjectValueFrom(ctx, FvCrtrnFvAEPgType, getEmptyFvCrtrnFvAEPgResourceModel())
		data.FvCrtrn = FvCrtrnObject
	}

	return childPayloads
}
func getFvAEPgFvRsAEPgMonPolChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsAEPgMonPolPlan, fvRsAEPgMonPolState FvRsAEPgMonPolFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsAEPgMonPol.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsAEPgMonPol.Attributes()) {
			if !fvRsAEPgMonPolPlan.Annotation.IsUnknown() && !fvRsAEPgMonPolPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsAEPgMonPolPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsAEPgMonPolPlan.TnMonEPGPolName.IsUnknown() && !fvRsAEPgMonPolPlan.TnMonEPGPolName.IsNull() {
				childMap["attributes"]["tnMonEPGPolName"] = fvRsAEPgMonPolPlan.TnMonEPGPolName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsAEPgMonPol": childMap})
	} else {
		FvRsAEPgMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsAEPgMonPolFvAEPgType, getEmptyFvRsAEPgMonPolFvAEPgResourceModel())
		data.FvRsAEPgMonPol = FvRsAEPgMonPolObject
	}

	return childPayloads
}
func getFvAEPgFvRsBdChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsBdPlan, fvRsBdState FvRsBdFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBd.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBd.Attributes()) {
			if !fvRsBdPlan.Annotation.IsUnknown() && !fvRsBdPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBdPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBdPlan.TnFvBDName.IsUnknown() && !fvRsBdPlan.TnFvBDName.IsNull() {
				childMap["attributes"]["tnFvBDName"] = fvRsBdPlan.TnFvBDName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBd": childMap})
	} else {
		FvRsBdObject, _ := types.ObjectValueFrom(ctx, FvRsBdFvAEPgType, getEmptyFvRsBdFvAEPgResourceModel())
		data.FvRsBd = FvRsBdObject
	}

	return childPayloads
}
func getFvAEPgFvRsConsChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsConsPlan, fvRsConsState []FvRsConsFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsCons.IsUnknown() {
		fvRsConsIdentifiers := []FvRsConsIdentifier{}
		for _, fvRsCons := range fvRsConsPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsCons.Annotation.IsUnknown() && !fvRsCons.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsCons.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsCons.Prio.IsUnknown() && !fvRsCons.Prio.IsNull() {
				childMap["attributes"]["prio"] = fvRsCons.Prio.ValueString()
			}
			if !fvRsCons.TnVzBrCPName.IsUnknown() && !fvRsCons.TnVzBrCPName.IsNull() {
				childMap["attributes"]["tnVzBrCPName"] = fvRsCons.TnVzBrCPName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsCons": childMap})
			fvRsConsIdentifier := FvRsConsIdentifier{}
			fvRsConsIdentifier.TnVzBrCPName = fvRsCons.TnVzBrCPName
			fvRsConsIdentifiers = append(fvRsConsIdentifiers, fvRsConsIdentifier)
		}
		for _, fvRsCons := range fvRsConsState {
			delete := true
			for _, fvRsConsIdentifier := range fvRsConsIdentifiers {
				if fvRsConsIdentifier.TnVzBrCPName == fvRsCons.TnVzBrCPName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnVzBrCPName"] = fvRsCons.TnVzBrCPName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsCons": childMap})
			}
		}
	} else {
		data.FvRsCons = types.SetNull(data.FvRsCons.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsConsIfChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsConsIfPlan, fvRsConsIfState []FvRsConsIfFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsConsIf.IsUnknown() {
		fvRsConsIfIdentifiers := []FvRsConsIfIdentifier{}
		for _, fvRsConsIf := range fvRsConsIfPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsConsIf.Annotation.IsUnknown() && !fvRsConsIf.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsConsIf.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsConsIf.Prio.IsUnknown() && !fvRsConsIf.Prio.IsNull() {
				childMap["attributes"]["prio"] = fvRsConsIf.Prio.ValueString()
			}
			if !fvRsConsIf.TnVzCPIfName.IsUnknown() && !fvRsConsIf.TnVzCPIfName.IsNull() {
				childMap["attributes"]["tnVzCPIfName"] = fvRsConsIf.TnVzCPIfName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsConsIf": childMap})
			fvRsConsIfIdentifier := FvRsConsIfIdentifier{}
			fvRsConsIfIdentifier.TnVzCPIfName = fvRsConsIf.TnVzCPIfName
			fvRsConsIfIdentifiers = append(fvRsConsIfIdentifiers, fvRsConsIfIdentifier)
		}
		for _, fvRsConsIf := range fvRsConsIfState {
			delete := true
			for _, fvRsConsIfIdentifier := range fvRsConsIfIdentifiers {
				if fvRsConsIfIdentifier.TnVzCPIfName == fvRsConsIf.TnVzCPIfName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnVzCPIfName"] = fvRsConsIf.TnVzCPIfName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsConsIf": childMap})
			}
		}
	} else {
		data.FvRsConsIf = types.SetNull(data.FvRsConsIf.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsCustQosPolChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsCustQosPolPlan, fvRsCustQosPolState FvRsCustQosPolFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsCustQosPol.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsCustQosPol.Attributes()) {
			if !fvRsCustQosPolPlan.Annotation.IsUnknown() && !fvRsCustQosPolPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsCustQosPolPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsCustQosPolPlan.TnQosCustomPolName.IsUnknown() && !fvRsCustQosPolPlan.TnQosCustomPolName.IsNull() {
				childMap["attributes"]["tnQosCustomPolName"] = fvRsCustQosPolPlan.TnQosCustomPolName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsCustQosPol": childMap})
	} else {
		FvRsCustQosPolObject, _ := types.ObjectValueFrom(ctx, FvRsCustQosPolFvAEPgType, getEmptyFvRsCustQosPolFvAEPgResourceModel())
		data.FvRsCustQosPol = FvRsCustQosPolObject
	}

	return childPayloads
}
func getFvAEPgFvRsDomAttChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsDomAttPlan, fvRsDomAttState []FvRsDomAttFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsDomAtt.IsUnknown() {
		fvRsDomAttIdentifiers := []FvRsDomAttIdentifier{}
		for _, fvRsDomAtt := range fvRsDomAttPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsDomAtt.Annotation.IsUnknown() && !fvRsDomAtt.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsDomAtt.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsDomAtt.BindingType.IsUnknown() && !fvRsDomAtt.BindingType.IsNull() {
				childMap["attributes"]["bindingType"] = fvRsDomAtt.BindingType.ValueString()
			}
			if !fvRsDomAtt.ClassPref.IsUnknown() && !fvRsDomAtt.ClassPref.IsNull() {
				childMap["attributes"]["classPref"] = fvRsDomAtt.ClassPref.ValueString()
			}
			if !fvRsDomAtt.CustomEpgName.IsUnknown() && !fvRsDomAtt.CustomEpgName.IsNull() {
				childMap["attributes"]["customEpgName"] = fvRsDomAtt.CustomEpgName.ValueString()
			}
			if !fvRsDomAtt.Delimiter.IsUnknown() && !fvRsDomAtt.Delimiter.IsNull() {
				childMap["attributes"]["delimiter"] = fvRsDomAtt.Delimiter.ValueString()
			}
			if !fvRsDomAtt.Encap.IsUnknown() && !fvRsDomAtt.Encap.IsNull() {
				childMap["attributes"]["encap"] = fvRsDomAtt.Encap.ValueString()
			}
			if !fvRsDomAtt.EncapMode.IsUnknown() && !fvRsDomAtt.EncapMode.IsNull() {
				childMap["attributes"]["encapMode"] = fvRsDomAtt.EncapMode.ValueString()
			}
			if !fvRsDomAtt.EpgCos.IsUnknown() && !fvRsDomAtt.EpgCos.IsNull() {
				childMap["attributes"]["epgCos"] = fvRsDomAtt.EpgCos.ValueString()
			}
			if !fvRsDomAtt.EpgCosPref.IsUnknown() && !fvRsDomAtt.EpgCosPref.IsNull() {
				childMap["attributes"]["epgCosPref"] = fvRsDomAtt.EpgCosPref.ValueString()
			}
			if !fvRsDomAtt.InstrImedcy.IsUnknown() && !fvRsDomAtt.InstrImedcy.IsNull() {
				childMap["attributes"]["instrImedcy"] = fvRsDomAtt.InstrImedcy.ValueString()
			}
			if !fvRsDomAtt.IpamDhcpOverride.IsUnknown() && !fvRsDomAtt.IpamDhcpOverride.IsNull() {
				childMap["attributes"]["ipamDhcpOverride"] = fvRsDomAtt.IpamDhcpOverride.ValueString()
			}
			if !fvRsDomAtt.IpamEnabled.IsUnknown() && !fvRsDomAtt.IpamEnabled.IsNull() {
				childMap["attributes"]["ipamEnabled"] = fvRsDomAtt.IpamEnabled.ValueString()
			}
			if !fvRsDomAtt.IpamGateway.IsUnknown() && !fvRsDomAtt.IpamGateway.IsNull() {
				childMap["attributes"]["ipamGateway"] = fvRsDomAtt.IpamGateway.ValueString()
			}
			if !fvRsDomAtt.LagPolicyName.IsUnknown() && !fvRsDomAtt.LagPolicyName.IsNull() {
				childMap["attributes"]["lagPolicyName"] = fvRsDomAtt.LagPolicyName.ValueString()
			}
			if !fvRsDomAtt.NetflowDir.IsUnknown() && !fvRsDomAtt.NetflowDir.IsNull() {
				childMap["attributes"]["netflowDir"] = fvRsDomAtt.NetflowDir.ValueString()
			}
			if !fvRsDomAtt.NetflowPref.IsUnknown() && !fvRsDomAtt.NetflowPref.IsNull() {
				childMap["attributes"]["netflowPref"] = fvRsDomAtt.NetflowPref.ValueString()
			}
			if !fvRsDomAtt.NumPorts.IsUnknown() && !fvRsDomAtt.NumPorts.IsNull() {
				childMap["attributes"]["numPorts"] = fvRsDomAtt.NumPorts.ValueString()
			}
			if !fvRsDomAtt.PortAllocation.IsUnknown() && !fvRsDomAtt.PortAllocation.IsNull() {
				childMap["attributes"]["portAllocation"] = fvRsDomAtt.PortAllocation.ValueString()
			}
			if !fvRsDomAtt.PrimaryEncap.IsUnknown() && !fvRsDomAtt.PrimaryEncap.IsNull() {
				childMap["attributes"]["primaryEncap"] = fvRsDomAtt.PrimaryEncap.ValueString()
			}
			if !fvRsDomAtt.PrimaryEncapInner.IsUnknown() && !fvRsDomAtt.PrimaryEncapInner.IsNull() {
				childMap["attributes"]["primaryEncapInner"] = fvRsDomAtt.PrimaryEncapInner.ValueString()
			}
			if !fvRsDomAtt.ResImedcy.IsUnknown() && !fvRsDomAtt.ResImedcy.IsNull() {
				childMap["attributes"]["resImedcy"] = fvRsDomAtt.ResImedcy.ValueString()
			}
			if !fvRsDomAtt.SecondaryEncapInner.IsUnknown() && !fvRsDomAtt.SecondaryEncapInner.IsNull() {
				childMap["attributes"]["secondaryEncapInner"] = fvRsDomAtt.SecondaryEncapInner.ValueString()
			}
			if !fvRsDomAtt.SwitchingMode.IsUnknown() && !fvRsDomAtt.SwitchingMode.IsNull() {
				childMap["attributes"]["switchingMode"] = fvRsDomAtt.SwitchingMode.ValueString()
			}
			if !fvRsDomAtt.TDn.IsUnknown() && !fvRsDomAtt.TDn.IsNull() {
				childMap["attributes"]["tDn"] = fvRsDomAtt.TDn.ValueString()
			}
			if !fvRsDomAtt.Untagged.IsUnknown() && !fvRsDomAtt.Untagged.IsNull() {
				childMap["attributes"]["untagged"] = fvRsDomAtt.Untagged.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsDomAtt": childMap})
			fvRsDomAttIdentifier := FvRsDomAttIdentifier{}
			fvRsDomAttIdentifier.TDn = fvRsDomAtt.TDn
			fvRsDomAttIdentifiers = append(fvRsDomAttIdentifiers, fvRsDomAttIdentifier)
		}
		for _, fvRsDomAtt := range fvRsDomAttState {
			delete := true
			for _, fvRsDomAttIdentifier := range fvRsDomAttIdentifiers {
				if fvRsDomAttIdentifier.TDn == fvRsDomAtt.TDn {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tDn"] = fvRsDomAtt.TDn.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsDomAtt": childMap})
			}
		}
	} else {
		data.FvRsDomAtt = types.SetNull(data.FvRsDomAtt.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsDppPolChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsDppPolPlan, fvRsDppPolState FvRsDppPolFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsDppPol.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsDppPol.Attributes()) {
			if !fvRsDppPolPlan.Annotation.IsUnknown() && !fvRsDppPolPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsDppPolPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsDppPolPlan.TnQosDppPolName.IsUnknown() && !fvRsDppPolPlan.TnQosDppPolName.IsNull() {
				childMap["attributes"]["tnQosDppPolName"] = fvRsDppPolPlan.TnQosDppPolName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsDppPol": childMap})
	} else {
		FvRsDppPolObject, _ := types.ObjectValueFrom(ctx, FvRsDppPolFvAEPgType, getEmptyFvRsDppPolFvAEPgResourceModel())
		data.FvRsDppPol = FvRsDppPolObject
	}

	return childPayloads
}
func getFvAEPgFvRsFcPathAttChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsFcPathAttPlan, fvRsFcPathAttState []FvRsFcPathAttFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsFcPathAtt.IsUnknown() {
		fvRsFcPathAttIdentifiers := []FvRsFcPathAttIdentifier{}
		for _, fvRsFcPathAtt := range fvRsFcPathAttPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsFcPathAtt.Annotation.IsUnknown() && !fvRsFcPathAtt.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsFcPathAtt.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsFcPathAtt.Descr.IsUnknown() && !fvRsFcPathAtt.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvRsFcPathAtt.Descr.ValueString()
			}
			if !fvRsFcPathAtt.TDn.IsUnknown() && !fvRsFcPathAtt.TDn.IsNull() {
				childMap["attributes"]["tDn"] = fvRsFcPathAtt.TDn.ValueString()
			}
			if !fvRsFcPathAtt.Vsan.IsUnknown() && !fvRsFcPathAtt.Vsan.IsNull() {
				childMap["attributes"]["vsan"] = fvRsFcPathAtt.Vsan.ValueString()
			}
			if !fvRsFcPathAtt.VsanMode.IsUnknown() && !fvRsFcPathAtt.VsanMode.IsNull() {
				childMap["attributes"]["vsanMode"] = fvRsFcPathAtt.VsanMode.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsFcPathAtt": childMap})
			fvRsFcPathAttIdentifier := FvRsFcPathAttIdentifier{}
			fvRsFcPathAttIdentifier.TDn = fvRsFcPathAtt.TDn
			fvRsFcPathAttIdentifiers = append(fvRsFcPathAttIdentifiers, fvRsFcPathAttIdentifier)
		}
		for _, fvRsFcPathAtt := range fvRsFcPathAttState {
			delete := true
			for _, fvRsFcPathAttIdentifier := range fvRsFcPathAttIdentifiers {
				if fvRsFcPathAttIdentifier.TDn == fvRsFcPathAtt.TDn {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tDn"] = fvRsFcPathAtt.TDn.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsFcPathAtt": childMap})
			}
		}
	} else {
		data.FvRsFcPathAtt = types.SetNull(data.FvRsFcPathAtt.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsIntraEpgChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsIntraEpgPlan, fvRsIntraEpgState []FvRsIntraEpgFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsIntraEpg.IsUnknown() {
		fvRsIntraEpgIdentifiers := []FvRsIntraEpgIdentifier{}
		for _, fvRsIntraEpg := range fvRsIntraEpgPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsIntraEpg.Annotation.IsUnknown() && !fvRsIntraEpg.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsIntraEpg.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsIntraEpg.TnVzBrCPName.IsUnknown() && !fvRsIntraEpg.TnVzBrCPName.IsNull() {
				childMap["attributes"]["tnVzBrCPName"] = fvRsIntraEpg.TnVzBrCPName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsIntraEpg": childMap})
			fvRsIntraEpgIdentifier := FvRsIntraEpgIdentifier{}
			fvRsIntraEpgIdentifier.TnVzBrCPName = fvRsIntraEpg.TnVzBrCPName
			fvRsIntraEpgIdentifiers = append(fvRsIntraEpgIdentifiers, fvRsIntraEpgIdentifier)
		}
		for _, fvRsIntraEpg := range fvRsIntraEpgState {
			delete := true
			for _, fvRsIntraEpgIdentifier := range fvRsIntraEpgIdentifiers {
				if fvRsIntraEpgIdentifier.TnVzBrCPName == fvRsIntraEpg.TnVzBrCPName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnVzBrCPName"] = fvRsIntraEpg.TnVzBrCPName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsIntraEpg": childMap})
			}
		}
	} else {
		data.FvRsIntraEpg = types.SetNull(data.FvRsIntraEpg.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsNodeAttChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsNodeAttPlan, fvRsNodeAttState []FvRsNodeAttFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsNodeAtt.IsUnknown() {
		fvRsNodeAttIdentifiers := []FvRsNodeAttIdentifier{}
		for _, fvRsNodeAtt := range fvRsNodeAttPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsNodeAtt.Annotation.IsUnknown() && !fvRsNodeAtt.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsNodeAtt.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsNodeAtt.Descr.IsUnknown() && !fvRsNodeAtt.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvRsNodeAtt.Descr.ValueString()
			}
			if !fvRsNodeAtt.Encap.IsUnknown() && !fvRsNodeAtt.Encap.IsNull() {
				childMap["attributes"]["encap"] = fvRsNodeAtt.Encap.ValueString()
			}
			if !fvRsNodeAtt.InstrImedcy.IsUnknown() && !fvRsNodeAtt.InstrImedcy.IsNull() {
				childMap["attributes"]["instrImedcy"] = fvRsNodeAtt.InstrImedcy.ValueString()
			}
			if !fvRsNodeAtt.Mode.IsUnknown() && !fvRsNodeAtt.Mode.IsNull() {
				childMap["attributes"]["mode"] = fvRsNodeAtt.Mode.ValueString()
			}
			if !fvRsNodeAtt.TDn.IsUnknown() && !fvRsNodeAtt.TDn.IsNull() {
				childMap["attributes"]["tDn"] = fvRsNodeAtt.TDn.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsNodeAtt": childMap})
			fvRsNodeAttIdentifier := FvRsNodeAttIdentifier{}
			fvRsNodeAttIdentifier.TDn = fvRsNodeAtt.TDn
			fvRsNodeAttIdentifiers = append(fvRsNodeAttIdentifiers, fvRsNodeAttIdentifier)
		}
		for _, fvRsNodeAtt := range fvRsNodeAttState {
			delete := true
			for _, fvRsNodeAttIdentifier := range fvRsNodeAttIdentifiers {
				if fvRsNodeAttIdentifier.TDn == fvRsNodeAtt.TDn {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tDn"] = fvRsNodeAtt.TDn.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsNodeAtt": childMap})
			}
		}
	} else {
		data.FvRsNodeAtt = types.SetNull(data.FvRsNodeAtt.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsPathAttChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsPathAttPlan, fvRsPathAttState []FvRsPathAttFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsPathAtt.IsUnknown() {
		fvRsPathAttIdentifiers := []FvRsPathAttIdentifier{}
		for _, fvRsPathAtt := range fvRsPathAttPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsPathAtt.Annotation.IsUnknown() && !fvRsPathAtt.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsPathAtt.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsPathAtt.Descr.IsUnknown() && !fvRsPathAtt.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvRsPathAtt.Descr.ValueString()
			}
			if !fvRsPathAtt.Encap.IsUnknown() && !fvRsPathAtt.Encap.IsNull() {
				childMap["attributes"]["encap"] = fvRsPathAtt.Encap.ValueString()
			}
			if !fvRsPathAtt.InstrImedcy.IsUnknown() && !fvRsPathAtt.InstrImedcy.IsNull() {
				childMap["attributes"]["instrImedcy"] = fvRsPathAtt.InstrImedcy.ValueString()
			}
			if !fvRsPathAtt.Mode.IsUnknown() && !fvRsPathAtt.Mode.IsNull() {
				childMap["attributes"]["mode"] = fvRsPathAtt.Mode.ValueString()
			}
			if !fvRsPathAtt.PrimaryEncap.IsUnknown() && !fvRsPathAtt.PrimaryEncap.IsNull() {
				childMap["attributes"]["primaryEncap"] = fvRsPathAtt.PrimaryEncap.ValueString()
			}
			if !fvRsPathAtt.TDn.IsUnknown() && !fvRsPathAtt.TDn.IsNull() {
				childMap["attributes"]["tDn"] = fvRsPathAtt.TDn.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsPathAtt": childMap})
			fvRsPathAttIdentifier := FvRsPathAttIdentifier{}
			fvRsPathAttIdentifier.TDn = fvRsPathAtt.TDn
			fvRsPathAttIdentifiers = append(fvRsPathAttIdentifiers, fvRsPathAttIdentifier)
		}
		for _, fvRsPathAtt := range fvRsPathAttState {
			delete := true
			for _, fvRsPathAttIdentifier := range fvRsPathAttIdentifiers {
				if fvRsPathAttIdentifier.TDn == fvRsPathAtt.TDn {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tDn"] = fvRsPathAtt.TDn.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsPathAtt": childMap})
			}
		}
	} else {
		data.FvRsPathAtt = types.SetNull(data.FvRsPathAtt.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsProtByChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsProtByPlan, fvRsProtByState []FvRsProtByFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsProtBy.IsUnknown() {
		fvRsProtByIdentifiers := []FvRsProtByIdentifier{}
		for _, fvRsProtBy := range fvRsProtByPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsProtBy.Annotation.IsUnknown() && !fvRsProtBy.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsProtBy.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsProtBy.TnVzTabooName.IsUnknown() && !fvRsProtBy.TnVzTabooName.IsNull() {
				childMap["attributes"]["tnVzTabooName"] = fvRsProtBy.TnVzTabooName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsProtBy": childMap})
			fvRsProtByIdentifier := FvRsProtByIdentifier{}
			fvRsProtByIdentifier.TnVzTabooName = fvRsProtBy.TnVzTabooName
			fvRsProtByIdentifiers = append(fvRsProtByIdentifiers, fvRsProtByIdentifier)
		}
		for _, fvRsProtBy := range fvRsProtByState {
			delete := true
			for _, fvRsProtByIdentifier := range fvRsProtByIdentifiers {
				if fvRsProtByIdentifier.TnVzTabooName == fvRsProtBy.TnVzTabooName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnVzTabooName"] = fvRsProtBy.TnVzTabooName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsProtBy": childMap})
			}
		}
	} else {
		data.FvRsProtBy = types.SetNull(data.FvRsProtBy.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsProvChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsProvPlan, fvRsProvState []FvRsProvFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsProv.IsUnknown() {
		fvRsProvIdentifiers := []FvRsProvIdentifier{}
		for _, fvRsProv := range fvRsProvPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsProv.Annotation.IsUnknown() && !fvRsProv.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsProv.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsProv.MatchT.IsUnknown() && !fvRsProv.MatchT.IsNull() {
				childMap["attributes"]["matchT"] = fvRsProv.MatchT.ValueString()
			}
			if !fvRsProv.Prio.IsUnknown() && !fvRsProv.Prio.IsNull() {
				childMap["attributes"]["prio"] = fvRsProv.Prio.ValueString()
			}
			if !fvRsProv.TnVzBrCPName.IsUnknown() && !fvRsProv.TnVzBrCPName.IsNull() {
				childMap["attributes"]["tnVzBrCPName"] = fvRsProv.TnVzBrCPName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsProv": childMap})
			fvRsProvIdentifier := FvRsProvIdentifier{}
			fvRsProvIdentifier.TnVzBrCPName = fvRsProv.TnVzBrCPName
			fvRsProvIdentifiers = append(fvRsProvIdentifiers, fvRsProvIdentifier)
		}
		for _, fvRsProv := range fvRsProvState {
			delete := true
			for _, fvRsProvIdentifier := range fvRsProvIdentifiers {
				if fvRsProvIdentifier.TnVzBrCPName == fvRsProv.TnVzBrCPName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnVzBrCPName"] = fvRsProv.TnVzBrCPName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsProv": childMap})
			}
		}
	} else {
		data.FvRsProv = types.SetNull(data.FvRsProv.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsSecInheritedChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsSecInheritedPlan, fvRsSecInheritedState []FvRsSecInheritedFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsSecInherited.IsUnknown() {
		fvRsSecInheritedIdentifiers := []FvRsSecInheritedIdentifier{}
		for _, fvRsSecInherited := range fvRsSecInheritedPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsSecInherited.Annotation.IsUnknown() && !fvRsSecInherited.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsSecInherited.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsSecInherited.TDn.IsUnknown() && !fvRsSecInherited.TDn.IsNull() {
				childMap["attributes"]["tDn"] = fvRsSecInherited.TDn.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsSecInherited": childMap})
			fvRsSecInheritedIdentifier := FvRsSecInheritedIdentifier{}
			fvRsSecInheritedIdentifier.TDn = fvRsSecInherited.TDn
			fvRsSecInheritedIdentifiers = append(fvRsSecInheritedIdentifiers, fvRsSecInheritedIdentifier)
		}
		for _, fvRsSecInherited := range fvRsSecInheritedState {
			delete := true
			for _, fvRsSecInheritedIdentifier := range fvRsSecInheritedIdentifiers {
				if fvRsSecInheritedIdentifier.TDn == fvRsSecInherited.TDn {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tDn"] = fvRsSecInherited.TDn.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsSecInherited": childMap})
			}
		}
	} else {
		data.FvRsSecInherited = types.SetNull(data.FvRsSecInherited.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgFvRsTrustCtrlChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, fvRsTrustCtrlPlan, fvRsTrustCtrlState FvRsTrustCtrlFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsTrustCtrl.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsTrustCtrl.Attributes()) {
			if !fvRsTrustCtrlPlan.Annotation.IsUnknown() && !fvRsTrustCtrlPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsTrustCtrlPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsTrustCtrlPlan.TnFhsTrustCtrlPolName.IsUnknown() && !fvRsTrustCtrlPlan.TnFhsTrustCtrlPolName.IsNull() {
				childMap["attributes"]["tnFhsTrustCtrlPolName"] = fvRsTrustCtrlPlan.TnFhsTrustCtrlPolName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsTrustCtrl": childMap})
	} else {
		FvRsTrustCtrlObject, _ := types.ObjectValueFrom(ctx, FvRsTrustCtrlFvAEPgType, getEmptyFvRsTrustCtrlFvAEPgResourceModel())
		data.FvRsTrustCtrl = FvRsTrustCtrlObject
	}

	return childPayloads
}
func getFvAEPgTagAnnotationChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagAnnotation.IsUnknown() {
		tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
		for _, tagAnnotation := range tagAnnotationPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagAnnotation.Key.IsUnknown() && !tagAnnotation.Key.IsNull() {
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
			}
			if !tagAnnotation.Value.IsUnknown() && !tagAnnotation.Value.IsNull() {
				childMap["attributes"]["value"] = tagAnnotation.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			tagAnnotationIdentifier := TagAnnotationIdentifier{}
			tagAnnotationIdentifier.Key = tagAnnotation.Key
			tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
		}
		for _, tagAnnotation := range tagAnnotationState {
			delete := true
			for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
				if tagAnnotationIdentifier.Key == tagAnnotation.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			}
		}
	} else {
		data.TagAnnotation = types.SetNull(data.TagAnnotation.ElementType(ctx))
	}

	return childPayloads
}
func getFvAEPgTagTagChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvAEPgResourceModel, tagTagPlan, tagTagState []TagTagFvAEPgResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagTag.IsUnknown() {
		tagTagIdentifiers := []TagTagIdentifier{}
		for _, tagTag := range tagTagPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagTag.Key.IsUnknown() && !tagTag.Key.IsNull() {
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
			}
			if !tagTag.Value.IsUnknown() && !tagTag.Value.IsNull() {
				childMap["attributes"]["value"] = tagTag.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			tagTagIdentifier := TagTagIdentifier{}
			tagTagIdentifier.Key = tagTag.Key
			tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
		}
		for _, tagTag := range tagTagState {
			delete := true
			for _, tagTagIdentifier := range tagTagIdentifiers {
				if tagTagIdentifier.Key == tagTag.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			}
		}
	} else {
		data.TagTag = types.SetNull(data.TagTag.ElementType(ctx))
	}

	return childPayloads
}

func getFvAEPgCreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *FvAEPgResourceModel, fvCrtrnPlan, fvCrtrnState FvCrtrnFvAEPgResourceModel, fvRsAEPgMonPolPlan, fvRsAEPgMonPolState FvRsAEPgMonPolFvAEPgResourceModel, fvRsBdPlan, fvRsBdState FvRsBdFvAEPgResourceModel, fvRsConsPlan, fvRsConsState []FvRsConsFvAEPgResourceModel, fvRsConsIfPlan, fvRsConsIfState []FvRsConsIfFvAEPgResourceModel, fvRsCustQosPolPlan, fvRsCustQosPolState FvRsCustQosPolFvAEPgResourceModel, fvRsDomAttPlan, fvRsDomAttState []FvRsDomAttFvAEPgResourceModel, fvRsDppPolPlan, fvRsDppPolState FvRsDppPolFvAEPgResourceModel, fvRsFcPathAttPlan, fvRsFcPathAttState []FvRsFcPathAttFvAEPgResourceModel, fvRsIntraEpgPlan, fvRsIntraEpgState []FvRsIntraEpgFvAEPgResourceModel, fvRsNodeAttPlan, fvRsNodeAttState []FvRsNodeAttFvAEPgResourceModel, fvRsPathAttPlan, fvRsPathAttState []FvRsPathAttFvAEPgResourceModel, fvRsProtByPlan, fvRsProtByState []FvRsProtByFvAEPgResourceModel, fvRsProvPlan, fvRsProvState []FvRsProvFvAEPgResourceModel, fvRsSecInheritedPlan, fvRsSecInheritedState []FvRsSecInheritedFvAEPgResourceModel, fvRsTrustCtrlPlan, fvRsTrustCtrlState FvRsTrustCtrlFvAEPgResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvAEPgResourceModel, tagTagPlan, tagTagState []TagTagFvAEPgResourceModel) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}
	childPayloads := []map[string]interface{}{}

	FvCrtrnchildPayloads := getFvAEPgFvCrtrnChildPayloads(ctx, diags, data, fvCrtrnPlan, fvCrtrnState)
	if FvCrtrnchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvCrtrnchildPayloads...)

	FvRsAEPgMonPolchildPayloads := getFvAEPgFvRsAEPgMonPolChildPayloads(ctx, diags, data, fvRsAEPgMonPolPlan, fvRsAEPgMonPolState)
	if FvRsAEPgMonPolchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsAEPgMonPolchildPayloads...)

	FvRsBdchildPayloads := getFvAEPgFvRsBdChildPayloads(ctx, diags, data, fvRsBdPlan, fvRsBdState)
	if FvRsBdchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBdchildPayloads...)

	FvRsConschildPayloads := getFvAEPgFvRsConsChildPayloads(ctx, diags, data, fvRsConsPlan, fvRsConsState)
	if FvRsConschildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsConschildPayloads...)

	FvRsConsIfchildPayloads := getFvAEPgFvRsConsIfChildPayloads(ctx, diags, data, fvRsConsIfPlan, fvRsConsIfState)
	if FvRsConsIfchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsConsIfchildPayloads...)

	FvRsCustQosPolchildPayloads := getFvAEPgFvRsCustQosPolChildPayloads(ctx, diags, data, fvRsCustQosPolPlan, fvRsCustQosPolState)
	if FvRsCustQosPolchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsCustQosPolchildPayloads...)

	FvRsDomAttchildPayloads := getFvAEPgFvRsDomAttChildPayloads(ctx, diags, data, fvRsDomAttPlan, fvRsDomAttState)
	if FvRsDomAttchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsDomAttchildPayloads...)

	FvRsDppPolchildPayloads := getFvAEPgFvRsDppPolChildPayloads(ctx, diags, data, fvRsDppPolPlan, fvRsDppPolState)
	if FvRsDppPolchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsDppPolchildPayloads...)

	FvRsFcPathAttchildPayloads := getFvAEPgFvRsFcPathAttChildPayloads(ctx, diags, data, fvRsFcPathAttPlan, fvRsFcPathAttState)
	if FvRsFcPathAttchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsFcPathAttchildPayloads...)

	FvRsIntraEpgchildPayloads := getFvAEPgFvRsIntraEpgChildPayloads(ctx, diags, data, fvRsIntraEpgPlan, fvRsIntraEpgState)
	if FvRsIntraEpgchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsIntraEpgchildPayloads...)

	FvRsNodeAttchildPayloads := getFvAEPgFvRsNodeAttChildPayloads(ctx, diags, data, fvRsNodeAttPlan, fvRsNodeAttState)
	if FvRsNodeAttchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsNodeAttchildPayloads...)

	FvRsPathAttchildPayloads := getFvAEPgFvRsPathAttChildPayloads(ctx, diags, data, fvRsPathAttPlan, fvRsPathAttState)
	if FvRsPathAttchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsPathAttchildPayloads...)

	FvRsProtBychildPayloads := getFvAEPgFvRsProtByChildPayloads(ctx, diags, data, fvRsProtByPlan, fvRsProtByState)
	if FvRsProtBychildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsProtBychildPayloads...)

	FvRsProvchildPayloads := getFvAEPgFvRsProvChildPayloads(ctx, diags, data, fvRsProvPlan, fvRsProvState)
	if FvRsProvchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsProvchildPayloads...)

	FvRsSecInheritedchildPayloads := getFvAEPgFvRsSecInheritedChildPayloads(ctx, diags, data, fvRsSecInheritedPlan, fvRsSecInheritedState)
	if FvRsSecInheritedchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsSecInheritedchildPayloads...)

	FvRsTrustCtrlchildPayloads := getFvAEPgFvRsTrustCtrlChildPayloads(ctx, diags, data, fvRsTrustCtrlPlan, fvRsTrustCtrlState)
	if FvRsTrustCtrlchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsTrustCtrlchildPayloads...)

	TagAnnotationchildPayloads := getFvAEPgTagAnnotationChildPayloads(ctx, diags, data, tagAnnotationPlan, tagAnnotationState)
	if TagAnnotationchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagAnnotationchildPayloads...)

	TagTagchildPayloads := getFvAEPgTagTagChildPayloads(ctx, diags, data, tagTagPlan, tagTagState)
	if TagTagchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagTagchildPayloads...)

	payloadMap["children"] = childPayloads
	if !data.Annotation.IsNull() && !data.Annotation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["annotation"] = data.Annotation.ValueString()
	}
	if !data.Descr.IsNull() && !data.Descr.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["descr"] = data.Descr.ValueString()
	}
	if !data.ExceptionTag.IsNull() && !data.ExceptionTag.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["exceptionTag"] = data.ExceptionTag.ValueString()
	}
	if !data.FloodOnEncap.IsNull() && !data.FloodOnEncap.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["floodOnEncap"] = data.FloodOnEncap.ValueString()
	}
	if !data.FwdCtrl.IsNull() && !data.FwdCtrl.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["fwdCtrl"] = data.FwdCtrl.ValueString()
	}
	if !data.HasMcastSource.IsNull() && !data.HasMcastSource.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["hasMcastSource"] = data.HasMcastSource.ValueString()
	}
	if !data.IsAttrBasedEPg.IsNull() && !data.IsAttrBasedEPg.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["isAttrBasedEPg"] = data.IsAttrBasedEPg.ValueString()
	}
	if !data.MatchT.IsNull() && !data.MatchT.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["matchT"] = data.MatchT.ValueString()
	}
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["name"] = data.Name.ValueString()
	}
	if !data.NameAlias.IsNull() && !data.NameAlias.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["nameAlias"] = data.NameAlias.ValueString()
	}
	if !data.PcEnfPref.IsNull() && !data.PcEnfPref.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["pcEnfPref"] = data.PcEnfPref.ValueString()
	}
	if !data.PrefGrMemb.IsNull() && !data.PrefGrMemb.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["prefGrMemb"] = data.PrefGrMemb.ValueString()
	}
	if !data.Prio.IsNull() && !data.Prio.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["prio"] = data.Prio.ValueString()
	}
	if !data.Shutdown.IsNull() && !data.Shutdown.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["shutdown"] = data.Shutdown.ValueString()
	}
	payload, err := json.Marshal(map[string]interface{}{"fvAEPg": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
