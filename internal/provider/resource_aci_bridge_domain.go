// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &FvBDResource{}
var _ resource.ResourceWithImportState = &FvBDResource{}

func NewFvBDResource() resource.Resource {
	return &FvBDResource{}
}

// FvBDResource defines the resource implementation.
type FvBDResource struct {
	client *client.Client
}

// FvBDResourceModel describes the resource data model.
type FvBDResourceModel struct {
	Id                                    types.String `tfsdk:"id"`
	ParentDn                              types.String `tfsdk:"parent_dn"`
	OptimizeWanBandwidth                  types.String `tfsdk:"optimize_wan_bandwidth"`
	Annotation                            types.String `tfsdk:"annotation"`
	ArpFlood                              types.String `tfsdk:"arp_flooding"`
	Descr                                 types.String `tfsdk:"description"`
	EnableRogueExceptMac                  types.String `tfsdk:"enable_rogue_exception_mac"`
	EpClear                               types.String `tfsdk:"clear_remote_mac_entries"`
	EpMoveDetectMode                      types.String `tfsdk:"endpoint_move_detection_mode"`
	HostBasedRouting                      types.String `tfsdk:"advertise_host_routes"`
	IntersiteBumTrafficAllow              types.String `tfsdk:"intersite_bum_traffic_allow"`
	IntersiteL2Stretch                    types.String `tfsdk:"intersite_l2_stretch"`
	IpLearning                            types.String `tfsdk:"ip_learning"`
	Ipv6McastAllow                        types.String `tfsdk:"pim_ipv6"`
	LimitIpLearnToSubnets                 types.String `tfsdk:"limit_ip_learn_to_subnets"`
	LlAddr                                types.String `tfsdk:"link_local_ipv6_address"`
	Mac                                   types.String `tfsdk:"custom_mac_address"`
	McastARPDrop                          types.String `tfsdk:"drop_arp_with_multicast_smac"`
	McastAllow                            types.String `tfsdk:"pim"`
	MultiDstPktAct                        types.String `tfsdk:"multi_destination_flooding"`
	Name                                  types.String `tfsdk:"name"`
	NameAlias                             types.String `tfsdk:"name_alias"`
	OwnerKey                              types.String `tfsdk:"owner_key"`
	OwnerTag                              types.String `tfsdk:"owner_tag"`
	Type                                  types.String `tfsdk:"bridge_domain_type"`
	UnicastRoute                          types.String `tfsdk:"unicast_routing"`
	UnkMacUcastAct                        types.String `tfsdk:"l2_unknown_unicast_flooding"`
	UnkMcastAct                           types.String `tfsdk:"l3_unknown_multicast_flooding"`
	V6unkMcastAct                         types.String `tfsdk:"ipv6_l3_unknown_multicast_flooding"`
	Vmac                                  types.String `tfsdk:"virtual_mac_address"`
	FvAccP                                types.Object `tfsdk:"legacy_mode"`
	FvRogueExceptionMac                   types.Set    `tfsdk:"rogue_coop_exceptions"`
	FvRsABDPolMonPol                      types.Object `tfsdk:"relation_to_monitor_policy"`
	FvRsBDToFhs                           types.Object `tfsdk:"relation_to_first_hop_security_policy"`
	FvRsBDToNdP                           types.Object `tfsdk:"relation_to_neighbor_discovery_interface_policy"`
	FvRsBDToNetflowMonitorPol             types.Set    `tfsdk:"relation_to_netflow_monitor_policies"`
	FvRsBDToOut                           types.Set    `tfsdk:"relation_to_l3_outsides"`
	FvRsBDToProfile                       types.Object `tfsdk:"relation_to_route_control_profile"`
	FvRsBDToRelayP                        types.Object `tfsdk:"relation_to_dhcp_relay_policy"`
	FvRsBdToEpRet                         types.Object `tfsdk:"relation_to_end_point_retention_policy"`
	FvRsCtx                               types.Object `tfsdk:"relation_to_vrf"`
	FvRsIgmpsn                            types.Object `tfsdk:"relation_to_igmp_snooping_policy"`
	FvRsMldsn                             types.Object `tfsdk:"relation_to_mld_snooping_policy"`
	TagAnnotation                         types.Set    `tfsdk:"annotations"`
	TagTag                                types.Set    `tfsdk:"tags"`
	DeprecatedArpFlood                    types.String `tfsdk:"arp_flood"`
	DeprecatedEpClear                     types.String `tfsdk:"ep_clear"`
	DeprecatedEpMoveDetectMode            types.String `tfsdk:"ep_move_detect_mode"`
	DeprecatedHostBasedRouting            types.String `tfsdk:"host_based_routing"`
	DeprecatedIpv6McastAllow              types.String `tfsdk:"ipv6_mcast_allow"`
	DeprecatedLlAddr                      types.String `tfsdk:"ll_addr"`
	DeprecatedMac                         types.String `tfsdk:"mac"`
	DeprecatedMcastAllow                  types.String `tfsdk:"mcast_allow"`
	DeprecatedMultiDstPktAct              types.String `tfsdk:"multi_dst_pkt_act"`
	DeprecatedParentDn                    types.String `tfsdk:"tenant_dn"`
	DeprecatedUnicastRoute                types.String `tfsdk:"unicast_route"`
	DeprecatedUnkMacUcastAct              types.String `tfsdk:"unk_mac_ucast_act"`
	DeprecatedUnkMcastAct                 types.String `tfsdk:"unk_mcast_act"`
	DeprecatedV6unkMcastAct               types.String `tfsdk:"v6unk_mcast_act"`
	DeprecatedVmac                        types.String `tfsdk:"vmac"`
	Deprecated_relation_fv_rs_bd_flood_to types.Set    `tfsdk:"relation_fv_rs_bd_flood_to"`
	DeprecatedFvRsBdToEpRet               types.String `tfsdk:"relation_fv_rs_bd_to_ep_ret"`
	DeprecatedFvRsBDToFhs                 types.String `tfsdk:"relation_fv_rs_bd_to_fhs"`
	DeprecatedFvRsIgmpsn                  types.String `tfsdk:"relation_fv_rs_igmpsn"`
	DeprecatedFvRsBDToOut                 types.Set    `tfsdk:"relation_fv_rs_bd_to_out"`
	DeprecatedFvRsMldsn                   types.String `tfsdk:"relation_fv_rs_mldsn"`
	DeprecatedFvRsABDPolMonPol            types.String `tfsdk:"relation_fv_rs_abd_pol_mon_pol"`
	DeprecatedFvRsBDToNdP                 types.String `tfsdk:"relation_fv_rs_bd_to_nd_p"`
	DeprecatedFvRsBDToRelayP              types.String `tfsdk:"relation_fv_rs_bd_to_relay_p"`
	DeprecatedFvRsBDToProfile             types.String `tfsdk:"relation_fv_rs_bd_to_profile"`
	DeprecatedFvRsCtx                     types.String `tfsdk:"relation_fv_rs_ctx"`
	DeprecatedFvRsBDToNetflowMonitorPol   types.Set    `tfsdk:"relation_fv_rs_bd_to_netflow_monitor_pol"`
}

func getEmptyFvBDResourceModel() *FvBDResourceModel {
	return &FvBDResourceModel{
		Id:                       basetypes.NewStringNull(),
		ParentDn:                 basetypes.NewStringNull(),
		OptimizeWanBandwidth:     basetypes.NewStringNull(),
		Annotation:               basetypes.NewStringNull(),
		ArpFlood:                 basetypes.NewStringNull(),
		Descr:                    basetypes.NewStringNull(),
		EnableRogueExceptMac:     basetypes.NewStringNull(),
		EpClear:                  basetypes.NewStringNull(),
		EpMoveDetectMode:         basetypes.NewStringNull(),
		HostBasedRouting:         basetypes.NewStringNull(),
		IntersiteBumTrafficAllow: basetypes.NewStringNull(),
		IntersiteL2Stretch:       basetypes.NewStringNull(),
		IpLearning:               basetypes.NewStringNull(),
		Ipv6McastAllow:           basetypes.NewStringNull(),
		LimitIpLearnToSubnets:    basetypes.NewStringNull(),
		LlAddr:                   basetypes.NewStringNull(),
		Mac:                      basetypes.NewStringNull(),
		McastARPDrop:             basetypes.NewStringNull(),
		McastAllow:               basetypes.NewStringNull(),
		MultiDstPktAct:           basetypes.NewStringNull(),
		Name:                     basetypes.NewStringNull(),
		NameAlias:                basetypes.NewStringNull(),
		OwnerKey:                 basetypes.NewStringNull(),
		OwnerTag:                 basetypes.NewStringNull(),
		Type:                     basetypes.NewStringNull(),
		UnicastRoute:             basetypes.NewStringNull(),
		UnkMacUcastAct:           basetypes.NewStringNull(),
		UnkMcastAct:              basetypes.NewStringNull(),
		V6unkMcastAct:            basetypes.NewStringNull(),
		Vmac:                     basetypes.NewStringNull(),
		FvAccP: types.ObjectNull(map[string]attr.Type{
			"annotation":    types.StringType,
			"description":   types.StringType,
			"encapsulation": types.StringType,
			"name":          types.StringType,
			"name_alias":    types.StringType,
			"owner_key":     types.StringType,
			"owner_tag":     types.StringType,
		}),
		FvRogueExceptionMac: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":  types.StringType,
				"description": types.StringType,
				"mac":         types.StringType,
				"name":        types.StringType,
				"name_alias":  types.StringType,
			},
		}),
		FvRsABDPolMonPol: types.ObjectNull(map[string]attr.Type{
			"annotation":             types.StringType,
			"monitoring_policy_name": types.StringType,
		}),
		FvRsBDToFhs: types.ObjectNull(map[string]attr.Type{
			"annotation":                     types.StringType,
			"first_hop_security_policy_name": types.StringType,
		}),
		FvRsBDToNdP: types.ObjectNull(map[string]attr.Type{
			"annotation": types.StringType,
			"neighbor_discovery_interface_policy_name": types.StringType,
		}),
		FvRsBDToNetflowMonitorPol: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":                  types.StringType,
				"filter_type":                 types.StringType,
				"netflow_monitor_policy_name": types.StringType,
			},
		}),
		FvRsBDToOut: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"annotation":      types.StringType,
				"l3_outside_name": types.StringType,
			},
		}),
		FvRsBDToProfile: types.ObjectNull(map[string]attr.Type{
			"annotation":                 types.StringType,
			"l3_outside_name":            types.StringType,
			"route_control_profile_name": types.StringType,
		}),
		FvRsBDToRelayP: types.ObjectNull(map[string]attr.Type{
			"annotation":             types.StringType,
			"dhcp_relay_policy_name": types.StringType,
		}),
		FvRsBdToEpRet: types.ObjectNull(map[string]attr.Type{
			"annotation":                      types.StringType,
			"resolve_action":                  types.StringType,
			"end_point_retention_policy_name": types.StringType,
		}),
		FvRsCtx: types.ObjectNull(map[string]attr.Type{
			"annotation": types.StringType,
			"vrf_name":   types.StringType,
		}),
		FvRsIgmpsn: types.ObjectNull(map[string]attr.Type{
			"annotation":                types.StringType,
			"igmp_snooping_policy_name": types.StringType,
		}),
		FvRsMldsn: types.ObjectNull(map[string]attr.Type{
			"annotation":               types.StringType,
			"mld_snooping_policy_name": types.StringType,
		}),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		DeprecatedArpFlood:                    types.String{},
		DeprecatedEpClear:                     types.String{},
		DeprecatedEpMoveDetectMode:            types.String{},
		DeprecatedHostBasedRouting:            types.String{},
		DeprecatedIpv6McastAllow:              types.String{},
		DeprecatedLlAddr:                      types.String{},
		DeprecatedMac:                         types.String{},
		DeprecatedMcastAllow:                  types.String{},
		DeprecatedMultiDstPktAct:              types.String{},
		DeprecatedParentDn:                    types.String{},
		DeprecatedUnicastRoute:                types.String{},
		DeprecatedUnkMacUcastAct:              types.String{},
		DeprecatedUnkMcastAct:                 types.String{},
		DeprecatedV6unkMcastAct:               types.String{},
		DeprecatedVmac:                        types.String{},
		Deprecated_relation_fv_rs_bd_flood_to: types.SetNull(types.StringType),
		DeprecatedFvRsBdToEpRet:               types.String{},
		DeprecatedFvRsBDToFhs:                 types.String{},
		DeprecatedFvRsIgmpsn:                  types.String{},
		DeprecatedFvRsBDToOut:                 types.SetNull(types.StringType),
		DeprecatedFvRsMldsn:                   types.String{},
		DeprecatedFvRsABDPolMonPol:            types.String{},
		DeprecatedFvRsBDToNdP:                 types.String{},
		DeprecatedFvRsBDToRelayP:              types.String{},
		DeprecatedFvRsBDToProfile:             types.String{},
		DeprecatedFvRsCtx:                     types.String{},
		DeprecatedFvRsBDToNetflowMonitorPol:   types.SetNull(deprecatedFvRsBDToNetflowMonitorPolType),
	}
}

// FvAccPFvBDResourceModel describes the resource data model for the children without relation ships.
type FvAccPFvBDResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	Descr      types.String `tfsdk:"description"`
	Encap      types.String `tfsdk:"encapsulation"`
	Name       types.String `tfsdk:"name"`
	NameAlias  types.String `tfsdk:"name_alias"`
	OwnerKey   types.String `tfsdk:"owner_key"`
	OwnerTag   types.String `tfsdk:"owner_tag"`
}

func getEmptyFvAccPFvBDResourceModel() FvAccPFvBDResourceModel {
	return FvAccPFvBDResourceModel{
		Annotation: basetypes.NewStringNull(),
		Descr:      basetypes.NewStringNull(),
		Encap:      basetypes.NewStringNull(),
		Name:       basetypes.NewStringNull(),
		NameAlias:  basetypes.NewStringNull(),
		OwnerKey:   basetypes.NewStringNull(),
		OwnerTag:   basetypes.NewStringNull(),
	}
}

var FvAccPFvBDType = map[string]attr.Type{
	"annotation":    types.StringType,
	"description":   types.StringType,
	"encapsulation": types.StringType,
	"name":          types.StringType,
	"name_alias":    types.StringType,
	"owner_key":     types.StringType,
	"owner_tag":     types.StringType,
}

// FvRogueExceptionMacFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRogueExceptionMacFvBDResourceModel struct {
	Annotation types.String `tfsdk:"annotation"`
	Descr      types.String `tfsdk:"description"`
	Mac        types.String `tfsdk:"mac"`
	Name       types.String `tfsdk:"name"`
	NameAlias  types.String `tfsdk:"name_alias"`
}

func getEmptyFvRogueExceptionMacFvBDResourceModel() FvRogueExceptionMacFvBDResourceModel {
	return FvRogueExceptionMacFvBDResourceModel{
		Annotation: basetypes.NewStringNull(),
		Descr:      basetypes.NewStringNull(),
		Mac:        basetypes.NewStringNull(),
		Name:       basetypes.NewStringNull(),
		NameAlias:  basetypes.NewStringNull(),
	}
}

// FvRsABDPolMonPolFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsABDPolMonPolFvBDResourceModel struct {
	Annotation      types.String `tfsdk:"annotation"`
	TnMonEPGPolName types.String `tfsdk:"monitoring_policy_name"`
}

func getEmptyFvRsABDPolMonPolFvBDResourceModel() FvRsABDPolMonPolFvBDResourceModel {
	return FvRsABDPolMonPolFvBDResourceModel{
		Annotation:      basetypes.NewStringNull(),
		TnMonEPGPolName: basetypes.NewStringNull(),
	}
}

var FvRsABDPolMonPolFvBDType = map[string]attr.Type{
	"annotation":             types.StringType,
	"monitoring_policy_name": types.StringType,
}

// FvRsBDToFhsFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToFhsFvBDResourceModel struct {
	Annotation     types.String `tfsdk:"annotation"`
	TnFhsBDPolName types.String `tfsdk:"first_hop_security_policy_name"`
}

func getEmptyFvRsBDToFhsFvBDResourceModel() FvRsBDToFhsFvBDResourceModel {
	return FvRsBDToFhsFvBDResourceModel{
		Annotation:     basetypes.NewStringNull(),
		TnFhsBDPolName: basetypes.NewStringNull(),
	}
}

var FvRsBDToFhsFvBDType = map[string]attr.Type{
	"annotation":                     types.StringType,
	"first_hop_security_policy_name": types.StringType,
}

// FvRsBDToNdPFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToNdPFvBDResourceModel struct {
	Annotation    types.String `tfsdk:"annotation"`
	TnNdIfPolName types.String `tfsdk:"neighbor_discovery_interface_policy_name"`
}

func getEmptyFvRsBDToNdPFvBDResourceModel() FvRsBDToNdPFvBDResourceModel {
	return FvRsBDToNdPFvBDResourceModel{
		Annotation:    basetypes.NewStringNull(),
		TnNdIfPolName: basetypes.NewStringNull(),
	}
}

var FvRsBDToNdPFvBDType = map[string]attr.Type{
	"annotation": types.StringType,
	"neighbor_discovery_interface_policy_name": types.StringType,
}

// FvRsBDToNetflowMonitorPolFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToNetflowMonitorPolFvBDResourceModel struct {
	Annotation              types.String `tfsdk:"annotation"`
	FltType                 types.String `tfsdk:"filter_type"`
	TnNetflowMonitorPolName types.String `tfsdk:"netflow_monitor_policy_name"`
}

func getEmptyFvRsBDToNetflowMonitorPolFvBDResourceModel() FvRsBDToNetflowMonitorPolFvBDResourceModel {
	return FvRsBDToNetflowMonitorPolFvBDResourceModel{
		Annotation:              basetypes.NewStringNull(),
		FltType:                 basetypes.NewStringNull(),
		TnNetflowMonitorPolName: basetypes.NewStringNull(),
	}
}

// FvRsBDToOutFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToOutFvBDResourceModel struct {
	Annotation     types.String `tfsdk:"annotation"`
	TnL3extOutName types.String `tfsdk:"l3_outside_name"`
}

func getEmptyFvRsBDToOutFvBDResourceModel() FvRsBDToOutFvBDResourceModel {
	return FvRsBDToOutFvBDResourceModel{
		Annotation:     basetypes.NewStringNull(),
		TnL3extOutName: basetypes.NewStringNull(),
	}
}

// FvRsBDToProfileFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToProfileFvBDResourceModel struct {
	Annotation          types.String `tfsdk:"annotation"`
	TnL3extOutName      types.String `tfsdk:"l3_outside_name"`
	TnRtctrlProfileName types.String `tfsdk:"route_control_profile_name"`
}

func getEmptyFvRsBDToProfileFvBDResourceModel() FvRsBDToProfileFvBDResourceModel {
	return FvRsBDToProfileFvBDResourceModel{
		Annotation:          basetypes.NewStringNull(),
		TnL3extOutName:      basetypes.NewStringNull(),
		TnRtctrlProfileName: basetypes.NewStringNull(),
	}
}

var FvRsBDToProfileFvBDType = map[string]attr.Type{
	"annotation":                 types.StringType,
	"l3_outside_name":            types.StringType,
	"route_control_profile_name": types.StringType,
}

// FvRsBDToRelayPFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBDToRelayPFvBDResourceModel struct {
	Annotation       types.String `tfsdk:"annotation"`
	TnDhcpRelayPName types.String `tfsdk:"dhcp_relay_policy_name"`
}

func getEmptyFvRsBDToRelayPFvBDResourceModel() FvRsBDToRelayPFvBDResourceModel {
	return FvRsBDToRelayPFvBDResourceModel{
		Annotation:       basetypes.NewStringNull(),
		TnDhcpRelayPName: basetypes.NewStringNull(),
	}
}

var FvRsBDToRelayPFvBDType = map[string]attr.Type{
	"annotation":             types.StringType,
	"dhcp_relay_policy_name": types.StringType,
}

// FvRsBdToEpRetFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsBdToEpRetFvBDResourceModel struct {
	Annotation       types.String `tfsdk:"annotation"`
	ResolveAct       types.String `tfsdk:"resolve_action"`
	TnFvEpRetPolName types.String `tfsdk:"end_point_retention_policy_name"`
}

func getEmptyFvRsBdToEpRetFvBDResourceModel() FvRsBdToEpRetFvBDResourceModel {
	return FvRsBdToEpRetFvBDResourceModel{
		Annotation:       basetypes.NewStringNull(),
		ResolveAct:       basetypes.NewStringNull(),
		TnFvEpRetPolName: basetypes.NewStringNull(),
	}
}

var FvRsBdToEpRetFvBDType = map[string]attr.Type{
	"annotation":                      types.StringType,
	"resolve_action":                  types.StringType,
	"end_point_retention_policy_name": types.StringType,
}

// FvRsCtxFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsCtxFvBDResourceModel struct {
	Annotation  types.String `tfsdk:"annotation"`
	TnFvCtxName types.String `tfsdk:"vrf_name"`
}

func getEmptyFvRsCtxFvBDResourceModel() FvRsCtxFvBDResourceModel {
	return FvRsCtxFvBDResourceModel{
		Annotation:  basetypes.NewStringNull(),
		TnFvCtxName: basetypes.NewStringNull(),
	}
}

var FvRsCtxFvBDType = map[string]attr.Type{
	"annotation": types.StringType,
	"vrf_name":   types.StringType,
}

// FvRsIgmpsnFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsIgmpsnFvBDResourceModel struct {
	Annotation         types.String `tfsdk:"annotation"`
	TnIgmpSnoopPolName types.String `tfsdk:"igmp_snooping_policy_name"`
}

func getEmptyFvRsIgmpsnFvBDResourceModel() FvRsIgmpsnFvBDResourceModel {
	return FvRsIgmpsnFvBDResourceModel{
		Annotation:         basetypes.NewStringNull(),
		TnIgmpSnoopPolName: basetypes.NewStringNull(),
	}
}

var FvRsIgmpsnFvBDType = map[string]attr.Type{
	"annotation":                types.StringType,
	"igmp_snooping_policy_name": types.StringType,
}

// FvRsMldsnFvBDResourceModel describes the resource data model for the children without relation ships.
type FvRsMldsnFvBDResourceModel struct {
	Annotation        types.String `tfsdk:"annotation"`
	TnMldSnoopPolName types.String `tfsdk:"mld_snooping_policy_name"`
}

func getEmptyFvRsMldsnFvBDResourceModel() FvRsMldsnFvBDResourceModel {
	return FvRsMldsnFvBDResourceModel{
		Annotation:        basetypes.NewStringNull(),
		TnMldSnoopPolName: basetypes.NewStringNull(),
	}
}

var FvRsMldsnFvBDType = map[string]attr.Type{
	"annotation":               types.StringType,
	"mld_snooping_policy_name": types.StringType,
}

// TagAnnotationFvBDResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationFvBDResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationFvBDResourceModel() TagAnnotationFvBDResourceModel {
	return TagAnnotationFvBDResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

// TagTagFvBDResourceModel describes the resource data model for the children without relation ships.
type TagTagFvBDResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagFvBDResourceModel() TagTagFvBDResourceModel {
	return TagTagFvBDResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

type FvBDIdentifier struct {
	Name types.String
}

var deprecatedFvRsBDToNetflowMonitorPolType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"flt_type":                    basetypes.StringType{},
		"tn_netflow_monitor_pol_name": basetypes.StringType{},
	},
}

type FvBDResourceModelV1 struct {
	Annotation                            types.String `tfsdk:"annotation"`
	ArpFlood                              types.String `tfsdk:"arp_flood"`
	Descr                                 types.String `tfsdk:"description"`
	EpClear                               types.String `tfsdk:"ep_clear"`
	EpMoveDetectMode                      types.String `tfsdk:"ep_move_detect_mode"`
	HostBasedRouting                      types.String `tfsdk:"host_based_routing"`
	Id                                    types.String `tfsdk:"id"`
	IntersiteBumTrafficAllow              types.String `tfsdk:"intersite_bum_traffic_allow"`
	IntersiteL2Stretch                    types.String `tfsdk:"intersite_l2_stretch"`
	IpLearning                            types.String `tfsdk:"ip_learning"`
	Ipv6McastAllow                        types.String `tfsdk:"ipv6_mcast_allow"`
	LimitIpLearnToSubnets                 types.String `tfsdk:"limit_ip_learn_to_subnets"`
	LlAddr                                types.String `tfsdk:"ll_addr"`
	Mac                                   types.String `tfsdk:"mac"`
	McastAllow                            types.String `tfsdk:"mcast_allow"`
	MultiDstPktAct                        types.String `tfsdk:"multi_dst_pkt_act"`
	Name                                  types.String `tfsdk:"name"`
	NameAlias                             types.String `tfsdk:"name_alias"`
	OptimizeWanBandwidth                  types.String `tfsdk:"optimize_wan_bandwidth"`
	ParentDn                              types.String `tfsdk:"tenant_dn"`
	Type                                  types.String `tfsdk:"bridge_domain_type"`
	UnicastRoute                          types.String `tfsdk:"unicast_route"`
	UnkMacUcastAct                        types.String `tfsdk:"unk_mac_ucast_act"`
	UnkMcastAct                           types.String `tfsdk:"unk_mcast_act"`
	V6unkMcastAct                         types.String `tfsdk:"v6unk_mcast_act"`
	Vmac                                  types.String `tfsdk:"vmac"`
	Deprecated_relation_fv_rs_bd_flood_to types.Set    `tfsdk:"relation_fv_rs_bd_flood_to"`
	FvRsBdToEpRet                         types.String `tfsdk:"relation_fv_rs_bd_to_ep_ret"`
	FvRsBDToFhs                           types.String `tfsdk:"relation_fv_rs_bd_to_fhs"`
	FvRsIgmpsn                            types.String `tfsdk:"relation_fv_rs_igmpsn"`
	FvRsBDToOut                           types.Set    `tfsdk:"relation_fv_rs_bd_to_out"`
	FvRsMldsn                             types.String `tfsdk:"relation_fv_rs_mldsn"`
	FvRsABDPolMonPol                      types.String `tfsdk:"relation_fv_rs_abd_pol_mon_pol"`
	FvRsBDToNdP                           types.String `tfsdk:"relation_fv_rs_bd_to_nd_p"`
	FvRsBDToRelayP                        types.String `tfsdk:"relation_fv_rs_bd_to_relay_p"`
	FvRsBDToProfile                       types.String `tfsdk:"relation_fv_rs_bd_to_profile"`
	FvRsCtx                               types.String `tfsdk:"relation_fv_rs_ctx"`
	FvRsBDToNetflowMonitorPol             types.Set    `tfsdk:"relation_fv_rs_bd_to_netflow_monitor_pol"`
}

type FvRsBDToNetflowMonitorPolFvBDResourceModelV1 struct {
	FltType                 types.String `tfsdk:"flt_type"`
	TnNetflowMonitorPolName types.String `tfsdk:"tn_netflow_monitor_pol_name"`
}

func (r *FvBDResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		1: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"arp_flood": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"description": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"ep_clear": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"ep_move_detect_mode": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"host_based_routing": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"id": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"intersite_bum_traffic_allow": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"intersite_l2_stretch": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"ip_learning": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"ipv6_mcast_allow": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"limit_ip_learn_to_subnets": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"ll_addr": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"mac": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"mcast_allow": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"multi_dst_pkt_act": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Optional: false,
						Computed: false,
					},
					"name_alias": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"optimize_wan_bandwidth": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"tenant_dn": schema.StringAttribute{
						Required: true,
						Optional: false,
						Computed: false,
					},
					"bridge_domain_type": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"unicast_route": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"unk_mac_ucast_act": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"unk_mcast_act": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"v6unk_mcast_act": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"vmac": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_bd_flood_to": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_bd_to_ep_ret": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_bd_to_fhs": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_igmpsn": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_bd_to_out": schema.SetAttribute{
						Required:    false,
						Optional:    true,
						Computed:    false,
						ElementType: types.StringType,
					},
					"relation_fv_rs_mldsn": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_abd_pol_mon_pol": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_bd_to_nd_p": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					"relation_fv_rs_bd_to_relay_p": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_bd_to_profile": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: false,
					},
					"relation_fv_rs_ctx": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
				},
				Blocks: map[string]schema.Block{
					"relation_fv_rs_bd_to_netflow_monitor_pol": schema.SetNestedBlock{
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"flt_type": schema.StringAttribute{
									Required: true,
									Optional: false,
									Computed: false,
								},
								"tn_netflow_monitor_pol_name": schema.StringAttribute{
									Required: true,
									Optional: false,
									Computed: false,
								},
							},
						},
					},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData FvBDResourceModelV1

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := FvBDResourceModel{
					Id:                                    priorStateData.Id,
					ParentDn:                              priorStateData.ParentDn,
					OptimizeWanBandwidth:                  priorStateData.OptimizeWanBandwidth,
					Annotation:                            priorStateData.Annotation,
					ArpFlood:                              priorStateData.ArpFlood,
					Descr:                                 priorStateData.Descr,
					EnableRogueExceptMac:                  basetypes.NewStringNull(),
					EpClear:                               priorStateData.EpClear,
					EpMoveDetectMode:                      priorStateData.EpMoveDetectMode,
					HostBasedRouting:                      priorStateData.HostBasedRouting,
					IntersiteBumTrafficAllow:              priorStateData.IntersiteBumTrafficAllow,
					IntersiteL2Stretch:                    priorStateData.IntersiteL2Stretch,
					IpLearning:                            priorStateData.IpLearning,
					Ipv6McastAllow:                        priorStateData.Ipv6McastAllow,
					LimitIpLearnToSubnets:                 priorStateData.LimitIpLearnToSubnets,
					LlAddr:                                priorStateData.LlAddr,
					Mac:                                   priorStateData.Mac,
					McastARPDrop:                          basetypes.NewStringNull(),
					McastAllow:                            priorStateData.McastAllow,
					MultiDstPktAct:                        priorStateData.MultiDstPktAct,
					Name:                                  priorStateData.Name,
					NameAlias:                             priorStateData.NameAlias,
					OwnerKey:                              basetypes.NewStringNull(),
					OwnerTag:                              basetypes.NewStringNull(),
					Type:                                  priorStateData.Type,
					UnicastRoute:                          priorStateData.UnicastRoute,
					UnkMacUcastAct:                        priorStateData.UnkMacUcastAct,
					UnkMcastAct:                           priorStateData.UnkMcastAct,
					V6unkMcastAct:                         priorStateData.V6unkMcastAct,
					Vmac:                                  priorStateData.Vmac,
					DeprecatedArpFlood:                    priorStateData.ArpFlood,
					DeprecatedEpClear:                     priorStateData.EpClear,
					DeprecatedEpMoveDetectMode:            priorStateData.EpMoveDetectMode,
					DeprecatedHostBasedRouting:            priorStateData.HostBasedRouting,
					DeprecatedIpv6McastAllow:              priorStateData.Ipv6McastAllow,
					DeprecatedLlAddr:                      priorStateData.LlAddr,
					DeprecatedMac:                         priorStateData.Mac,
					DeprecatedMcastAllow:                  priorStateData.McastAllow,
					DeprecatedMultiDstPktAct:              priorStateData.MultiDstPktAct,
					DeprecatedParentDn:                    priorStateData.ParentDn,
					DeprecatedUnicastRoute:                priorStateData.UnicastRoute,
					DeprecatedUnkMacUcastAct:              priorStateData.UnkMacUcastAct,
					DeprecatedUnkMcastAct:                 priorStateData.UnkMcastAct,
					DeprecatedV6unkMcastAct:               priorStateData.V6unkMcastAct,
					DeprecatedVmac:                        priorStateData.Vmac,
					Deprecated_relation_fv_rs_bd_flood_to: priorStateData.Deprecated_relation_fv_rs_bd_flood_to,
					DeprecatedFvRsBdToEpRet:               priorStateData.FvRsBdToEpRet,
					DeprecatedFvRsBDToFhs:                 priorStateData.FvRsBDToFhs,
					DeprecatedFvRsIgmpsn:                  priorStateData.FvRsIgmpsn,
					DeprecatedFvRsMldsn:                   priorStateData.FvRsMldsn,
					DeprecatedFvRsABDPolMonPol:            priorStateData.FvRsABDPolMonPol,
					DeprecatedFvRsBDToNdP:                 priorStateData.FvRsBDToNdP,
					DeprecatedFvRsBDToRelayP:              priorStateData.FvRsBDToRelayP,
					DeprecatedFvRsBDToProfile:             priorStateData.FvRsBDToProfile,
					DeprecatedFvRsCtx:                     priorStateData.FvRsCtx,
				}

				upgradedStateData.FvAccP = types.ObjectNull(FvAccPFvBDType)

				upgradedStateData.FvRogueExceptionMac = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"annotation":  basetypes.StringType{},
							"description": basetypes.StringType{},
							"mac":         basetypes.StringType{},
							"name":        basetypes.StringType{},
							"name_alias":  basetypes.StringType{},
						},
					},
				)

				FvRsABDPolMonPolObject := FvRsABDPolMonPolFvBDResourceModel{
					Annotation:      basetypes.NewStringNull(),
					TnMonEPGPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsABDPolMonPol.ValueString())),
				}
				fvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, FvRsABDPolMonPolObject)
				upgradedStateData.FvRsABDPolMonPol = fvRsABDPolMonPolObject

				FvRsBDToFhsObject := FvRsBDToFhsFvBDResourceModel{
					Annotation:     basetypes.NewStringNull(),
					TnFhsBDPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBDToFhs.ValueString())),
				}
				fvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, FvRsBDToFhsObject)
				upgradedStateData.FvRsBDToFhs = fvRsBDToFhsObject

				FvRsBDToNdPObject := FvRsBDToNdPFvBDResourceModel{
					Annotation:    basetypes.NewStringNull(),
					TnNdIfPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBDToNdP.ValueString())),
				}
				fvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, FvRsBDToNdPObject)
				upgradedStateData.FvRsBDToNdP = fvRsBDToNdPObject

				FvRsBDToNetflowMonitorPolList := make([]FvRsBDToNetflowMonitorPolFvBDResourceModel, 0)
				var priorStateDataFvRsBDToNetflowMonitorPolList []FvRsBDToNetflowMonitorPolFvBDResourceModelV1
				priorStateData.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &priorStateDataFvRsBDToNetflowMonitorPolList, false)
				for _, priorStateDataFvRsBDToNetflowMonitorPol := range priorStateDataFvRsBDToNetflowMonitorPolList {
					FvRsBDToNetflowMonitorPol := FvRsBDToNetflowMonitorPolFvBDResourceModel{
						Annotation:              basetypes.NewStringNull(),
						FltType:                 priorStateDataFvRsBDToNetflowMonitorPol.FltType,
						TnNetflowMonitorPolName: priorStateDataFvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName,
					}
					FvRsBDToNetflowMonitorPolList = append(FvRsBDToNetflowMonitorPolList, FvRsBDToNetflowMonitorPol)
				}
				FvRsBDToNetflowMonitorPolType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":                  basetypes.StringType{},
						"filter_type":                 basetypes.StringType{},
						"netflow_monitor_policy_name": basetypes.StringType{},
					},
				}
				FvRsBDToNetflowMonitorPolSet, _ := types.SetValueFrom(ctx, FvRsBDToNetflowMonitorPolType, FvRsBDToNetflowMonitorPolList)
				upgradedStateData.FvRsBDToNetflowMonitorPol = FvRsBDToNetflowMonitorPolSet

				FvRsBDToOutList := make([]FvRsBDToOutFvBDResourceModel, 0)
				var priorStateDataFvRsBDToOutList []string
				priorStateData.FvRsBDToOut.ElementsAs(ctx, &priorStateDataFvRsBDToOutList, false)
				for _, priorStateDataFvRsBDToOut := range priorStateDataFvRsBDToOutList {
					FvRsBDToOut := FvRsBDToOutFvBDResourceModel{
						Annotation:     basetypes.NewStringNull(),
						TnL3extOutName: basetypes.NewStringValue(GetMOName(priorStateDataFvRsBDToOut)),
					}
					FvRsBDToOutList = append(FvRsBDToOutList, FvRsBDToOut)
				}
				FvRsBDToOutType := types.ObjectType{
					AttrTypes: map[string]attr.Type{
						"annotation":      basetypes.StringType{},
						"l3_outside_name": basetypes.StringType{},
					},
				}
				FvRsBDToOutSet, _ := types.SetValueFrom(ctx, FvRsBDToOutType, FvRsBDToOutList)
				upgradedStateData.FvRsBDToOut = FvRsBDToOutSet

				FvRsBDToProfileObject := FvRsBDToProfileFvBDResourceModel{
					Annotation:          basetypes.NewStringNull(),
					TnL3extOutName:      basetypes.NewStringNull(),
					TnRtctrlProfileName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBDToProfile.ValueString())),
				}
				fvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, FvRsBDToProfileObject)
				upgradedStateData.FvRsBDToProfile = fvRsBDToProfileObject

				FvRsBDToRelayPObject := FvRsBDToRelayPFvBDResourceModel{
					Annotation:       basetypes.NewStringNull(),
					TnDhcpRelayPName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBDToRelayP.ValueString())),
				}
				fvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, FvRsBDToRelayPObject)
				upgradedStateData.FvRsBDToRelayP = fvRsBDToRelayPObject

				FvRsBdToEpRetObject := FvRsBdToEpRetFvBDResourceModel{
					Annotation:       basetypes.NewStringNull(),
					ResolveAct:       basetypes.NewStringNull(),
					TnFvEpRetPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsBdToEpRet.ValueString())),
				}
				fvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, FvRsBdToEpRetObject)
				upgradedStateData.FvRsBdToEpRet = fvRsBdToEpRetObject

				FvRsCtxObject := FvRsCtxFvBDResourceModel{
					Annotation:  basetypes.NewStringNull(),
					TnFvCtxName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsCtx.ValueString())),
				}
				fvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, FvRsCtxObject)
				upgradedStateData.FvRsCtx = fvRsCtxObject

				FvRsIgmpsnObject := FvRsIgmpsnFvBDResourceModel{
					Annotation:         basetypes.NewStringNull(),
					TnIgmpSnoopPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsIgmpsn.ValueString())),
				}
				fvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, FvRsIgmpsnObject)
				upgradedStateData.FvRsIgmpsn = fvRsIgmpsnObject

				FvRsMldsnObject := FvRsMldsnFvBDResourceModel{
					Annotation:        basetypes.NewStringNull(),
					TnMldSnoopPolName: basetypes.NewStringValue(GetMOName(priorStateData.FvRsMldsn.ValueString())),
				}
				fvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, FvRsMldsnObject)
				upgradedStateData.FvRsMldsn = fvRsMldsnObject

				upgradedStateData.TagAnnotation = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				upgradedStateData.TagTag = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"key":   basetypes.StringType{},
							"value": basetypes.StringType{},
						},
					},
				)

				var deprecatedFvRsBDToOutList []string
				priorStateData.FvRsBDToOut.ElementsAs(ctx, &deprecatedFvRsBDToOutList, false)
				DeprecatedFvRsBDToOutSet, _ := types.SetValueFrom(ctx, types.StringType, deprecatedFvRsBDToOutList)
				upgradedStateData.DeprecatedFvRsBDToOut = DeprecatedFvRsBDToOutSet

				var FvRsBDToNetflowMonitorPolV1List []FvRsBDToNetflowMonitorPolFvBDResourceModelV1
				priorStateData.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &FvRsBDToNetflowMonitorPolV1List, false)
				FvRsBDToNetflowMonitorPolV1Set, _ := types.SetValueFrom(ctx, deprecatedFvRsBDToNetflowMonitorPolType, FvRsBDToNetflowMonitorPolV1List)
				upgradedStateData.DeprecatedFvRsBDToNetflowMonitorPol = FvRsBDToNetflowMonitorPolV1Set

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
	}
}

func setFvBDLegacyAttributes(ctx context.Context, diags *diag.Diagnostics, data, staticData *FvBDResourceModel, classReadInfo []interface{}) {
	data.DeprecatedParentDn = data.ParentDn
	if !staticData.Deprecated_relation_fv_rs_bd_flood_to.IsUnknown() && !staticData.Deprecated_relation_fv_rs_bd_flood_to.IsNull() {
		data.Deprecated_relation_fv_rs_bd_flood_to = staticData.Deprecated_relation_fv_rs_bd_flood_to
	} else {
		Deprecated_relation_fv_rs_bd_flood_toSet, _ := types.SetValueFrom(ctx, types.StringType, []string{})
		data.Deprecated_relation_fv_rs_bd_flood_to = Deprecated_relation_fv_rs_bd_flood_toSet
	}
	attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
	for attributeName, attributeValue := range attributes {
		if attributeName == "arpFlood" {
			data.DeprecatedArpFlood = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "epClear" {
			data.DeprecatedEpClear = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "epMoveDetectMode" {
			data.DeprecatedEpMoveDetectMode = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "hostBasedRouting" {
			data.DeprecatedHostBasedRouting = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "ipv6McastAllow" {
			data.DeprecatedIpv6McastAllow = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "llAddr" {
			data.DeprecatedLlAddr = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "mac" {
			data.DeprecatedMac = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "mcastAllow" {
			data.DeprecatedMcastAllow = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "multiDstPktAct" {
			data.DeprecatedMultiDstPktAct = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "unicastRoute" {
			data.DeprecatedUnicastRoute = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "unkMacUcastAct" {
			data.DeprecatedUnkMacUcastAct = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "unkMcastAct" {
			data.DeprecatedUnkMcastAct = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "v6unkMcastAct" {
			data.DeprecatedV6unkMcastAct = basetypes.NewStringValue(attributeValue.(string))
		}
		if attributeName == "vmac" {
			data.DeprecatedVmac = basetypes.NewStringValue(attributeValue.(string))
		}
	}
	data.DeprecatedFvRsABDPolMonPol = basetypes.NewStringNull()
	data.DeprecatedFvRsBDToFhs = basetypes.NewStringNull()
	data.DeprecatedFvRsBDToNdP = basetypes.NewStringNull()
	DeprecatedFvRsBDToOutFvBDList := make([]string, 0)
	data.DeprecatedFvRsBDToProfile = basetypes.NewStringNull()
	data.DeprecatedFvRsBDToRelayP = basetypes.NewStringNull()
	data.DeprecatedFvRsBdToEpRet = basetypes.NewStringNull()
	data.DeprecatedFvRsCtx = basetypes.NewStringNull()
	data.DeprecatedFvRsIgmpsn = basetypes.NewStringNull()
	data.DeprecatedFvRsMldsn = basetypes.NewStringNull()

	_, ok := classReadInfo[0].(map[string]interface{})["children"]
	if ok {
		children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
		for _, child := range children {
			for childClassName, childClassDetails := range child.(map[string]interface{}) {
				childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
				if childClassName == "fvRsABDPolMonPol" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsABDPolMonPol = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBDToFhs" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBDToFhs = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBDToNdP" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBDToNdP = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBDToOut" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(DeprecatedFvRsBDToOutFvBDList, childAttributeValue.(string)) {
							DeprecatedFvRsBDToOutFvBDList = append(DeprecatedFvRsBDToOutFvBDList, childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBDToProfile" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBDToProfile = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBDToRelayP" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBDToRelayP = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsBdToEpRet" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsBdToEpRet = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsCtx" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsCtx = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsIgmpsn" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsIgmpsn = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
				if childClassName == "fvRsMldsn" {
					for childAttributeName, childAttributeValue := range childAttributes {
						if childAttributeName == "tDn" {
							data.DeprecatedFvRsMldsn = basetypes.NewStringValue(childAttributeValue.(string))
						}
					}
				}
			}
		}
		data.DeprecatedFvRsBDToNetflowMonitorPol = types.SetNull(deprecatedFvRsBDToNetflowMonitorPolType)
		fvRsBDToOutSet, _ := types.SetValueFrom(ctx, data.DeprecatedFvRsBDToOut.ElementType(ctx), DeprecatedFvRsBDToOutFvBDList)
		data.DeprecatedFvRsBDToOut = fvRsBDToOutSet
	}
}

func (r *FvBDResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if !req.Plan.Raw.IsNull() {
		var planData, stateData, configData *FvBDResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		resp.Diagnostics.Append(req.Config.Get(ctx, &configData)...)

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) && !planData.ParentDn.IsUnknown() && !planData.Name.IsUnknown() {
			setFvBDId(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "fvBD", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}
		if !configData.FvAccP.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvAccP.Attributes()) {
				FvAccPObject, _ := types.ObjectValueFrom(ctx, FvAccPFvBDType, getEmptyFvAccPFvBDResourceModel())
				planData.FvAccP = FvAccPObject
			}
		}
		if !configData.FvRsABDPolMonPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsABDPolMonPol.Attributes()) {
				FvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, getEmptyFvRsABDPolMonPolFvBDResourceModel())
				planData.FvRsABDPolMonPol = FvRsABDPolMonPolObject
			}
		}
		if !configData.FvRsBDToFhs.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToFhs.Attributes()) {
				FvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, getEmptyFvRsBDToFhsFvBDResourceModel())
				planData.FvRsBDToFhs = FvRsBDToFhsObject
			}
		}
		if !configData.FvRsBDToNdP.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToNdP.Attributes()) {
				FvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, getEmptyFvRsBDToNdPFvBDResourceModel())
				planData.FvRsBDToNdP = FvRsBDToNdPObject
			}
		}
		if !configData.FvRsBDToProfile.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToProfile.Attributes()) {
				FvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, getEmptyFvRsBDToProfileFvBDResourceModel())
				planData.FvRsBDToProfile = FvRsBDToProfileObject
			}
		}
		if !configData.FvRsBDToRelayP.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToRelayP.Attributes()) {
				FvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, getEmptyFvRsBDToRelayPFvBDResourceModel())
				planData.FvRsBDToRelayP = FvRsBDToRelayPObject
			}
		}
		if !configData.FvRsBdToEpRet.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBdToEpRet.Attributes()) {
				FvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, getEmptyFvRsBdToEpRetFvBDResourceModel())
				planData.FvRsBdToEpRet = FvRsBdToEpRetObject
			}
		}
		if !configData.FvRsCtx.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsCtx.Attributes()) {
				FvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, getEmptyFvRsCtxFvBDResourceModel())
				planData.FvRsCtx = FvRsCtxObject
			}
		}
		if !configData.FvRsIgmpsn.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsIgmpsn.Attributes()) {
				FvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, getEmptyFvRsIgmpsnFvBDResourceModel())
				planData.FvRsIgmpsn = FvRsIgmpsnObject
			}
		}
		if !configData.FvRsMldsn.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsMldsn.Attributes()) {
				FvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, getEmptyFvRsMldsnFvBDResourceModel())
				planData.FvRsMldsn = FvRsMldsnObject
			}
		}

		if !configData.ArpFlood.IsNull() {
			planData.DeprecatedArpFlood = configData.ArpFlood
		} else if !configData.DeprecatedArpFlood.IsNull() {
			planData.ArpFlood = configData.DeprecatedArpFlood
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedArpFlood = stateData.DeprecatedArpFlood
		}

		if !configData.EpClear.IsNull() {
			planData.DeprecatedEpClear = configData.EpClear
		} else if !configData.DeprecatedEpClear.IsNull() {
			planData.EpClear = configData.DeprecatedEpClear
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedEpClear = stateData.DeprecatedEpClear
		}

		if !configData.EpMoveDetectMode.IsNull() {
			planData.DeprecatedEpMoveDetectMode = configData.EpMoveDetectMode
		} else if !configData.DeprecatedEpMoveDetectMode.IsNull() {
			planData.EpMoveDetectMode = configData.DeprecatedEpMoveDetectMode
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedEpMoveDetectMode = stateData.DeprecatedEpMoveDetectMode
		}

		if !configData.HostBasedRouting.IsNull() {
			planData.DeprecatedHostBasedRouting = configData.HostBasedRouting
		} else if !configData.DeprecatedHostBasedRouting.IsNull() {
			planData.HostBasedRouting = configData.DeprecatedHostBasedRouting
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedHostBasedRouting = stateData.DeprecatedHostBasedRouting
		}

		if !configData.Ipv6McastAllow.IsNull() {
			planData.DeprecatedIpv6McastAllow = configData.Ipv6McastAllow
		} else if !configData.DeprecatedIpv6McastAllow.IsNull() {
			planData.Ipv6McastAllow = configData.DeprecatedIpv6McastAllow
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedIpv6McastAllow = stateData.DeprecatedIpv6McastAllow
		}

		if !configData.LlAddr.IsNull() {
			planData.DeprecatedLlAddr = configData.LlAddr
		} else if !configData.DeprecatedLlAddr.IsNull() {
			planData.LlAddr = configData.DeprecatedLlAddr
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedLlAddr = stateData.DeprecatedLlAddr
		}

		if !configData.Mac.IsNull() {
			planData.DeprecatedMac = configData.Mac
		} else if !configData.DeprecatedMac.IsNull() {
			planData.Mac = configData.DeprecatedMac
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedMac = stateData.DeprecatedMac
		}

		if !configData.McastAllow.IsNull() {
			planData.DeprecatedMcastAllow = configData.McastAllow
		} else if !configData.DeprecatedMcastAllow.IsNull() {
			planData.McastAllow = configData.DeprecatedMcastAllow
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedMcastAllow = stateData.DeprecatedMcastAllow
		}

		if !configData.MultiDstPktAct.IsNull() {
			planData.DeprecatedMultiDstPktAct = configData.MultiDstPktAct
		} else if !configData.DeprecatedMultiDstPktAct.IsNull() {
			planData.MultiDstPktAct = configData.DeprecatedMultiDstPktAct
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedMultiDstPktAct = stateData.DeprecatedMultiDstPktAct
		}

		if !configData.ParentDn.IsNull() {
			planData.DeprecatedParentDn = configData.ParentDn
		} else if !configData.DeprecatedParentDn.IsNull() {
			planData.ParentDn = configData.DeprecatedParentDn
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedParentDn = stateData.DeprecatedParentDn
		}

		if !configData.UnicastRoute.IsNull() {
			planData.DeprecatedUnicastRoute = configData.UnicastRoute
		} else if !configData.DeprecatedUnicastRoute.IsNull() {
			planData.UnicastRoute = configData.DeprecatedUnicastRoute
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedUnicastRoute = stateData.DeprecatedUnicastRoute
		}

		if !configData.UnkMacUcastAct.IsNull() {
			planData.DeprecatedUnkMacUcastAct = configData.UnkMacUcastAct
		} else if !configData.DeprecatedUnkMacUcastAct.IsNull() {
			planData.UnkMacUcastAct = configData.DeprecatedUnkMacUcastAct
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedUnkMacUcastAct = stateData.DeprecatedUnkMacUcastAct
		}

		if !configData.UnkMcastAct.IsNull() {
			planData.DeprecatedUnkMcastAct = configData.UnkMcastAct
		} else if !configData.DeprecatedUnkMcastAct.IsNull() {
			planData.UnkMcastAct = configData.DeprecatedUnkMcastAct
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedUnkMcastAct = stateData.DeprecatedUnkMcastAct
		}

		if !configData.V6unkMcastAct.IsNull() {
			planData.DeprecatedV6unkMcastAct = configData.V6unkMcastAct
		} else if !configData.DeprecatedV6unkMcastAct.IsNull() {
			planData.V6unkMcastAct = configData.DeprecatedV6unkMcastAct
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedV6unkMcastAct = stateData.DeprecatedV6unkMcastAct
		}

		if !configData.Vmac.IsNull() {
			planData.DeprecatedVmac = configData.Vmac
		} else if !configData.DeprecatedVmac.IsNull() {
			planData.Vmac = configData.DeprecatedVmac
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedVmac = stateData.DeprecatedVmac
		}

		if !configData.FvRsBdToEpRet.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBdToEpRet.Attributes()) {
				planData.FvRsBdToEpRet = configData.FvRsBdToEpRet
				planData.DeprecatedFvRsBdToEpRet = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBdToEpRetFvBDResourceModel
				configData.FvRsBdToEpRet.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBdToEpRet.ValueString()) == attributeValues.TnFvEpRetPolName.ValueString() && !attributeValues.TnFvEpRetPolName.IsNull() {
					planData.DeprecatedFvRsBdToEpRet = stateData.DeprecatedFvRsBdToEpRet
				}
			}
		} else if !configData.DeprecatedFvRsBdToEpRet.IsNull() {
			FvRsBdToEpRet := FvRsBdToEpRetFvBDResourceModel{
				Annotation:       planData.Annotation,
				ResolveAct:       basetypes.NewStringNull(),
				TnFvEpRetPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBdToEpRet.ValueString())),
			}
			FvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, FvRsBdToEpRet)
			planData.FvRsBdToEpRet = FvRsBdToEpRetObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBdToEpRet = stateData.DeprecatedFvRsBdToEpRet
		}

		if !configData.FvRsBDToFhs.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToFhs.Attributes()) {
				planData.FvRsBDToFhs = configData.FvRsBDToFhs
				planData.DeprecatedFvRsBDToFhs = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBDToFhsFvBDResourceModel
				configData.FvRsBDToFhs.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBDToFhs.ValueString()) == attributeValues.TnFhsBDPolName.ValueString() && !attributeValues.TnFhsBDPolName.IsNull() {
					planData.DeprecatedFvRsBDToFhs = stateData.DeprecatedFvRsBDToFhs
				}
			}
		} else if !configData.DeprecatedFvRsBDToFhs.IsNull() {
			FvRsBDToFhs := FvRsBDToFhsFvBDResourceModel{
				Annotation:     planData.Annotation,
				TnFhsBDPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBDToFhs.ValueString())),
			}
			FvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, FvRsBDToFhs)
			planData.FvRsBDToFhs = FvRsBDToFhsObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBDToFhs = stateData.DeprecatedFvRsBDToFhs
		}

		if !configData.FvRsIgmpsn.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsIgmpsn.Attributes()) {
				planData.FvRsIgmpsn = configData.FvRsIgmpsn
				planData.DeprecatedFvRsIgmpsn = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsIgmpsnFvBDResourceModel
				configData.FvRsIgmpsn.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsIgmpsn.ValueString()) == attributeValues.TnIgmpSnoopPolName.ValueString() && !attributeValues.TnIgmpSnoopPolName.IsNull() {
					planData.DeprecatedFvRsIgmpsn = stateData.DeprecatedFvRsIgmpsn
				}
			}
		} else if !configData.DeprecatedFvRsIgmpsn.IsNull() {
			FvRsIgmpsn := FvRsIgmpsnFvBDResourceModel{
				Annotation:         planData.Annotation,
				TnIgmpSnoopPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsIgmpsn.ValueString())),
			}
			FvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, FvRsIgmpsn)
			planData.FvRsIgmpsn = FvRsIgmpsnObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsIgmpsn = stateData.DeprecatedFvRsIgmpsn
		}

		if !configData.FvRsBDToOut.IsNull() && stateData != nil {
			var attributeValues []FvRsBDToOutFvBDResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.FvRsBDToOut.ElementsAs(ctx, &attributeValues, false)
			stateData.DeprecatedFvRsBDToOut.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
				newAttributeValues = append(newAttributeValues, attributeValue.TnL3extOutName.ValueString())
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					FvRsBDToOutSet, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.DeprecatedFvRsBDToOut = FvRsBDToOutSet
				}
			}
		} else if !configData.DeprecatedFvRsBDToOut.IsNull() {
			FvRsBDToOutList := make([]FvRsBDToOutFvBDResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []FvRsBDToOutFvBDResourceModel
			configData.DeprecatedFvRsBDToOut.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.FvRsBDToOut.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				FvRsBDToOutValue := FvRsBDToOutFvBDResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.TnL3extOutName.ValueString() == GetMOName(attributeValue) {
						FvRsBDToOutValue = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
				FvRsBDToOut := FvRsBDToOutFvBDResourceModel{
					TnL3extOutName: basetypes.NewStringValue(GetMOName(attributeValue)),
				}

				if foundAttributeValue {
					FvRsBDToOut.Annotation = FvRsBDToOutValue.Annotation
				} else {
					FvRsBDToOut.Annotation = planData.Annotation
				}
				FvRsBDToOutList = append(FvRsBDToOutList, FvRsBDToOut)
			}
			FvRsBDToOutType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":      basetypes.StringType{},
					"l3_outside_name": basetypes.StringType{},
				},
			}
			FvRsBDToOutSet, _ := types.SetValueFrom(ctx, FvRsBDToOutType, FvRsBDToOutList)
			planData.FvRsBDToOut = FvRsBDToOutSet
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBDToOut = stateData.DeprecatedFvRsBDToOut
		}

		if !configData.FvRsMldsn.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsMldsn.Attributes()) {
				planData.FvRsMldsn = configData.FvRsMldsn
				planData.DeprecatedFvRsMldsn = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsMldsnFvBDResourceModel
				configData.FvRsMldsn.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsMldsn.ValueString()) == attributeValues.TnMldSnoopPolName.ValueString() && !attributeValues.TnMldSnoopPolName.IsNull() {
					planData.DeprecatedFvRsMldsn = stateData.DeprecatedFvRsMldsn
				}
			}
		} else if !configData.DeprecatedFvRsMldsn.IsNull() {
			FvRsMldsn := FvRsMldsnFvBDResourceModel{
				Annotation:        planData.Annotation,
				TnMldSnoopPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsMldsn.ValueString())),
			}
			FvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, FvRsMldsn)
			planData.FvRsMldsn = FvRsMldsnObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsMldsn = stateData.DeprecatedFvRsMldsn
		}

		if !configData.FvRsABDPolMonPol.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsABDPolMonPol.Attributes()) {
				planData.FvRsABDPolMonPol = configData.FvRsABDPolMonPol
				planData.DeprecatedFvRsABDPolMonPol = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsABDPolMonPolFvBDResourceModel
				configData.FvRsABDPolMonPol.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsABDPolMonPol.ValueString()) == attributeValues.TnMonEPGPolName.ValueString() && !attributeValues.TnMonEPGPolName.IsNull() {
					planData.DeprecatedFvRsABDPolMonPol = stateData.DeprecatedFvRsABDPolMonPol
				}
			}
		} else if !configData.DeprecatedFvRsABDPolMonPol.IsNull() {
			FvRsABDPolMonPol := FvRsABDPolMonPolFvBDResourceModel{
				Annotation:      planData.Annotation,
				TnMonEPGPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsABDPolMonPol.ValueString())),
			}
			FvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, FvRsABDPolMonPol)
			planData.FvRsABDPolMonPol = FvRsABDPolMonPolObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsABDPolMonPol = stateData.DeprecatedFvRsABDPolMonPol
		}

		if !configData.FvRsBDToNdP.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToNdP.Attributes()) {
				planData.FvRsBDToNdP = configData.FvRsBDToNdP
				planData.DeprecatedFvRsBDToNdP = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBDToNdPFvBDResourceModel
				configData.FvRsBDToNdP.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBDToNdP.ValueString()) == attributeValues.TnNdIfPolName.ValueString() && !attributeValues.TnNdIfPolName.IsNull() {
					planData.DeprecatedFvRsBDToNdP = stateData.DeprecatedFvRsBDToNdP
				}
			}
		} else if !configData.DeprecatedFvRsBDToNdP.IsNull() {
			FvRsBDToNdP := FvRsBDToNdPFvBDResourceModel{
				Annotation:    planData.Annotation,
				TnNdIfPolName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBDToNdP.ValueString())),
			}
			FvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, FvRsBDToNdP)
			planData.FvRsBDToNdP = FvRsBDToNdPObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBDToNdP = stateData.DeprecatedFvRsBDToNdP
		}

		if !configData.FvRsBDToRelayP.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToRelayP.Attributes()) {
				planData.FvRsBDToRelayP = configData.FvRsBDToRelayP
				planData.DeprecatedFvRsBDToRelayP = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBDToRelayPFvBDResourceModel
				configData.FvRsBDToRelayP.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBDToRelayP.ValueString()) == attributeValues.TnDhcpRelayPName.ValueString() && !attributeValues.TnDhcpRelayPName.IsNull() {
					planData.DeprecatedFvRsBDToRelayP = stateData.DeprecatedFvRsBDToRelayP
				}
			}
		} else if !configData.DeprecatedFvRsBDToRelayP.IsNull() {
			FvRsBDToRelayP := FvRsBDToRelayPFvBDResourceModel{
				Annotation:       planData.Annotation,
				TnDhcpRelayPName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBDToRelayP.ValueString())),
			}
			FvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, FvRsBDToRelayP)
			planData.FvRsBDToRelayP = FvRsBDToRelayPObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBDToRelayP = stateData.DeprecatedFvRsBDToRelayP
		}

		if !configData.FvRsBDToProfile.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsBDToProfile.Attributes()) {
				planData.FvRsBDToProfile = configData.FvRsBDToProfile
				planData.DeprecatedFvRsBDToProfile = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsBDToProfileFvBDResourceModel
				configData.FvRsBDToProfile.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsBDToProfile.ValueString()) == attributeValues.TnRtctrlProfileName.ValueString() && !attributeValues.TnRtctrlProfileName.IsNull() {
					planData.DeprecatedFvRsBDToProfile = stateData.DeprecatedFvRsBDToProfile
				}
			}
		} else if !configData.DeprecatedFvRsBDToProfile.IsNull() {
			FvRsBDToProfile := FvRsBDToProfileFvBDResourceModel{
				Annotation:          planData.Annotation,
				TnL3extOutName:      basetypes.NewStringValue(""),
				TnRtctrlProfileName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsBDToProfile.ValueString())),
			}
			FvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, FvRsBDToProfile)
			planData.FvRsBDToProfile = FvRsBDToProfileObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsBDToProfile = stateData.DeprecatedFvRsBDToProfile
		}

		if !configData.FvRsCtx.IsNull() && stateData != nil {
			if IsEmptySingleNestedAttribute(configData.FvRsCtx.Attributes()) {
				planData.FvRsCtx = configData.FvRsCtx
				planData.DeprecatedFvRsCtx = basetypes.NewStringNull()
			} else {
				var attributeValues FvRsCtxFvBDResourceModel
				configData.FvRsCtx.As(ctx, &attributeValues, basetypes.ObjectAsOptions{})
				if GetMOName(stateData.DeprecatedFvRsCtx.ValueString()) == attributeValues.TnFvCtxName.ValueString() && !attributeValues.TnFvCtxName.IsNull() {
					planData.DeprecatedFvRsCtx = stateData.DeprecatedFvRsCtx
				}
			}
		} else if !configData.DeprecatedFvRsCtx.IsNull() {
			FvRsCtx := FvRsCtxFvBDResourceModel{
				Annotation:  planData.Annotation,
				TnFvCtxName: basetypes.NewStringValue(GetMOName(configData.DeprecatedFvRsCtx.ValueString())),
			}
			FvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, FvRsCtx)
			planData.FvRsCtx = FvRsCtxObject
		} else if stateData != nil { // used to replace use state for unknown
			planData.DeprecatedFvRsCtx = stateData.DeprecatedFvRsCtx
		}

		planData.DeprecatedFvRsBDToNetflowMonitorPol = types.SetNull(deprecatedFvRsBDToNetflowMonitorPolType)
		if !configData.DeprecatedFvRsBDToNetflowMonitorPol.IsNull() && stateData != nil {
			FvRsBDToNetflowMonitorPolList := make([]FvRsBDToNetflowMonitorPolFvBDResourceModel, 0)
			var attributeValues []FvRsBDToNetflowMonitorPolFvBDResourceModelV1
			var newAttributeValues []FvRsBDToNetflowMonitorPolFvBDResourceModel
			configData.DeprecatedFvRsBDToNetflowMonitorPol.ElementsAs(ctx, &attributeValues, false)
			stateData.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &newAttributeValues, false)
			for _, attributeValue := range attributeValues {

				FvRsBDToNetflowMonitorPol := FvRsBDToNetflowMonitorPolFvBDResourceModel{
					Annotation: planData.Annotation,
					FltType:    attributeValue.FltType,
				}

				FvRsBDToNetflowMonitorPolList = append(FvRsBDToNetflowMonitorPolList, FvRsBDToNetflowMonitorPol)
			}

			FvRsBDToNetflowMonitorPolType := types.ObjectType{
				AttrTypes: map[string]attr.Type{
					"annotation":                  basetypes.StringType{},
					"filter_type":                 basetypes.StringType{},
					"netflow_monitor_policy_name": basetypes.StringType{},
				},
			}
			FvRsBDToNetflowMonitorPolSet, _ := types.SetValueFrom(ctx, FvRsBDToNetflowMonitorPolType, FvRsBDToNetflowMonitorPolList)
			planData.FvRsBDToNetflowMonitorPol = FvRsBDToNetflowMonitorPolSet
		}

		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func (r *FvBDResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_bridge_domain")
	resp.TypeName = req.ProviderTypeName + "_bridge_domain"
	tflog.Debug(ctx, "End metadata of resource: aci_bridge_domain")
}

func (r *FvBDResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_bridge_domain")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The bridge_domain resource for the 'fvBD' class",
		Version:             2,

		Attributes: map[string]schema.Attribute{
			// Deprecated attributes
			"arp_flood": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'arp_flood' is deprecated, please refer to 'arp_flooding' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("arp_flooding"),
					}...),
				},
			},
			"ep_clear": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_clear' is deprecated, please refer to 'clear_remote_mac_entries' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("clear_remote_mac_entries"),
					}...),
				},
			},
			"ep_move_detect_mode": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_move_detect_mode' is deprecated, please refer to 'endpoint_move_detection_mode' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("endpoint_move_detection_mode"),
					}...),
				},
			},
			"host_based_routing": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'host_based_routing' is deprecated, please refer to 'advertise_host_routes' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("advertise_host_routes"),
					}...),
				},
			},
			"ipv6_mcast_allow": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'ipv6_mcast_allow' is deprecated, please refer to 'pim_ipv6' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("pim_ipv6"),
					}...),
				},
			},
			"ll_addr": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'll_addr' is deprecated, please refer to 'link_local_ipv6_address' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("link_local_ipv6_address"),
					}...),
				},
			},
			"mac": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'mac' is deprecated, please refer to 'custom_mac_address' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("custom_mac_address"),
					}...),
				},
			},
			"mcast_allow": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'mcast_allow' is deprecated, please refer to 'pim' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("pim"),
					}...),
				},
			},
			"multi_dst_pkt_act": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'multi_dst_pkt_act' is deprecated, please refer to 'multi_destination_flooding' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("multi_destination_flooding"),
					}...),
				},
			},
			"tenant_dn": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'tenant_dn' is deprecated, please refer to 'parent_dn' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("parent_dn"),
					}...),
				},
			},
			"unicast_route": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'unicast_route' is deprecated, please refer to 'unicast_routing' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("unicast_routing"),
					}...),
				},
			},
			"unk_mac_ucast_act": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'unk_mac_ucast_act' is deprecated, please refer to 'l2_unknown_unicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("l2_unknown_unicast_flooding"),
					}...),
				},
			},
			"unk_mcast_act": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'unk_mcast_act' is deprecated, please refer to 'l3_unknown_multicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("l3_unknown_multicast_flooding"),
					}...),
				},
			},
			"v6unk_mcast_act": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'v6unk_mcast_act' is deprecated, please refer to 'ipv6_l3_unknown_multicast_flooding' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("ipv6_l3_unknown_multicast_flooding"),
					}...),
				},
			},
			"vmac": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'vmac' is deprecated, please refer to 'virtual_mac_address' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("virtual_mac_address"),
					}...),
				},
			},
			"relation_fv_rs_bd_flood_to": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute `relation_fv_rs_bd_flood_to` is deprecated. The attribute will be removed in the next major version of the provider.",
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
			"relation_fv_rs_bd_to_ep_ret": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_ep_ret' is deprecated, please refer to 'relation_to_end_point_retention_policy.end_point_retention_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_end_point_retention_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd_to_fhs": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_fhs' is deprecated, please refer to 'relation_to_first_hop_security_policy.first_hop_security_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_first_hop_security_policy"),
					}...),
				},
			},
			"relation_fv_rs_igmpsn": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_igmpsn' is deprecated, please refer to 'relation_to_igmp_snooping_policy.igmp_snooping_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_igmp_snooping_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd_to_out": schema.SetAttribute{
				Optional:           true,
				Computed:           true,
				ElementType:        types.StringType,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_out' is deprecated, please refer to 'relation_to_l3_outsides.l3_outside_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_l3_outsides"),
					}...),
				},
			},
			"relation_fv_rs_mldsn": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_mldsn' is deprecated, please refer to 'relation_to_mld_snooping_policy.mld_snooping_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_mld_snooping_policy"),
					}...),
				},
			},
			"relation_fv_rs_abd_pol_mon_pol": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_abd_pol_mon_pol' is deprecated, please refer to 'relation_to_monitor_policy.monitoring_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_monitor_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd_to_nd_p": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_nd_p' is deprecated, please refer to 'relation_to_neighbor_discovery_interface_policy.neighbor_discovery_interface_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_neighbor_discovery_interface_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd_to_relay_p": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_relay_p' is deprecated, please refer to 'relation_to_relay_policy.dhcp_relay_policy_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_relay_policy"),
					}...),
				},
			},
			"relation_fv_rs_bd_to_profile": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_bd_to_profile' is deprecated, please refer to 'relation_to_route_control_profile.route_control_profile_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_route_control_profile"),
					}...),
				},
			},
			"relation_fv_rs_ctx": schema.StringAttribute{
				Optional:           true,
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_fv_rs_ctx' is deprecated, please refer to 'relation_to_vrf.vrf_name' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("relation_to_vrf"),
					}...),
				},
			},
			// End of deprecated attributes
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the Bridge Domain object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"parent_dn": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("tenant_dn"),
					}...),
				},
			},
			"optimize_wan_bandwidth": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Optimize WAN Bandwidth for the Bridge Domain object.`,
			},
			"annotation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Default:             stringdefault.StaticString(globalAnnotation),
				MarkdownDescription: `The annotation of the Bridge Domain object.`,
			},
			"arp_flooding": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable ARP flooding for the Bridge Domain object. If flooding is disabled, ARP requests for unknown endpoints will be forwarded by the leaf switch to the spine proxy for resolution and might trigger an ARP glean if the endpoint is not present in the COOP database.`,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The description of the Bridge Domain object.`,
			},
			"enable_rogue_exception_mac": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable rogue exception based on MAC wildcard for the Bridge Domain object.`,
			},
			"clear_remote_mac_entries": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Clear all endpoints in leaf switches for the Bridge Domain object.`,
			},
			"endpoint_move_detection_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("", "garp"),
				},
				MarkdownDescription: `The End Point move detection option uses the Gratuitous Address Resolution Protocol (GARP). A gratuitous ARP is an ARP broadcast-type of packet that is used to verify that no other device on the network has the same IP address as the sending device.`,
			},
			"advertise_host_routes": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Advertise host routes (/32 prefixes) out of the L3Out(s) associated to the Bridge Domain object.`,
			},
			"intersite_bum_traffic_allow": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable intersite Broadcast, Unknown-Unicast and Multicast (BUM) traffic between sites for the Bridge Domain object.`,
			},
			"intersite_l2_stretch": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable L2 stretch between sites for the Bridge Domain object.`,
			},
			"ip_learning": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The IP learning setting of the Bridge Domain object.`,
			},
			"pim_ipv6": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable IPv6 multicast traffic for the Bridge Domain object.`,
			},
			"limit_ip_learn_to_subnets": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Limit IP address learning to subnets for the Bridge Domain object. Every Bridge Domain object can have multiple subnets associated with it.`,
			},
			"link_local_ipv6_address": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators:          []validator.String{},
				MarkdownDescription: `The override of the system generated IPv6 link-local address.`,
			},
			"custom_mac_address": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators:          []validator.String{},
				MarkdownDescription: `The MAC address of the Bridge Domain object.`,
			},
			"drop_arp_with_multicast_smac": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Drop rogue multicast ARP packets for the Bridge Domain object.`,
			},
			"pim": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enable IPv4 multicast traffic for the Bridge Domain object.`,
			},
			"multi_destination_flooding": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("bd-flood", "drop", "encap-flood"),
				},
				MarkdownDescription: `The multiple destination forwarding method for L2 Multicast, Broadcast, and Link Layer traffic types.`,
			},
			"name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The name of the Bridge Domain object.`,
			},
			"name_alias": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The name alias of the Bridge Domain object.`,
			},
			"owner_key": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
			},
			"owner_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
			},
			"bridge_domain_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("fc", "regular"),
				},
				MarkdownDescription: `domain type.`,
			},
			"unicast_routing": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `Enables L3 routing and endpoint IP learning for the Bridge Domain object.`,
			},
			"l2_unknown_unicast_flooding": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("flood", "proxy"),
				},
				MarkdownDescription: `The forwarding method for unknown layer 2 destinations.`,
			},
			"l3_unknown_multicast_flooding": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("flood", "opt-flood"),
				},
				MarkdownDescription: `The forwarding method for unknown layer 3 multicast destinations.`,
			},
			"ipv6_l3_unknown_multicast_flooding": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("flood", "opt-flood"),
				},
				MarkdownDescription: `The forwarding method for unknown IPv6 multicast destinations.`,
			},
			"virtual_mac_address": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators:          []validator.String{},
				MarkdownDescription: `The virtual MAC address of the Bridge Domain object. This is used when the the BD/SVI is extended to multiple sites using a L2 Outside.`,
			},
			"legacy_mode": schema.SingleNestedAttribute{
				MarkdownDescription: `The bridge domain (BD) access profile. When created over a BD, contracts are not enforced for the BD, and the encap will be applied to all endpoint groups on this BD.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.Object{
					MakeSingleNestedAttributeRequiredAttributesNotProvidedValidator("legacy_mode", []string{"encapsulation"}),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Legacy Mode object.`,
					},
					"description": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The description of the Legacy Mode object.`,
					},
					"encapsulation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The VLAN or VXLAN encapsulation of the Legacy Mode object.`,
					},
					"name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the Legacy Mode object.`,
					},
					"name_alias": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name alias of the Legacy Mode object.`,
					},
					"owner_key": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
					},
					"owner_tag": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
					},
				},
			},
			"rogue_coop_exceptions": schema.SetNestedAttribute{
				MarkdownDescription: `Configuration of MAC address to be excepted from Rogue processing`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Rogue Coop Exception object.`,
						},
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The description of the Rogue Coop Exception object.`,
						},
						"mac": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The MAC address of the Rogue Coop Exception object.`,
						},
						"name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the Rogue Coop Exception object.`,
						},
						"name_alias": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name alias of the Rogue Coop Exception object.`,
						},
					},
				},
			},
			"relation_to_monitor_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the monitoring policy model for the endpoint group semantic scope. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Monitoring Policy object.`,
					},
					"monitoring_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the Monitoring Policy object.`,
					},
				},
			},
			"relation_to_first_hop_security_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relation to FHS BD policy`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To First Hop Security Policy object.`,
					},
					"first_hop_security_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the First Hop Security Policy object.`,
					},
				},
			},
			"relation_to_neighbor_discovery_interface_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `The neighbor discovery policy.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Neighbor Discovery Interface Policy object.`,
					},
					"neighbor_discovery_interface_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the Neighbor Discovery Interface Policy object.`,
					},
				},
			},
			"relation_to_netflow_monitor_policies": schema.SetNestedAttribute{
				MarkdownDescription: `Relation to Netflow Monitor policy`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Relation From Bridge Domain To NetFlow Monitor Policy object.`,
						},
						"filter_type": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							Validators: []validator.String{
								stringvalidator.OneOf("ce", "ipv4", "ipv6", "unspecified"),
								MakeStringRequired(),
							},
							MarkdownDescription: `The filter type of the NetFlow Monitor Policy object.`,
						},
						"netflow_monitor_policy_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the NetFlow Monitor Policy object.`,
						},
					},
				},
			},
			"relation_to_l3_outsides": schema.SetNestedAttribute{
				MarkdownDescription: `A source relation to the policy controlling connectivity to the outside. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"annotation": schema.StringAttribute{
							Optional: true,
							Computed: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The annotation of the Relation From Bridge Domain To L3 Outside object.`,
						},
						"l3_outside_name": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The name of the L3 Outside object.`,
						},
					},
				},
			},
			"relation_to_route_control_profile": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to external networks that are routed via Layer 3 networks outside the fabric that are reachable by a tenant's applications. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Route Control Profile object.`,
					},
					"l3_outside_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the L3 Outside object.`,
					},
					"route_control_profile_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the Route Control Profile object.`,
					},
				},
			},
			"relation_to_dhcp_relay_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the DHCP relay profile. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To Dhcp Relay Policy object.`,
					},
					"dhcp_relay_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the DHCP Relay Policy object.`,
					},
				},
			},
			"relation_to_end_point_retention_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the endpoint retention policy providing the parameters for the lifecycle of the endpoint group. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation From Bridge Domain To End Point Retention Policy object.`,
					},
					"resolve_action": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						Validators: []validator.String{
							stringvalidator.OneOf("inherit", "resolve"),
						},
						MarkdownDescription: `The action to take for resolving the Endpoint Retention Policy object.`,
					},
					"end_point_retention_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the Endpoint Retention Policy object.`,
					},
				},
			},
			"relation_to_vrf": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to a private layer 3 network context that either belongs to a specific tenant or is shared. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation To VRF object.`,
					},
					"vrf_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the VRF object.`,
					},
				},
			},
			"relation_to_igmp_snooping_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the Internet Group Management Protocol (IGMP) snooping policy. This is an internal object.`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation To IGMP Snooping Policy object.`,
					},
					"igmp_snooping_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the IGMP Snooping Policy object.`,
					},
				},
			},
			"relation_to_mld_snooping_policy": schema.SingleNestedAttribute{
				MarkdownDescription: `Relation to an MLD Snoop policy`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The annotation of the Relation To MLD Snooping Policy object.`,
					},
					"mld_snooping_policy_name": schema.StringAttribute{
						Optional: true,
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
						MarkdownDescription: `The name of the MLD Snooping Policy object.`,
					},
				},
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{
			"relation_fv_rs_bd_to_netflow_monitor_pol": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"flt_type": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'flt_type' will be deprecated soon, please use 'relation_to_netflow_monitor_policy.filter_type' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_netflow_monitor_policy"),
								}...),
							},
						},
						"tn_netflow_monitor_pol_name": schema.StringAttribute{
							Optional:           true,
							Computed:           true,
							DeprecationMessage: "Attribute 'tn_netflow_monitor_pol_name' will be deprecated soon, please use 'relation_to_netflow_monitor_policy.netflow_monitor_policy_name' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("relation_to_netflow_monitor_policy"),
								}...),
							},
						},
					},
				},
			},
		},
	}
	tflog.Debug(ctx, "End schema of resource: aci_bridge_domain")
}

func (r *FvBDResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_bridge_domain")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_bridge_domain")
}

func (r *FvBDResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_bridge_domain")
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *FvBDResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		setFvBDId(ctx, stateData)
	}
	getAndSetFvBDAttributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The fvBD object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	}

	var data *FvBDResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Id.IsUnknown() || data.Id.IsNull() {
		setFvBDId(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))

	var fvAccPPlan, fvAccPState FvAccPFvBDResourceModel
	data.FvAccP.As(ctx, &fvAccPPlan, basetypes.ObjectAsOptions{})
	stateData.FvAccP.As(ctx, &fvAccPState, basetypes.ObjectAsOptions{})
	var fvRogueExceptionMacPlan, fvRogueExceptionMacState []FvRogueExceptionMacFvBDResourceModel
	data.FvRogueExceptionMac.ElementsAs(ctx, &fvRogueExceptionMacPlan, false)
	stateData.FvRogueExceptionMac.ElementsAs(ctx, &fvRogueExceptionMacState, false)
	var fvRsABDPolMonPolPlan, fvRsABDPolMonPolState FvRsABDPolMonPolFvBDResourceModel
	data.FvRsABDPolMonPol.As(ctx, &fvRsABDPolMonPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsABDPolMonPol.As(ctx, &fvRsABDPolMonPolState, basetypes.ObjectAsOptions{})
	var fvRsBDToFhsPlan, fvRsBDToFhsState FvRsBDToFhsFvBDResourceModel
	data.FvRsBDToFhs.As(ctx, &fvRsBDToFhsPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToFhs.As(ctx, &fvRsBDToFhsState, basetypes.ObjectAsOptions{})
	var fvRsBDToNdPPlan, fvRsBDToNdPState FvRsBDToNdPFvBDResourceModel
	data.FvRsBDToNdP.As(ctx, &fvRsBDToNdPPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToNdP.As(ctx, &fvRsBDToNdPState, basetypes.ObjectAsOptions{})
	var fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState []FvRsBDToNetflowMonitorPolFvBDResourceModel
	data.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &fvRsBDToNetflowMonitorPolPlan, false)
	stateData.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &fvRsBDToNetflowMonitorPolState, false)
	var fvRsBDToOutPlan, fvRsBDToOutState []FvRsBDToOutFvBDResourceModel
	data.FvRsBDToOut.ElementsAs(ctx, &fvRsBDToOutPlan, false)
	stateData.FvRsBDToOut.ElementsAs(ctx, &fvRsBDToOutState, false)
	var fvRsBDToProfilePlan, fvRsBDToProfileState FvRsBDToProfileFvBDResourceModel
	data.FvRsBDToProfile.As(ctx, &fvRsBDToProfilePlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToProfile.As(ctx, &fvRsBDToProfileState, basetypes.ObjectAsOptions{})
	var fvRsBDToRelayPPlan, fvRsBDToRelayPState FvRsBDToRelayPFvBDResourceModel
	data.FvRsBDToRelayP.As(ctx, &fvRsBDToRelayPPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToRelayP.As(ctx, &fvRsBDToRelayPState, basetypes.ObjectAsOptions{})
	var fvRsBdToEpRetPlan, fvRsBdToEpRetState FvRsBdToEpRetFvBDResourceModel
	data.FvRsBdToEpRet.As(ctx, &fvRsBdToEpRetPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBdToEpRet.As(ctx, &fvRsBdToEpRetState, basetypes.ObjectAsOptions{})
	var fvRsCtxPlan, fvRsCtxState FvRsCtxFvBDResourceModel
	data.FvRsCtx.As(ctx, &fvRsCtxPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsCtx.As(ctx, &fvRsCtxState, basetypes.ObjectAsOptions{})
	var fvRsIgmpsnPlan, fvRsIgmpsnState FvRsIgmpsnFvBDResourceModel
	data.FvRsIgmpsn.As(ctx, &fvRsIgmpsnPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsIgmpsn.As(ctx, &fvRsIgmpsnState, basetypes.ObjectAsOptions{})
	var fvRsMldsnPlan, fvRsMldsnState FvRsMldsnFvBDResourceModel
	data.FvRsMldsn.As(ctx, &fvRsMldsnPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsMldsn.As(ctx, &fvRsMldsnState, basetypes.ObjectAsOptions{})
	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvBDResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvBDResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getFvBDCreateJsonPayload(ctx, &resp.Diagnostics, true, data, fvAccPPlan, fvAccPState, fvRogueExceptionMacPlan, fvRogueExceptionMacState, fvRsABDPolMonPolPlan, fvRsABDPolMonPolState, fvRsBDToFhsPlan, fvRsBDToFhsState, fvRsBDToNdPPlan, fvRsBDToNdPState, fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState, fvRsBDToOutPlan, fvRsBDToOutState, fvRsBDToProfilePlan, fvRsBDToProfileState, fvRsBDToRelayPPlan, fvRsBDToRelayPState, fvRsBdToEpRetPlan, fvRsBdToEpRetState, fvRsCtxPlan, fvRsCtxState, fvRsIgmpsnPlan, fvRsIgmpsnState, fvRsMldsnPlan, fvRsMldsnState, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvBDAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvBDResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_bridge_domain")
	var data *FvBDResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))

	getAndSetFvBDAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *FvBDResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvBDResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_bridge_domain")
	var data *FvBDResourceModel
	var stateData *FvBDResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	// Error out when child object fvRsBDToNdP is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsBDToNdP.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsBDToNdP.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsBDToNdP object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
	// Error out when child object fvRsBdToEpRet is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsBdToEpRet.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsBdToEpRet.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsBdToEpRet object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
	// Error out when child object fvRsCtx is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsCtx.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsCtx.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsCtx object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
	// Error out when child object fvRsIgmpsn is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsIgmpsn.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsIgmpsn.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsIgmpsn object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
	// Error out when child object fvRsMldsn is being deleted
	if IsEmptySingleNestedAttribute(data.FvRsMldsn.Attributes()) && !IsEmptySingleNestedAttribute(stateData.FvRsMldsn.Attributes()) {
		resp.Diagnostics.AddError(
			"FvRsMldsn object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))

	var fvAccPPlan, fvAccPState FvAccPFvBDResourceModel
	data.FvAccP.As(ctx, &fvAccPPlan, basetypes.ObjectAsOptions{})
	stateData.FvAccP.As(ctx, &fvAccPState, basetypes.ObjectAsOptions{})
	var fvRogueExceptionMacPlan, fvRogueExceptionMacState []FvRogueExceptionMacFvBDResourceModel
	data.FvRogueExceptionMac.ElementsAs(ctx, &fvRogueExceptionMacPlan, false)
	stateData.FvRogueExceptionMac.ElementsAs(ctx, &fvRogueExceptionMacState, false)
	var fvRsABDPolMonPolPlan, fvRsABDPolMonPolState FvRsABDPolMonPolFvBDResourceModel
	data.FvRsABDPolMonPol.As(ctx, &fvRsABDPolMonPolPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsABDPolMonPol.As(ctx, &fvRsABDPolMonPolState, basetypes.ObjectAsOptions{})
	var fvRsBDToFhsPlan, fvRsBDToFhsState FvRsBDToFhsFvBDResourceModel
	data.FvRsBDToFhs.As(ctx, &fvRsBDToFhsPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToFhs.As(ctx, &fvRsBDToFhsState, basetypes.ObjectAsOptions{})
	var fvRsBDToNdPPlan, fvRsBDToNdPState FvRsBDToNdPFvBDResourceModel
	data.FvRsBDToNdP.As(ctx, &fvRsBDToNdPPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToNdP.As(ctx, &fvRsBDToNdPState, basetypes.ObjectAsOptions{})
	var fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState []FvRsBDToNetflowMonitorPolFvBDResourceModel
	data.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &fvRsBDToNetflowMonitorPolPlan, false)
	stateData.FvRsBDToNetflowMonitorPol.ElementsAs(ctx, &fvRsBDToNetflowMonitorPolState, false)
	var fvRsBDToOutPlan, fvRsBDToOutState []FvRsBDToOutFvBDResourceModel
	data.FvRsBDToOut.ElementsAs(ctx, &fvRsBDToOutPlan, false)
	stateData.FvRsBDToOut.ElementsAs(ctx, &fvRsBDToOutState, false)
	var fvRsBDToProfilePlan, fvRsBDToProfileState FvRsBDToProfileFvBDResourceModel
	data.FvRsBDToProfile.As(ctx, &fvRsBDToProfilePlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToProfile.As(ctx, &fvRsBDToProfileState, basetypes.ObjectAsOptions{})
	var fvRsBDToRelayPPlan, fvRsBDToRelayPState FvRsBDToRelayPFvBDResourceModel
	data.FvRsBDToRelayP.As(ctx, &fvRsBDToRelayPPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBDToRelayP.As(ctx, &fvRsBDToRelayPState, basetypes.ObjectAsOptions{})
	var fvRsBdToEpRetPlan, fvRsBdToEpRetState FvRsBdToEpRetFvBDResourceModel
	data.FvRsBdToEpRet.As(ctx, &fvRsBdToEpRetPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsBdToEpRet.As(ctx, &fvRsBdToEpRetState, basetypes.ObjectAsOptions{})
	var fvRsCtxPlan, fvRsCtxState FvRsCtxFvBDResourceModel
	data.FvRsCtx.As(ctx, &fvRsCtxPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsCtx.As(ctx, &fvRsCtxState, basetypes.ObjectAsOptions{})
	var fvRsIgmpsnPlan, fvRsIgmpsnState FvRsIgmpsnFvBDResourceModel
	data.FvRsIgmpsn.As(ctx, &fvRsIgmpsnPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsIgmpsn.As(ctx, &fvRsIgmpsnState, basetypes.ObjectAsOptions{})
	var fvRsMldsnPlan, fvRsMldsnState FvRsMldsnFvBDResourceModel
	data.FvRsMldsn.As(ctx, &fvRsMldsnPlan, basetypes.ObjectAsOptions{})
	stateData.FvRsMldsn.As(ctx, &fvRsMldsnState, basetypes.ObjectAsOptions{})
	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvBDResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvBDResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getFvBDCreateJsonPayload(ctx, &resp.Diagnostics, false, data, fvAccPPlan, fvAccPState, fvRogueExceptionMacPlan, fvRogueExceptionMacState, fvRsABDPolMonPolPlan, fvRsABDPolMonPolState, fvRsBDToFhsPlan, fvRsBDToFhsState, fvRsBDToNdPPlan, fvRsBDToNdPState, fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState, fvRsBDToOutPlan, fvRsBDToOutState, fvRsBDToProfilePlan, fvRsBDToProfileState, fvRsBDToRelayPPlan, fvRsBDToRelayPState, fvRsBdToEpRetPlan, fvRsBdToEpRetState, fvRsCtxPlan, fvRsCtxState, fvRsIgmpsnPlan, fvRsIgmpsnState, fvRsMldsnPlan, fvRsMldsnState, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvBDAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvBDResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_bridge_domain")
	var data *FvBDResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "fvBD", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_bridge_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvBDResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_bridge_domain")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	var stateData *FvBDResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_bridge_domain with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_bridge_domain")
}

func getAndSetFvBDAttributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *FvBDResourceModel) {
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=children&rsp-subtree-class=%s", data.Id.ValueString(), "fvBD,fvAccP,fvRogueExceptionMac,fvRsABDPolMonPol,fvRsBDToFhs,fvRsBDToNdP,fvRsBDToNetflowMonitorPol,fvRsBDToOut,fvRsBDToProfile,fvRsBDToRelayP,fvRsBdToEpRet,fvRsCtx,fvRsIgmpsn,fvRsMldsn,tagAnnotation,tagTag"), "GET", nil)

	readData := getEmptyFvBDResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("fvBD").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("fvBD").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					readData.Id = basetypes.NewStringValue(attributeValue.(string))
					setFvBDParentDn(ctx, attributeValue.(string), readData)
				}
				if attributeName == "OptimizeWanBandwidth" {
					readData.OptimizeWanBandwidth = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "annotation" {
					readData.Annotation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "arpFlood" {
					readData.ArpFlood = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "descr" {
					readData.Descr = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "enableRogueExceptMac" {
					readData.EnableRogueExceptMac = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "epClear" {
					readData.EpClear = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "epMoveDetectMode" {
					readData.EpMoveDetectMode = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "hostBasedRouting" {
					readData.HostBasedRouting = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "intersiteBumTrafficAllow" {
					readData.IntersiteBumTrafficAllow = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "intersiteL2Stretch" {
					readData.IntersiteL2Stretch = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ipLearning" {
					readData.IpLearning = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ipv6McastAllow" {
					readData.Ipv6McastAllow = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "limitIpLearnToSubnets" {
					readData.LimitIpLearnToSubnets = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "llAddr" {
					readData.LlAddr = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "mac" {
					readData.Mac = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "mcastARPDrop" {
					readData.McastARPDrop = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "mcastAllow" {
					readData.McastAllow = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "multiDstPktAct" {
					readData.MultiDstPktAct = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "name" {
					readData.Name = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "nameAlias" {
					readData.NameAlias = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ownerKey" {
					readData.OwnerKey = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ownerTag" {
					readData.OwnerTag = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "type" {
					readData.Type = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "unicastRoute" {
					readData.UnicastRoute = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "unkMacUcastAct" {
					readData.UnkMacUcastAct = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "unkMcastAct" {
					readData.UnkMcastAct = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "v6unkMcastAct" {
					readData.V6unkMcastAct = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "vmac" {
					readData.Vmac = basetypes.NewStringValue(attributeValue.(string))
				}
			}
			FvAccPFvBDList := make([]FvAccPFvBDResourceModel, 0)
			FvRogueExceptionMacFvBDList := make([]FvRogueExceptionMacFvBDResourceModel, 0)
			FvRsABDPolMonPolFvBDList := make([]FvRsABDPolMonPolFvBDResourceModel, 0)
			FvRsBDToFhsFvBDList := make([]FvRsBDToFhsFvBDResourceModel, 0)
			FvRsBDToNdPFvBDList := make([]FvRsBDToNdPFvBDResourceModel, 0)
			FvRsBDToNetflowMonitorPolFvBDList := make([]FvRsBDToNetflowMonitorPolFvBDResourceModel, 0)
			FvRsBDToOutFvBDList := make([]FvRsBDToOutFvBDResourceModel, 0)
			FvRsBDToProfileFvBDList := make([]FvRsBDToProfileFvBDResourceModel, 0)
			FvRsBDToRelayPFvBDList := make([]FvRsBDToRelayPFvBDResourceModel, 0)
			FvRsBdToEpRetFvBDList := make([]FvRsBdToEpRetFvBDResourceModel, 0)
			FvRsCtxFvBDList := make([]FvRsCtxFvBDResourceModel, 0)
			FvRsIgmpsnFvBDList := make([]FvRsIgmpsnFvBDResourceModel, 0)
			FvRsMldsnFvBDList := make([]FvRsMldsnFvBDResourceModel, 0)
			TagAnnotationFvBDList := make([]TagAnnotationFvBDResourceModel, 0)
			TagTagFvBDList := make([]TagTagFvBDResourceModel, 0)
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						if childClassName == "fvAccP" {
							FvAccPFvBD := getEmptyFvAccPFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvAccPFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvAccPFvBD.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "encap" {
									FvAccPFvBD.Encap = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "name" {
									FvAccPFvBD.Name = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "nameAlias" {
									FvAccPFvBD.NameAlias = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ownerKey" {
									FvAccPFvBD.OwnerKey = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "ownerTag" {
									FvAccPFvBD.OwnerTag = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvAccPFvBDList = append(FvAccPFvBDList, FvAccPFvBD)
						}
						if childClassName == "fvRogueExceptionMac" {
							FvRogueExceptionMacFvBD := getEmptyFvRogueExceptionMacFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRogueExceptionMacFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "descr" {
									FvRogueExceptionMacFvBD.Descr = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "mac" {
									FvRogueExceptionMacFvBD.Mac = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "name" {
									FvRogueExceptionMacFvBD.Name = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "nameAlias" {
									FvRogueExceptionMacFvBD.NameAlias = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRogueExceptionMacFvBDList = append(FvRogueExceptionMacFvBDList, FvRogueExceptionMacFvBD)
						}
						if childClassName == "fvRsABDPolMonPol" {
							FvRsABDPolMonPolFvBD := getEmptyFvRsABDPolMonPolFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsABDPolMonPolFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnMonEPGPolName" {
									FvRsABDPolMonPolFvBD.TnMonEPGPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsABDPolMonPolFvBDList = append(FvRsABDPolMonPolFvBDList, FvRsABDPolMonPolFvBD)
						}
						if childClassName == "fvRsBDToFhs" {
							FvRsBDToFhsFvBD := getEmptyFvRsBDToFhsFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToFhsFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnFhsBDPolName" {
									FvRsBDToFhsFvBD.TnFhsBDPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToFhsFvBDList = append(FvRsBDToFhsFvBDList, FvRsBDToFhsFvBD)
						}
						if childClassName == "fvRsBDToNdP" {
							FvRsBDToNdPFvBD := getEmptyFvRsBDToNdPFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToNdPFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnNdIfPolName" {
									FvRsBDToNdPFvBD.TnNdIfPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToNdPFvBDList = append(FvRsBDToNdPFvBDList, FvRsBDToNdPFvBD)
						}
						if childClassName == "fvRsBDToNetflowMonitorPol" {
							FvRsBDToNetflowMonitorPolFvBD := getEmptyFvRsBDToNetflowMonitorPolFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToNetflowMonitorPolFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "fltType" {
									FvRsBDToNetflowMonitorPolFvBD.FltType = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnNetflowMonitorPolName" {
									FvRsBDToNetflowMonitorPolFvBD.TnNetflowMonitorPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToNetflowMonitorPolFvBDList = append(FvRsBDToNetflowMonitorPolFvBDList, FvRsBDToNetflowMonitorPolFvBD)
						}
						if childClassName == "fvRsBDToOut" {
							FvRsBDToOutFvBD := getEmptyFvRsBDToOutFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToOutFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnL3extOutName" {
									FvRsBDToOutFvBD.TnL3extOutName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToOutFvBDList = append(FvRsBDToOutFvBDList, FvRsBDToOutFvBD)
						}
						if childClassName == "fvRsBDToProfile" {
							FvRsBDToProfileFvBD := getEmptyFvRsBDToProfileFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToProfileFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnL3extOutName" {
									FvRsBDToProfileFvBD.TnL3extOutName = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnRtctrlProfileName" {
									FvRsBDToProfileFvBD.TnRtctrlProfileName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToProfileFvBDList = append(FvRsBDToProfileFvBDList, FvRsBDToProfileFvBD)
						}
						if childClassName == "fvRsBDToRelayP" {
							FvRsBDToRelayPFvBD := getEmptyFvRsBDToRelayPFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBDToRelayPFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnDhcpRelayPName" {
									FvRsBDToRelayPFvBD.TnDhcpRelayPName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBDToRelayPFvBDList = append(FvRsBDToRelayPFvBDList, FvRsBDToRelayPFvBD)
						}
						if childClassName == "fvRsBdToEpRet" {
							FvRsBdToEpRetFvBD := getEmptyFvRsBdToEpRetFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsBdToEpRetFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "resolveAct" {
									FvRsBdToEpRetFvBD.ResolveAct = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnFvEpRetPolName" {
									FvRsBdToEpRetFvBD.TnFvEpRetPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsBdToEpRetFvBDList = append(FvRsBdToEpRetFvBDList, FvRsBdToEpRetFvBD)
						}
						if childClassName == "fvRsCtx" {
							FvRsCtxFvBD := getEmptyFvRsCtxFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsCtxFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnFvCtxName" {
									FvRsCtxFvBD.TnFvCtxName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsCtxFvBDList = append(FvRsCtxFvBDList, FvRsCtxFvBD)
						}
						if childClassName == "fvRsIgmpsn" {
							FvRsIgmpsnFvBD := getEmptyFvRsIgmpsnFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsIgmpsnFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnIgmpSnoopPolName" {
									FvRsIgmpsnFvBD.TnIgmpSnoopPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsIgmpsnFvBDList = append(FvRsIgmpsnFvBDList, FvRsIgmpsnFvBD)
						}
						if childClassName == "fvRsMldsn" {
							FvRsMldsnFvBD := getEmptyFvRsMldsnFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "annotation" {
									FvRsMldsnFvBD.Annotation = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "tnMldSnoopPolName" {
									FvRsMldsnFvBD.TnMldSnoopPolName = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							FvRsMldsnFvBDList = append(FvRsMldsnFvBDList, FvRsMldsnFvBD)
						}
						if childClassName == "tagAnnotation" {
							TagAnnotationFvBD := getEmptyTagAnnotationFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagAnnotationFvBD.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagAnnotationFvBD.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagAnnotationFvBDList = append(TagAnnotationFvBDList, TagAnnotationFvBD)
						}
						if childClassName == "tagTag" {
							TagTagFvBD := getEmptyTagTagFvBDResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagTagFvBD.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagTagFvBD.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagTagFvBDList = append(TagTagFvBDList, TagTagFvBD)
						}
					}
				}
			}
			if len(FvAccPFvBDList) == 1 {
				fvAccPObject, _ := types.ObjectValueFrom(ctx, FvAccPFvBDType, FvAccPFvBDList[0])
				readData.FvAccP = fvAccPObject
			} else {
				fvAccPObject, _ := types.ObjectValueFrom(ctx, FvAccPFvBDType, getEmptyFvAccPFvBDResourceModel())
				readData.FvAccP = fvAccPObject
			}
			fvRogueExceptionMacSet, _ := types.SetValueFrom(ctx, readData.FvRogueExceptionMac.ElementType(ctx), FvRogueExceptionMacFvBDList)
			readData.FvRogueExceptionMac = fvRogueExceptionMacSet
			if len(FvRsABDPolMonPolFvBDList) == 1 {
				fvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, FvRsABDPolMonPolFvBDList[0])
				readData.FvRsABDPolMonPol = fvRsABDPolMonPolObject
			} else {
				fvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, getEmptyFvRsABDPolMonPolFvBDResourceModel())
				readData.FvRsABDPolMonPol = fvRsABDPolMonPolObject
			}
			if len(FvRsBDToFhsFvBDList) == 1 {
				fvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, FvRsBDToFhsFvBDList[0])
				readData.FvRsBDToFhs = fvRsBDToFhsObject
			} else {
				fvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, getEmptyFvRsBDToFhsFvBDResourceModel())
				readData.FvRsBDToFhs = fvRsBDToFhsObject
			}
			if len(FvRsBDToNdPFvBDList) == 1 {
				fvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, FvRsBDToNdPFvBDList[0])
				readData.FvRsBDToNdP = fvRsBDToNdPObject
			} else {
				fvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, getEmptyFvRsBDToNdPFvBDResourceModel())
				readData.FvRsBDToNdP = fvRsBDToNdPObject
			}
			fvRsBDToNetflowMonitorPolSet, _ := types.SetValueFrom(ctx, readData.FvRsBDToNetflowMonitorPol.ElementType(ctx), FvRsBDToNetflowMonitorPolFvBDList)
			readData.FvRsBDToNetflowMonitorPol = fvRsBDToNetflowMonitorPolSet
			fvRsBDToOutSet, _ := types.SetValueFrom(ctx, readData.FvRsBDToOut.ElementType(ctx), FvRsBDToOutFvBDList)
			readData.FvRsBDToOut = fvRsBDToOutSet
			if len(FvRsBDToProfileFvBDList) == 1 {
				fvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, FvRsBDToProfileFvBDList[0])
				readData.FvRsBDToProfile = fvRsBDToProfileObject
			} else {
				fvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, getEmptyFvRsBDToProfileFvBDResourceModel())
				readData.FvRsBDToProfile = fvRsBDToProfileObject
			}
			if len(FvRsBDToRelayPFvBDList) == 1 {
				fvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, FvRsBDToRelayPFvBDList[0])
				readData.FvRsBDToRelayP = fvRsBDToRelayPObject
			} else {
				fvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, getEmptyFvRsBDToRelayPFvBDResourceModel())
				readData.FvRsBDToRelayP = fvRsBDToRelayPObject
			}
			if len(FvRsBdToEpRetFvBDList) == 1 {
				fvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, FvRsBdToEpRetFvBDList[0])
				readData.FvRsBdToEpRet = fvRsBdToEpRetObject
			} else {
				fvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, getEmptyFvRsBdToEpRetFvBDResourceModel())
				readData.FvRsBdToEpRet = fvRsBdToEpRetObject
			}
			if len(FvRsCtxFvBDList) == 1 {
				fvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, FvRsCtxFvBDList[0])
				readData.FvRsCtx = fvRsCtxObject
			} else {
				fvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, getEmptyFvRsCtxFvBDResourceModel())
				readData.FvRsCtx = fvRsCtxObject
			}
			if len(FvRsIgmpsnFvBDList) == 1 {
				fvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, FvRsIgmpsnFvBDList[0])
				readData.FvRsIgmpsn = fvRsIgmpsnObject
			} else {
				fvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, getEmptyFvRsIgmpsnFvBDResourceModel())
				readData.FvRsIgmpsn = fvRsIgmpsnObject
			}
			if len(FvRsMldsnFvBDList) == 1 {
				fvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, FvRsMldsnFvBDList[0])
				readData.FvRsMldsn = fvRsMldsnObject
			} else {
				fvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, getEmptyFvRsMldsnFvBDResourceModel())
				readData.FvRsMldsn = fvRsMldsnObject
			}
			tagAnnotationSet, _ := types.SetValueFrom(ctx, readData.TagAnnotation.ElementType(ctx), TagAnnotationFvBDList)
			readData.TagAnnotation = tagAnnotationSet
			tagTagSet, _ := types.SetValueFrom(ctx, readData.TagTag.ElementType(ctx), TagTagFvBDList)
			readData.TagTag = tagTagSet
			setFvBDLegacyAttributes(ctx, diags, readData, data, classReadInfo)
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class 'fvBD'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		readData.Id = basetypes.NewStringNull()
	}
	*data = *readData
}

func getFvBDRn(ctx context.Context, data *FvBDResourceModel) string {
	rn := "BD-{name}"
	for _, identifier := range []string{"name"} {
		fieldName := fmt.Sprintf("%s%s", strings.ToUpper(identifier[:1]), identifier[1:])
		fieldValue := reflect.ValueOf(data).Elem().FieldByName(fieldName).Interface().(basetypes.StringValue).ValueString()
		rn = strings.ReplaceAll(rn, fmt.Sprintf("{%s}", identifier), fieldValue)
	}
	return rn
}

func setFvBDParentDn(ctx context.Context, dn string, data *FvBDResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
}

func setFvBDId(ctx context.Context, data *FvBDResourceModel) {
	rn := getFvBDRn(ctx, data)
	data.Id = types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
}

func getFvBDFvAccPChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvAccPPlan, fvAccPState FvAccPFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvAccP.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvAccP.Attributes()) {
			if !fvAccPPlan.Annotation.IsUnknown() && !fvAccPPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvAccPPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvAccPPlan.Descr.IsUnknown() && !fvAccPPlan.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvAccPPlan.Descr.ValueString()
			}
			if !fvAccPPlan.Encap.IsUnknown() && !fvAccPPlan.Encap.IsNull() {
				childMap["attributes"]["encap"] = fvAccPPlan.Encap.ValueString()
			}
			if !fvAccPPlan.Name.IsUnknown() && !fvAccPPlan.Name.IsNull() {
				childMap["attributes"]["name"] = fvAccPPlan.Name.ValueString()
			}
			if !fvAccPPlan.NameAlias.IsUnknown() && !fvAccPPlan.NameAlias.IsNull() {
				childMap["attributes"]["nameAlias"] = fvAccPPlan.NameAlias.ValueString()
			}
			if !fvAccPPlan.OwnerKey.IsUnknown() && !fvAccPPlan.OwnerKey.IsNull() {
				childMap["attributes"]["ownerKey"] = fvAccPPlan.OwnerKey.ValueString()
			}
			if !fvAccPPlan.OwnerTag.IsUnknown() && !fvAccPPlan.OwnerTag.IsNull() {
				childMap["attributes"]["ownerTag"] = fvAccPPlan.OwnerTag.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvAccP": childMap})
	} else {
		FvAccPObject, _ := types.ObjectValueFrom(ctx, FvAccPFvBDType, getEmptyFvAccPFvBDResourceModel())
		data.FvAccP = FvAccPObject
	}

	return childPayloads
}
func getFvBDFvRogueExceptionMacChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRogueExceptionMacPlan, fvRogueExceptionMacState []FvRogueExceptionMacFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRogueExceptionMac.IsUnknown() {
		fvRogueExceptionMacIdentifiers := []FvRogueExceptionMacIdentifier{}
		for _, fvRogueExceptionMac := range fvRogueExceptionMacPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRogueExceptionMac.Annotation.IsUnknown() && !fvRogueExceptionMac.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRogueExceptionMac.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRogueExceptionMac.Descr.IsUnknown() && !fvRogueExceptionMac.Descr.IsNull() {
				childMap["attributes"]["descr"] = fvRogueExceptionMac.Descr.ValueString()
			}
			if !fvRogueExceptionMac.Mac.IsUnknown() && !fvRogueExceptionMac.Mac.IsNull() {
				childMap["attributes"]["mac"] = fvRogueExceptionMac.Mac.ValueString()
			}
			if !fvRogueExceptionMac.Name.IsUnknown() && !fvRogueExceptionMac.Name.IsNull() {
				childMap["attributes"]["name"] = fvRogueExceptionMac.Name.ValueString()
			}
			if !fvRogueExceptionMac.NameAlias.IsUnknown() && !fvRogueExceptionMac.NameAlias.IsNull() {
				childMap["attributes"]["nameAlias"] = fvRogueExceptionMac.NameAlias.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRogueExceptionMac": childMap})
			fvRogueExceptionMacIdentifier := FvRogueExceptionMacIdentifier{}
			fvRogueExceptionMacIdentifier.Mac = fvRogueExceptionMac.Mac
			fvRogueExceptionMacIdentifiers = append(fvRogueExceptionMacIdentifiers, fvRogueExceptionMacIdentifier)
		}
		for _, fvRogueExceptionMac := range fvRogueExceptionMacState {
			delete := true
			for _, fvRogueExceptionMacIdentifier := range fvRogueExceptionMacIdentifiers {
				if fvRogueExceptionMacIdentifier.Mac == fvRogueExceptionMac.Mac {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["mac"] = fvRogueExceptionMac.Mac.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRogueExceptionMac": childMap})
			}
		}
	} else {
		data.FvRogueExceptionMac = types.SetNull(data.FvRogueExceptionMac.ElementType(ctx))
	}

	return childPayloads
}
func getFvBDFvRsABDPolMonPolChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsABDPolMonPolPlan, fvRsABDPolMonPolState FvRsABDPolMonPolFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsABDPolMonPol.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsABDPolMonPol.Attributes()) {
			if !fvRsABDPolMonPolPlan.Annotation.IsUnknown() && !fvRsABDPolMonPolPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsABDPolMonPolPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsABDPolMonPolPlan.TnMonEPGPolName.IsUnknown() && !fvRsABDPolMonPolPlan.TnMonEPGPolName.IsNull() {
				childMap["attributes"]["tnMonEPGPolName"] = fvRsABDPolMonPolPlan.TnMonEPGPolName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsABDPolMonPol": childMap})
	} else {
		FvRsABDPolMonPolObject, _ := types.ObjectValueFrom(ctx, FvRsABDPolMonPolFvBDType, getEmptyFvRsABDPolMonPolFvBDResourceModel())
		data.FvRsABDPolMonPol = FvRsABDPolMonPolObject
	}

	return childPayloads
}
func getFvBDFvRsBDToFhsChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToFhsPlan, fvRsBDToFhsState FvRsBDToFhsFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToFhs.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBDToFhs.Attributes()) {
			if !fvRsBDToFhsPlan.Annotation.IsUnknown() && !fvRsBDToFhsPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToFhsPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToFhsPlan.TnFhsBDPolName.IsUnknown() && !fvRsBDToFhsPlan.TnFhsBDPolName.IsNull() {
				childMap["attributes"]["tnFhsBDPolName"] = fvRsBDToFhsPlan.TnFhsBDPolName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToFhs": childMap})
	} else {
		FvRsBDToFhsObject, _ := types.ObjectValueFrom(ctx, FvRsBDToFhsFvBDType, getEmptyFvRsBDToFhsFvBDResourceModel())
		data.FvRsBDToFhs = FvRsBDToFhsObject
	}

	return childPayloads
}
func getFvBDFvRsBDToNdPChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToNdPPlan, fvRsBDToNdPState FvRsBDToNdPFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToNdP.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBDToNdP.Attributes()) {
			if !fvRsBDToNdPPlan.Annotation.IsUnknown() && !fvRsBDToNdPPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToNdPPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToNdPPlan.TnNdIfPolName.IsUnknown() && !fvRsBDToNdPPlan.TnNdIfPolName.IsNull() {
				childMap["attributes"]["tnNdIfPolName"] = fvRsBDToNdPPlan.TnNdIfPolName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToNdP": childMap})
	} else {
		FvRsBDToNdPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToNdPFvBDType, getEmptyFvRsBDToNdPFvBDResourceModel())
		data.FvRsBDToNdP = FvRsBDToNdPObject
	}

	return childPayloads
}
func getFvBDFvRsBDToNetflowMonitorPolChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState []FvRsBDToNetflowMonitorPolFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToNetflowMonitorPol.IsUnknown() {
		fvRsBDToNetflowMonitorPolIdentifiers := []FvRsBDToNetflowMonitorPolIdentifier{}
		for _, fvRsBDToNetflowMonitorPol := range fvRsBDToNetflowMonitorPolPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsBDToNetflowMonitorPol.Annotation.IsUnknown() && !fvRsBDToNetflowMonitorPol.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToNetflowMonitorPol.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToNetflowMonitorPol.FltType.IsUnknown() && !fvRsBDToNetflowMonitorPol.FltType.IsNull() {
				childMap["attributes"]["fltType"] = fvRsBDToNetflowMonitorPol.FltType.ValueString()
			}
			if !fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName.IsUnknown() && !fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName.IsNull() {
				childMap["attributes"]["tnNetflowMonitorPolName"] = fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToNetflowMonitorPol": childMap})
			fvRsBDToNetflowMonitorPolIdentifier := FvRsBDToNetflowMonitorPolIdentifier{}
			fvRsBDToNetflowMonitorPolIdentifier.FltType = fvRsBDToNetflowMonitorPol.FltType
			fvRsBDToNetflowMonitorPolIdentifier.TnNetflowMonitorPolName = fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName
			fvRsBDToNetflowMonitorPolIdentifiers = append(fvRsBDToNetflowMonitorPolIdentifiers, fvRsBDToNetflowMonitorPolIdentifier)
		}
		for _, fvRsBDToNetflowMonitorPol := range fvRsBDToNetflowMonitorPolState {
			delete := true
			for _, fvRsBDToNetflowMonitorPolIdentifier := range fvRsBDToNetflowMonitorPolIdentifiers {
				if fvRsBDToNetflowMonitorPolIdentifier.FltType == fvRsBDToNetflowMonitorPol.FltType &&
					fvRsBDToNetflowMonitorPolIdentifier.TnNetflowMonitorPolName == fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["fltType"] = fvRsBDToNetflowMonitorPol.FltType.ValueString()
				childMap["attributes"]["tnNetflowMonitorPolName"] = fvRsBDToNetflowMonitorPol.TnNetflowMonitorPolName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToNetflowMonitorPol": childMap})
			}
		}
	} else {
		data.FvRsBDToNetflowMonitorPol = types.SetNull(data.FvRsBDToNetflowMonitorPol.ElementType(ctx))
	}

	return childPayloads
}
func getFvBDFvRsBDToOutChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToOutPlan, fvRsBDToOutState []FvRsBDToOutFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToOut.IsUnknown() {
		fvRsBDToOutIdentifiers := []FvRsBDToOutIdentifier{}
		for _, fvRsBDToOut := range fvRsBDToOutPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !fvRsBDToOut.Annotation.IsUnknown() && !fvRsBDToOut.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToOut.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToOut.TnL3extOutName.IsUnknown() && !fvRsBDToOut.TnL3extOutName.IsNull() {
				childMap["attributes"]["tnL3extOutName"] = fvRsBDToOut.TnL3extOutName.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToOut": childMap})
			fvRsBDToOutIdentifier := FvRsBDToOutIdentifier{}
			fvRsBDToOutIdentifier.TnL3extOutName = fvRsBDToOut.TnL3extOutName
			fvRsBDToOutIdentifiers = append(fvRsBDToOutIdentifiers, fvRsBDToOutIdentifier)
		}
		for _, fvRsBDToOut := range fvRsBDToOutState {
			delete := true
			for _, fvRsBDToOutIdentifier := range fvRsBDToOutIdentifiers {
				if fvRsBDToOutIdentifier.TnL3extOutName == fvRsBDToOut.TnL3extOutName {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["tnL3extOutName"] = fvRsBDToOut.TnL3extOutName.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToOut": childMap})
			}
		}
	} else {
		data.FvRsBDToOut = types.SetNull(data.FvRsBDToOut.ElementType(ctx))
	}

	return childPayloads
}
func getFvBDFvRsBDToProfileChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToProfilePlan, fvRsBDToProfileState FvRsBDToProfileFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToProfile.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBDToProfile.Attributes()) {
			if !fvRsBDToProfilePlan.Annotation.IsUnknown() && !fvRsBDToProfilePlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToProfilePlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToProfilePlan.TnL3extOutName.IsUnknown() && !fvRsBDToProfilePlan.TnL3extOutName.IsNull() {
				childMap["attributes"]["tnL3extOutName"] = fvRsBDToProfilePlan.TnL3extOutName.ValueString()
			}
			if !fvRsBDToProfilePlan.TnRtctrlProfileName.IsUnknown() && !fvRsBDToProfilePlan.TnRtctrlProfileName.IsNull() {
				childMap["attributes"]["tnRtctrlProfileName"] = fvRsBDToProfilePlan.TnRtctrlProfileName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToProfile": childMap})
	} else {
		FvRsBDToProfileObject, _ := types.ObjectValueFrom(ctx, FvRsBDToProfileFvBDType, getEmptyFvRsBDToProfileFvBDResourceModel())
		data.FvRsBDToProfile = FvRsBDToProfileObject
	}

	return childPayloads
}
func getFvBDFvRsBDToRelayPChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBDToRelayPPlan, fvRsBDToRelayPState FvRsBDToRelayPFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBDToRelayP.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBDToRelayP.Attributes()) {
			if !fvRsBDToRelayPPlan.Annotation.IsUnknown() && !fvRsBDToRelayPPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBDToRelayPPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBDToRelayPPlan.TnDhcpRelayPName.IsUnknown() && !fvRsBDToRelayPPlan.TnDhcpRelayPName.IsNull() {
				childMap["attributes"]["tnDhcpRelayPName"] = fvRsBDToRelayPPlan.TnDhcpRelayPName.ValueString()
			}
		} else {
			childMap["attributes"]["status"] = "deleted"
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBDToRelayP": childMap})
	} else {
		FvRsBDToRelayPObject, _ := types.ObjectValueFrom(ctx, FvRsBDToRelayPFvBDType, getEmptyFvRsBDToRelayPFvBDResourceModel())
		data.FvRsBDToRelayP = FvRsBDToRelayPObject
	}

	return childPayloads
}
func getFvBDFvRsBdToEpRetChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsBdToEpRetPlan, fvRsBdToEpRetState FvRsBdToEpRetFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsBdToEpRet.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsBdToEpRet.Attributes()) {
			if !fvRsBdToEpRetPlan.Annotation.IsUnknown() && !fvRsBdToEpRetPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsBdToEpRetPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsBdToEpRetPlan.ResolveAct.IsUnknown() && !fvRsBdToEpRetPlan.ResolveAct.IsNull() {
				childMap["attributes"]["resolveAct"] = fvRsBdToEpRetPlan.ResolveAct.ValueString()
			}
			if !fvRsBdToEpRetPlan.TnFvEpRetPolName.IsUnknown() && !fvRsBdToEpRetPlan.TnFvEpRetPolName.IsNull() {
				childMap["attributes"]["tnFvEpRetPolName"] = fvRsBdToEpRetPlan.TnFvEpRetPolName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsBdToEpRet": childMap})
	} else {
		FvRsBdToEpRetObject, _ := types.ObjectValueFrom(ctx, FvRsBdToEpRetFvBDType, getEmptyFvRsBdToEpRetFvBDResourceModel())
		data.FvRsBdToEpRet = FvRsBdToEpRetObject
	}

	return childPayloads
}
func getFvBDFvRsCtxChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsCtxPlan, fvRsCtxState FvRsCtxFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsCtx.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsCtx.Attributes()) {
			if !fvRsCtxPlan.Annotation.IsUnknown() && !fvRsCtxPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsCtxPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsCtxPlan.TnFvCtxName.IsUnknown() && !fvRsCtxPlan.TnFvCtxName.IsNull() {
				childMap["attributes"]["tnFvCtxName"] = fvRsCtxPlan.TnFvCtxName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsCtx": childMap})
	} else {
		FvRsCtxObject, _ := types.ObjectValueFrom(ctx, FvRsCtxFvBDType, getEmptyFvRsCtxFvBDResourceModel())
		data.FvRsCtx = FvRsCtxObject
	}

	return childPayloads
}
func getFvBDFvRsIgmpsnChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsIgmpsnPlan, fvRsIgmpsnState FvRsIgmpsnFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsIgmpsn.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsIgmpsn.Attributes()) {
			if !fvRsIgmpsnPlan.Annotation.IsUnknown() && !fvRsIgmpsnPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsIgmpsnPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsIgmpsnPlan.TnIgmpSnoopPolName.IsUnknown() && !fvRsIgmpsnPlan.TnIgmpSnoopPolName.IsNull() {
				childMap["attributes"]["tnIgmpSnoopPolName"] = fvRsIgmpsnPlan.TnIgmpSnoopPolName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsIgmpsn": childMap})
	} else {
		FvRsIgmpsnObject, _ := types.ObjectValueFrom(ctx, FvRsIgmpsnFvBDType, getEmptyFvRsIgmpsnFvBDResourceModel())
		data.FvRsIgmpsn = FvRsIgmpsnObject
	}

	return childPayloads
}
func getFvBDFvRsMldsnChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, fvRsMldsnPlan, fvRsMldsnState FvRsMldsnFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.FvRsMldsn.IsUnknown() {
		childMap := map[string]map[string]interface{}{"attributes": {}}
		if !IsEmptySingleNestedAttribute(data.FvRsMldsn.Attributes()) {
			if !fvRsMldsnPlan.Annotation.IsUnknown() && !fvRsMldsnPlan.Annotation.IsNull() {
				childMap["attributes"]["annotation"] = fvRsMldsnPlan.Annotation.ValueString()
			} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			}
			if !fvRsMldsnPlan.TnMldSnoopPolName.IsUnknown() && !fvRsMldsnPlan.TnMldSnoopPolName.IsNull() {
				childMap["attributes"]["tnMldSnoopPolName"] = fvRsMldsnPlan.TnMldSnoopPolName.ValueString()
			}
		}
		childPayloads = append(childPayloads, map[string]interface{}{"fvRsMldsn": childMap})
	} else {
		FvRsMldsnObject, _ := types.ObjectValueFrom(ctx, FvRsMldsnFvBDType, getEmptyFvRsMldsnFvBDResourceModel())
		data.FvRsMldsn = FvRsMldsnObject
	}

	return childPayloads
}
func getFvBDTagAnnotationChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagAnnotation.IsUnknown() {
		tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
		for _, tagAnnotation := range tagAnnotationPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagAnnotation.Key.IsUnknown() && !tagAnnotation.Key.IsNull() {
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
			}
			if !tagAnnotation.Value.IsUnknown() && !tagAnnotation.Value.IsNull() {
				childMap["attributes"]["value"] = tagAnnotation.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			tagAnnotationIdentifier := TagAnnotationIdentifier{}
			tagAnnotationIdentifier.Key = tagAnnotation.Key
			tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
		}
		for _, tagAnnotation := range tagAnnotationState {
			delete := true
			for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
				if tagAnnotationIdentifier.Key == tagAnnotation.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			}
		}
	} else {
		data.TagAnnotation = types.SetNull(data.TagAnnotation.ElementType(ctx))
	}

	return childPayloads
}
func getFvBDTagTagChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvBDResourceModel, tagTagPlan, tagTagState []TagTagFvBDResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagTag.IsUnknown() {
		tagTagIdentifiers := []TagTagIdentifier{}
		for _, tagTag := range tagTagPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagTag.Key.IsUnknown() && !tagTag.Key.IsNull() {
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
			}
			if !tagTag.Value.IsUnknown() && !tagTag.Value.IsNull() {
				childMap["attributes"]["value"] = tagTag.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			tagTagIdentifier := TagTagIdentifier{}
			tagTagIdentifier.Key = tagTag.Key
			tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
		}
		for _, tagTag := range tagTagState {
			delete := true
			for _, tagTagIdentifier := range tagTagIdentifiers {
				if tagTagIdentifier.Key == tagTag.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			}
		}
	} else {
		data.TagTag = types.SetNull(data.TagTag.ElementType(ctx))
	}

	return childPayloads
}

func getFvBDCreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *FvBDResourceModel, fvAccPPlan, fvAccPState FvAccPFvBDResourceModel, fvRogueExceptionMacPlan, fvRogueExceptionMacState []FvRogueExceptionMacFvBDResourceModel, fvRsABDPolMonPolPlan, fvRsABDPolMonPolState FvRsABDPolMonPolFvBDResourceModel, fvRsBDToFhsPlan, fvRsBDToFhsState FvRsBDToFhsFvBDResourceModel, fvRsBDToNdPPlan, fvRsBDToNdPState FvRsBDToNdPFvBDResourceModel, fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState []FvRsBDToNetflowMonitorPolFvBDResourceModel, fvRsBDToOutPlan, fvRsBDToOutState []FvRsBDToOutFvBDResourceModel, fvRsBDToProfilePlan, fvRsBDToProfileState FvRsBDToProfileFvBDResourceModel, fvRsBDToRelayPPlan, fvRsBDToRelayPState FvRsBDToRelayPFvBDResourceModel, fvRsBdToEpRetPlan, fvRsBdToEpRetState FvRsBdToEpRetFvBDResourceModel, fvRsCtxPlan, fvRsCtxState FvRsCtxFvBDResourceModel, fvRsIgmpsnPlan, fvRsIgmpsnState FvRsIgmpsnFvBDResourceModel, fvRsMldsnPlan, fvRsMldsnState FvRsMldsnFvBDResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvBDResourceModel, tagTagPlan, tagTagState []TagTagFvBDResourceModel) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}
	childPayloads := []map[string]interface{}{}

	FvAccPchildPayloads := getFvBDFvAccPChildPayloads(ctx, diags, data, fvAccPPlan, fvAccPState)
	if FvAccPchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvAccPchildPayloads...)

	FvRogueExceptionMacchildPayloads := getFvBDFvRogueExceptionMacChildPayloads(ctx, diags, data, fvRogueExceptionMacPlan, fvRogueExceptionMacState)
	if FvRogueExceptionMacchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRogueExceptionMacchildPayloads...)

	FvRsABDPolMonPolchildPayloads := getFvBDFvRsABDPolMonPolChildPayloads(ctx, diags, data, fvRsABDPolMonPolPlan, fvRsABDPolMonPolState)
	if FvRsABDPolMonPolchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsABDPolMonPolchildPayloads...)

	FvRsBDToFhschildPayloads := getFvBDFvRsBDToFhsChildPayloads(ctx, diags, data, fvRsBDToFhsPlan, fvRsBDToFhsState)
	if FvRsBDToFhschildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToFhschildPayloads...)

	FvRsBDToNdPchildPayloads := getFvBDFvRsBDToNdPChildPayloads(ctx, diags, data, fvRsBDToNdPPlan, fvRsBDToNdPState)
	if FvRsBDToNdPchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToNdPchildPayloads...)

	FvRsBDToNetflowMonitorPolchildPayloads := getFvBDFvRsBDToNetflowMonitorPolChildPayloads(ctx, diags, data, fvRsBDToNetflowMonitorPolPlan, fvRsBDToNetflowMonitorPolState)
	if FvRsBDToNetflowMonitorPolchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToNetflowMonitorPolchildPayloads...)

	FvRsBDToOutchildPayloads := getFvBDFvRsBDToOutChildPayloads(ctx, diags, data, fvRsBDToOutPlan, fvRsBDToOutState)
	if FvRsBDToOutchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToOutchildPayloads...)

	FvRsBDToProfilechildPayloads := getFvBDFvRsBDToProfileChildPayloads(ctx, diags, data, fvRsBDToProfilePlan, fvRsBDToProfileState)
	if FvRsBDToProfilechildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToProfilechildPayloads...)

	FvRsBDToRelayPchildPayloads := getFvBDFvRsBDToRelayPChildPayloads(ctx, diags, data, fvRsBDToRelayPPlan, fvRsBDToRelayPState)
	if FvRsBDToRelayPchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBDToRelayPchildPayloads...)

	FvRsBdToEpRetchildPayloads := getFvBDFvRsBdToEpRetChildPayloads(ctx, diags, data, fvRsBdToEpRetPlan, fvRsBdToEpRetState)
	if FvRsBdToEpRetchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsBdToEpRetchildPayloads...)

	FvRsCtxchildPayloads := getFvBDFvRsCtxChildPayloads(ctx, diags, data, fvRsCtxPlan, fvRsCtxState)
	if FvRsCtxchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsCtxchildPayloads...)

	FvRsIgmpsnchildPayloads := getFvBDFvRsIgmpsnChildPayloads(ctx, diags, data, fvRsIgmpsnPlan, fvRsIgmpsnState)
	if FvRsIgmpsnchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsIgmpsnchildPayloads...)

	FvRsMldsnchildPayloads := getFvBDFvRsMldsnChildPayloads(ctx, diags, data, fvRsMldsnPlan, fvRsMldsnState)
	if FvRsMldsnchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, FvRsMldsnchildPayloads...)

	TagAnnotationchildPayloads := getFvBDTagAnnotationChildPayloads(ctx, diags, data, tagAnnotationPlan, tagAnnotationState)
	if TagAnnotationchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagAnnotationchildPayloads...)

	TagTagchildPayloads := getFvBDTagTagChildPayloads(ctx, diags, data, tagTagPlan, tagTagState)
	if TagTagchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagTagchildPayloads...)

	payloadMap["children"] = childPayloads
	if !data.OptimizeWanBandwidth.IsNull() && !data.OptimizeWanBandwidth.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["OptimizeWanBandwidth"] = data.OptimizeWanBandwidth.ValueString()
	}
	if !data.Annotation.IsNull() && !data.Annotation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["annotation"] = data.Annotation.ValueString()
	}
	if !data.ArpFlood.IsNull() && !data.ArpFlood.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["arpFlood"] = data.ArpFlood.ValueString()
	}
	if !data.Descr.IsNull() && !data.Descr.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["descr"] = data.Descr.ValueString()
	}
	if !data.EnableRogueExceptMac.IsNull() && !data.EnableRogueExceptMac.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["enableRogueExceptMac"] = data.EnableRogueExceptMac.ValueString()
	}
	if !data.EpClear.IsNull() && !data.EpClear.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["epClear"] = data.EpClear.ValueString()
	}
	if !data.EpMoveDetectMode.IsNull() && !data.EpMoveDetectMode.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["epMoveDetectMode"] = data.EpMoveDetectMode.ValueString()
	}
	if !data.HostBasedRouting.IsNull() && !data.HostBasedRouting.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["hostBasedRouting"] = data.HostBasedRouting.ValueString()
	}
	if !data.IntersiteBumTrafficAllow.IsNull() && !data.IntersiteBumTrafficAllow.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["intersiteBumTrafficAllow"] = data.IntersiteBumTrafficAllow.ValueString()
	}
	if !data.IntersiteL2Stretch.IsNull() && !data.IntersiteL2Stretch.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["intersiteL2Stretch"] = data.IntersiteL2Stretch.ValueString()
	}
	if !data.IpLearning.IsNull() && !data.IpLearning.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ipLearning"] = data.IpLearning.ValueString()
	}
	if !data.Ipv6McastAllow.IsNull() && !data.Ipv6McastAllow.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ipv6McastAllow"] = data.Ipv6McastAllow.ValueString()
	}
	if !data.LimitIpLearnToSubnets.IsNull() && !data.LimitIpLearnToSubnets.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["limitIpLearnToSubnets"] = data.LimitIpLearnToSubnets.ValueString()
	}
	if !data.LlAddr.IsNull() && !data.LlAddr.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["llAddr"] = data.LlAddr.ValueString()
	}
	if !data.Mac.IsNull() && !data.Mac.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["mac"] = data.Mac.ValueString()
	}
	if !data.McastARPDrop.IsNull() && !data.McastARPDrop.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["mcastARPDrop"] = data.McastARPDrop.ValueString()
	}
	if !data.McastAllow.IsNull() && !data.McastAllow.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["mcastAllow"] = data.McastAllow.ValueString()
	}
	if !data.MultiDstPktAct.IsNull() && !data.MultiDstPktAct.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["multiDstPktAct"] = data.MultiDstPktAct.ValueString()
	}
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["name"] = data.Name.ValueString()
	}
	if !data.NameAlias.IsNull() && !data.NameAlias.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["nameAlias"] = data.NameAlias.ValueString()
	}
	if !data.OwnerKey.IsNull() && !data.OwnerKey.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ownerKey"] = data.OwnerKey.ValueString()
	}
	if !data.OwnerTag.IsNull() && !data.OwnerTag.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ownerTag"] = data.OwnerTag.ValueString()
	}
	if !data.Type.IsNull() && !data.Type.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["type"] = data.Type.ValueString()
	}
	if !data.UnicastRoute.IsNull() && !data.UnicastRoute.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["unicastRoute"] = data.UnicastRoute.ValueString()
	}
	if !data.UnkMacUcastAct.IsNull() && !data.UnkMacUcastAct.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["unkMacUcastAct"] = data.UnkMacUcastAct.ValueString()
	}
	if !data.UnkMcastAct.IsNull() && !data.UnkMcastAct.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["unkMcastAct"] = data.UnkMcastAct.ValueString()
	}
	if !data.V6unkMcastAct.IsNull() && !data.V6unkMcastAct.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["v6unkMcastAct"] = data.V6unkMcastAct.ValueString()
	}
	if !data.Vmac.IsNull() && !data.Vmac.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["vmac"] = data.Vmac.ValueString()
	}
	payload, err := json.Marshal(map[string]interface{}{"fvBD": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
