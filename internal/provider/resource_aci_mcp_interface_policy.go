// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &McpIfPolResource{}
var _ resource.ResourceWithImportState = &McpIfPolResource{}

func NewMcpIfPolResource() resource.Resource {
	return &McpIfPolResource{}
}

// McpIfPolResource defines the resource implementation.
type McpIfPolResource struct {
	client *client.Client
}

// McpIfPolResourceModel describes the resource data model.
type McpIfPolResourceModel struct {
	Id                  types.String `tfsdk:"id"`
	AdminSt             types.String `tfsdk:"admin_state"`
	Annotation          types.String `tfsdk:"annotation"`
	Descr               types.String `tfsdk:"description"`
	GracePeriod         types.String `tfsdk:"grace_period_seconds"`
	GracePeriodMsec     types.String `tfsdk:"grace_period_milliseconds"`
	MaxPduPerVlanLimit  types.String `tfsdk:"maximum_number_of_vlan"`
	McpMode             types.String `tfsdk:"strict_mode"`
	McpPduPerVlan       types.String `tfsdk:"mcp_pdu_per_vlan"`
	Name                types.String `tfsdk:"name"`
	NameAlias           types.String `tfsdk:"name_alias"`
	OwnerKey            types.String `tfsdk:"owner_key"`
	OwnerTag            types.String `tfsdk:"owner_tag"`
	StrictInitDelayTime types.String `tfsdk:"initial_delay_time"`
	StrictTxFreq        types.String `tfsdk:"transmission_frequency_seconds"`
	StrictTxFreqMsec    types.String `tfsdk:"transmission_frequency_milliseconds"`
	TagAnnotation       types.Set    `tfsdk:"annotations"`
	TagTag              types.Set    `tfsdk:"tags"`
}

func getEmptyMcpIfPolResourceModel() *McpIfPolResourceModel {
	return &McpIfPolResourceModel{
		Id:                  basetypes.NewStringNull(),
		AdminSt:             basetypes.NewStringNull(),
		Annotation:          basetypes.NewStringNull(),
		Descr:               basetypes.NewStringNull(),
		GracePeriod:         basetypes.NewStringNull(),
		GracePeriodMsec:     basetypes.NewStringNull(),
		MaxPduPerVlanLimit:  basetypes.NewStringNull(),
		McpMode:             basetypes.NewStringNull(),
		McpPduPerVlan:       basetypes.NewStringNull(),
		Name:                basetypes.NewStringNull(),
		NameAlias:           basetypes.NewStringNull(),
		OwnerKey:            basetypes.NewStringNull(),
		OwnerTag:            basetypes.NewStringNull(),
		StrictInitDelayTime: basetypes.NewStringNull(),
		StrictTxFreq:        basetypes.NewStringNull(),
		StrictTxFreqMsec:    basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
	}
}

// TagAnnotationMcpIfPolResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationMcpIfPolResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationMcpIfPolResourceModel() TagAnnotationMcpIfPolResourceModel {
	return TagAnnotationMcpIfPolResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagAnnotationMcpIfPolType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

// TagTagMcpIfPolResourceModel describes the resource data model for the children without relation ships.
type TagTagMcpIfPolResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagMcpIfPolResourceModel() TagTagMcpIfPolResourceModel {
	return TagTagMcpIfPolResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

var TagTagMcpIfPolType = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		"key":   types.StringType,
		"value": types.StringType,
	},
}

type McpIfPolIdentifier struct {
	Name types.String
}

func (r *McpIfPolResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if !req.Plan.Raw.IsNull() {
		var planData, stateData *McpIfPolResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) && !planData.Name.IsUnknown() {
			setMcpIfPolId(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "mcpIfPol", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}

		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func (r *McpIfPolResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_mcp_interface_policy")
	resp.TypeName = req.ProviderTypeName + "_mcp_interface_policy"
	tflog.Debug(ctx, "End metadata of resource: aci_mcp_interface_policy")
}

func (r *McpIfPolResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_mcp_interface_policy")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The mcp_interface_policy resource for the 'mcpIfPol' class",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the MCP Interface Policy object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
				},
			},
			"admin_state": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("disabled", "enabled"),
				},
				MarkdownDescription: `The administrative state of the MCP Interface Policy object.`,
			},
			"annotation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Default:             stringdefault.StaticString(globalAnnotation),
				MarkdownDescription: `The annotation of the MCP Interface Policy object.`,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The description of the MCP Interface Policy object.`,
			},
			"grace_period_seconds": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The grace period in seconds for the MCP Interface Policy object. This attribute is only applicable when 'strict_mode' is 'on'. The value must be in the range 0 - 300.`,
			},
			"grace_period_milliseconds": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The grace period in milliseconds for the MCP Interface Policy object. This attribute is only applicable when 'strict_mode' is 'on'. The value must be in the range 0 - 999.`,
			},
			"maximum_number_of_vlan": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The maximum amount of VLANs for the MCP Interface Policy object. The value must be in the range 1 - 2000 when 'strict_mode' is 'off', else the value must be in range 1 - 256.`,
			},
			"strict_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("off", "on"),
				},
				MarkdownDescription: `Enable strict mode for the MCP Interface Policy object.`,
			},
			"mcp_pdu_per_vlan": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("off", "on"),
				},
				MarkdownDescription: `Send MCP PDU packets per VLAN for the MCP Interface Policy object.`,
			},
			"name": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The name of the MCP Interface Policy object.`,
			},
			"name_alias": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The name alias of the MCP Interface Policy object.`,
			},
			"owner_key": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
			},
			"owner_tag": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
			},
			"initial_delay_time": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The initial delay time in seconds for the MCP Interface Policy object. This allows for MCP to wait before sending Bridge Protocol Data Units (BPDUs) which gives Spanning Tree Protocol (STP) on the external network time to converge. This attribute is only applicable when 'strict_mode' is 'on'. The value must be in the range 0 - 1800.`,
			},
			"transmission_frequency_seconds": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The transmission frequency in seconds for the MCP Interface Policy object. This attribute is only applicable when 'strict_mode' is 'on'. The value must be in the range 0 - 300.`,
			},
			"transmission_frequency_milliseconds": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseNonNullStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The transmission frequency in milliseconds for the MCP Interface Policy object. This attribute is only applicable when 'strict_mode' is 'on'. The value must be in the range 0 - 999.`,
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseNonNullStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseNonNullStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseNonNullStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseNonNullStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseNonNullStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseNonNullStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
		},
	}
	tflog.Debug(ctx, "End schema of resource: aci_mcp_interface_policy")
}

func (r *McpIfPolResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_mcp_interface_policy")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_mcp_interface_policy")
}

func (r *McpIfPolResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_mcp_interface_policy")
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *McpIfPolResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		setMcpIfPolId(ctx, stateData)
	}
	getAndSetMcpIfPolAttributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The mcpIfPol object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	}

	var data *McpIfPolResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Id.IsUnknown() || data.Id.IsNull() {
		setMcpIfPolId(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationMcpIfPolResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagMcpIfPolResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getMcpIfPolCreateJsonPayload(ctx, &resp.Diagnostics, true, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetMcpIfPolAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))
}

func (r *McpIfPolResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_mcp_interface_policy")
	var data *McpIfPolResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))

	getAndSetMcpIfPolAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *McpIfPolResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))
}

func (r *McpIfPolResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_mcp_interface_policy")
	var data *McpIfPolResourceModel
	var stateData *McpIfPolResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationMcpIfPolResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagMcpIfPolResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := getMcpIfPolCreateJsonPayload(ctx, &resp.Diagnostics, false, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetMcpIfPolAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))
}

func (r *McpIfPolResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_mcp_interface_policy")
	var data *McpIfPolResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "mcpIfPol", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_mcp_interface_policy with id '%s'", data.Id.ValueString()))
}

func (r *McpIfPolResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_mcp_interface_policy")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	var stateData *McpIfPolResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_mcp_interface_policy with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_mcp_interface_policy")
}

func getAndSetMcpIfPolAttributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *McpIfPolResourceModel) {
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=full&rsp-subtree-class=%s", data.Id.ValueString(), "mcpIfPol,tagAnnotation,tagTag"), "GET", nil)

	readData := getEmptyMcpIfPolResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("mcpIfPol").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("mcpIfPol").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					readData.Id = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "adminSt" {
					readData.AdminSt = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "annotation" {
					readData.Annotation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "descr" {
					readData.Descr = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "gracePeriod" {
					readData.GracePeriod = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "gracePeriodMsec" {
					readData.GracePeriodMsec = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "maxPduPerVlanLimit" {
					readData.MaxPduPerVlanLimit = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "mcpMode" {
					readData.McpMode = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "mcpPduPerVlan" {
					readData.McpPduPerVlan = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "name" {
					readData.Name = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "nameAlias" {
					readData.NameAlias = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ownerKey" {
					readData.OwnerKey = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ownerTag" {
					readData.OwnerTag = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "strictInitDelayTime" {
					readData.StrictInitDelayTime = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "strictTxFreq" {
					readData.StrictTxFreq = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "strictTxFreqMsec" {
					readData.StrictTxFreqMsec = basetypes.NewStringValue(attributeValue.(string))
				}
			}
			TagAnnotationMcpIfPolList := make([]TagAnnotationMcpIfPolResourceModel, 0)
			TagTagMcpIfPolList := make([]TagTagMcpIfPolResourceModel, 0)
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						if childClassName == "tagAnnotation" {
							TagAnnotationMcpIfPol := getEmptyTagAnnotationMcpIfPolResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagAnnotationMcpIfPol.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagAnnotationMcpIfPol.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagAnnotationMcpIfPolList = append(TagAnnotationMcpIfPolList, TagAnnotationMcpIfPol)
						}
						if childClassName == "tagTag" {
							TagTagMcpIfPol := getEmptyTagTagMcpIfPolResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagTagMcpIfPol.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagTagMcpIfPol.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}

							}
							TagTagMcpIfPolList = append(TagTagMcpIfPolList, TagTagMcpIfPol)
						}
					}
				}
			}
			tagAnnotationSet, _ := types.SetValueFrom(ctx, readData.TagAnnotation.ElementType(ctx), TagAnnotationMcpIfPolList)
			readData.TagAnnotation = tagAnnotationSet
			tagTagSet, _ := types.SetValueFrom(ctx, readData.TagTag.ElementType(ctx), TagTagMcpIfPolList)
			readData.TagTag = tagTagSet
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class 'mcpIfPol'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		readData.Id = basetypes.NewStringNull()
	}
	*data = *readData
}

func getMcpIfPolRn(ctx context.Context, data *McpIfPolResourceModel) string {
	return fmt.Sprintf("infra/mcpIfP-%s", data.Name.ValueString())
}

func setMcpIfPolId(ctx context.Context, data *McpIfPolResourceModel) {
	rn := getMcpIfPolRn(ctx, data)
	data.Id = types.StringValue(fmt.Sprintf("%s/%s", strings.Split([]string{"uni/infra/mcpIfP-{name}"}[0], "/")[0], rn))
}

func getMcpIfPolTagAnnotationChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *McpIfPolResourceModel, tagAnnotationMcpIfPolPlan, tagAnnotationMcpIfPolState []TagAnnotationMcpIfPolResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.TagAnnotation.IsNull() && !data.TagAnnotation.IsUnknown() {
		tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
		for _, tagAnnotationMcpIfPol := range tagAnnotationMcpIfPolPlan {
			childMap := NewAciObject()
			if !tagAnnotationMcpIfPol.Key.IsNull() && !tagAnnotationMcpIfPol.Key.IsUnknown() {
				childMap.Attributes["key"] = tagAnnotationMcpIfPol.Key.ValueString()
			}
			if !tagAnnotationMcpIfPol.Value.IsNull() && !tagAnnotationMcpIfPol.Value.IsUnknown() {
				childMap.Attributes["value"] = tagAnnotationMcpIfPol.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			tagAnnotationIdentifier := TagAnnotationIdentifier{}
			tagAnnotationIdentifier.Key = tagAnnotationMcpIfPol.Key
			tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
		}
		for _, tagAnnotation := range tagAnnotationMcpIfPolState {
			delete := true
			for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
				if tagAnnotationIdentifier.Key == tagAnnotation.Key {
					delete = false
					break
				}
			}
			if delete {
				tagAnnotationChildMapForDelete := NewAciObject()
				tagAnnotationChildMapForDelete.Attributes["status"] = "deleted"
				tagAnnotationChildMapForDelete.Attributes["key"] = tagAnnotation.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": tagAnnotationChildMapForDelete})
			}
		}
	} else {
		data.TagAnnotation = types.SetNull(data.TagAnnotation.ElementType(ctx))
	}

	return childPayloads
}

func getMcpIfPolTagTagChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *McpIfPolResourceModel, tagTagMcpIfPolPlan, tagTagMcpIfPolState []TagTagMcpIfPolResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	if !data.TagTag.IsNull() && !data.TagTag.IsUnknown() {
		tagTagIdentifiers := []TagTagIdentifier{}
		for _, tagTagMcpIfPol := range tagTagMcpIfPolPlan {
			childMap := NewAciObject()
			if !tagTagMcpIfPol.Key.IsNull() && !tagTagMcpIfPol.Key.IsUnknown() {
				childMap.Attributes["key"] = tagTagMcpIfPol.Key.ValueString()
			}
			if !tagTagMcpIfPol.Value.IsNull() && !tagTagMcpIfPol.Value.IsUnknown() {
				childMap.Attributes["value"] = tagTagMcpIfPol.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			tagTagIdentifier := TagTagIdentifier{}
			tagTagIdentifier.Key = tagTagMcpIfPol.Key
			tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
		}
		for _, tagTag := range tagTagMcpIfPolState {
			delete := true
			for _, tagTagIdentifier := range tagTagIdentifiers {
				if tagTagIdentifier.Key == tagTag.Key {
					delete = false
					break
				}
			}
			if delete {
				tagTagChildMapForDelete := NewAciObject()
				tagTagChildMapForDelete.Attributes["status"] = "deleted"
				tagTagChildMapForDelete.Attributes["key"] = tagTag.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagTag": tagTagChildMapForDelete})
			}
		}
	} else {
		data.TagTag = types.SetNull(data.TagTag.ElementType(ctx))
	}

	return childPayloads
}

func getMcpIfPolCreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *McpIfPolResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationMcpIfPolResourceModel, tagTagPlan, tagTagState []TagTagMcpIfPolResourceModel) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}
	childPayloads := []map[string]interface{}{}

	TagAnnotationchildPayloads := getMcpIfPolTagAnnotationChildPayloads(ctx, diags, data, tagAnnotationPlan, tagAnnotationState)
	if TagAnnotationchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagAnnotationchildPayloads...)

	TagTagchildPayloads := getMcpIfPolTagTagChildPayloads(ctx, diags, data, tagTagPlan, tagTagState)
	if TagTagchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagTagchildPayloads...)

	payloadMap["children"] = childPayloads
	if !data.AdminSt.IsNull() && !data.AdminSt.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["adminSt"] = data.AdminSt.ValueString()
	}
	if !data.Annotation.IsNull() && !data.Annotation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["annotation"] = data.Annotation.ValueString()
	}
	if !data.Descr.IsNull() && !data.Descr.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["descr"] = data.Descr.ValueString()
	}
	if !data.GracePeriod.IsNull() && !data.GracePeriod.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["gracePeriod"] = data.GracePeriod.ValueString()
	}
	if !data.GracePeriodMsec.IsNull() && !data.GracePeriodMsec.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["gracePeriodMsec"] = data.GracePeriodMsec.ValueString()
	}
	if !data.MaxPduPerVlanLimit.IsNull() && !data.MaxPduPerVlanLimit.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["maxPduPerVlanLimit"] = data.MaxPduPerVlanLimit.ValueString()
	}
	if !data.McpMode.IsNull() && !data.McpMode.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["mcpMode"] = data.McpMode.ValueString()
	}
	if !data.McpPduPerVlan.IsNull() && !data.McpPduPerVlan.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["mcpPduPerVlan"] = data.McpPduPerVlan.ValueString()
	}
	if !data.Name.IsNull() && !data.Name.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["name"] = data.Name.ValueString()
	}
	if !data.NameAlias.IsNull() && !data.NameAlias.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["nameAlias"] = data.NameAlias.ValueString()
	}
	if !data.OwnerKey.IsNull() && !data.OwnerKey.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ownerKey"] = data.OwnerKey.ValueString()
	}
	if !data.OwnerTag.IsNull() && !data.OwnerTag.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ownerTag"] = data.OwnerTag.ValueString()
	}
	if !data.StrictInitDelayTime.IsNull() && !data.StrictInitDelayTime.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["strictInitDelayTime"] = data.StrictInitDelayTime.ValueString()
	}
	if !data.StrictTxFreq.IsNull() && !data.StrictTxFreq.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["strictTxFreq"] = data.StrictTxFreq.ValueString()
	}
	if !data.StrictTxFreqMsec.IsNull() && !data.StrictTxFreqMsec.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["strictTxFreqMsec"] = data.StrictTxFreqMsec.ValueString()
	}
	payload, err := json.Marshal(map[string]interface{}{"mcpIfPol": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
