// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"fmt"

	"github.com/ciscoecosystem/aci-go-client/v2/client"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &VmmDomPDataSource{}

func NewVmmDomPDataSource() datasource.DataSource {
	return &VmmDomPDataSource{}
}

// VmmDomPDataSource defines the data source implementation.
type VmmDomPDataSource struct {
	client *client.Client
}

func (d *VmmDomPDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of datasource: aci_vmm_domain")
	resp.TypeName = req.ProviderTypeName + "_vmm_domain"
	tflog.Debug(ctx, "End metadata of datasource: aci_vmm_domain")
}

func (d *VmmDomPDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of datasource: aci_vmm_domain")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The vmm_domain datasource for the 'vmmDomP' class",

		Attributes: map[string]schema.Attribute{
			// Deprecated attributes
			"config_infra_pg": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'config_infra_pg' is deprecated, please refer to 'configure_infra_port_groups' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ctrl_knob": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ctrl_knob' is deprecated, please refer to 'endpoint_data_path_verification' instead. The attribute will be removed in the next major version of the provider.",
			},
			"enable_ave": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'enable_ave' is deprecated, please refer to 'enable_ave_mode' instead. The attribute will be removed in the next major version of the provider.",
			},
			"enable_tag": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'enable_tag' is deprecated, please refer to 'enable_tag_collection' instead. The attribute will be removed in the next major version of the provider.",
			},
			"enable_vm_folder": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'enable_vm_folder' is deprecated, please refer to 'enable_vm_folder_data_retrieval' instead. The attribute will be removed in the next major version of the provider.",
			},
			"encap_mode": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'encap_mode' is deprecated, please refer to 'encapsulation_mode' instead. The attribute will be removed in the next major version of the provider.",
			},
			"enf_pref": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'enf_pref' is deprecated, please refer to 'switching_enforcement_preference' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ep_inventory_type": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_inventory_type' is deprecated, please refer to 'endpoint_inventory_type' instead. The attribute will be removed in the next major version of the provider.",
			},
			"ep_ret_time": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'ep_ret_time' is deprecated, please refer to 'endpoint_retention_time' instead. The attribute will be removed in the next major version of the provider.",
			},
			"hv_avail_monitor": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'hv_avail_monitor' is deprecated, please refer to 'host_availability_assurance' instead. The attribute will be removed in the next major version of the provider.",
			},
			"mcast_addr": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'mcast_addr' is deprecated, please refer to 'multicast_address' instead. The attribute will be removed in the next major version of the provider.",
			},
			"mode": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'mode' is deprecated, please refer to 'switch_type' instead. The attribute will be removed in the next major version of the provider.",
			},
			"provider_profile_dn": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'provider_profile_dn' is deprecated, please refer to 'parent_dn' instead. The attribute will be removed in the next major version of the provider.",
			},
			"pref_encap_mode": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'pref_encap_mode' is deprecated, please refer to 'default_encapsulation_mode' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_infra_rs_dom_vxlan_ns_def": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_infra_rs_dom_vxlan_ns_def` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_infra_rs_vlan_ns_def": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_infra_rs_vlan_ns_def` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_infra_rs_vip_addr_ns": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_infra_rs_vip_addr_ns' is deprecated, please refer to 'relation_to_ip_address_pool' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_pref_enhanced_lag_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_vmm_rs_pref_enhanced_lag_pol' is deprecated, please refer to 'relation_to_lacp_enhanced_lag_policy' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_dom_mcast_addr_ns": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_vmm_rs_dom_mcast_addr_ns' is deprecated, please refer to 'relation_to_multicast_pool' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_infra_rs_vlan_ns": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute 'relation_infra_rs_vlan_ns' is deprecated, please refer to 'relation_to_vlan_pool' instead. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_cdp_if_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_cdp_if_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_fw_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_fw_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_l2_inst_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_l2_inst_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_lacp_lag_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_lacp_lag_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_lldp_if_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_lldp_if_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			"relation_vmm_rs_default_stp_if_pol": schema.StringAttribute{
				Computed:           true,
				DeprecationMessage: "Attribute `relation_vmm_rs_default_stp_if_pol` is deprecated. The attribute will be removed in the next major version of the provider.",
			},
			// End of deprecated attributes
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the VMM Domain object.",
			},
			"parent_dn": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.OneOf("uni/vmmp-CloudFoundry", "uni/vmmp-Kubernetes", "uni/vmmp-Microsoft", "uni/vmmp-Nutanix", "uni/vmmp-OpenShift", "uni/vmmp-OpenStack", "uni/vmmp-Redhat", "uni/vmmp-VMware"),
				},
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
			},
			"access_mode": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The access mode of the VMM Domain object.`,
			},
			"annotation": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The annotation of the VMM Domain object.`,
			},
			"arp_learning": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable ARP learning for the the VMM Domain object, this attribute is only applicable for Application Virtual Switch (AVS).`,
			},
			"ave_time_out": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The timeout in seconds that the Cisco ACI Virtual Edge (AVE), the virtual switch for ACI, can remain in a non-working state before vCenter takes action.`,
			},
			"configure_infra_port_groups": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Configure port groups for the virtual APIC.`,
			},
			"endpoint_data_path_verification": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `This mechanism allows disabling endpoint verification, prevents the un-deployment of an EPG while processing an endpoint detach when the fabric is still receiving traffic for the endpoint.`,
			},
			"custom_switch_name": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The custom vSwitch name.`,
			},
			"delimiter": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The delimiter of the VMM Domain object.`,
			},
			"enable_ave_mode": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable Cisco ACI Virtual Edge (AVE) mode on the VMM Domain object.`,
			},
			"enable_tag_collection": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable Tag data retrieval for the VMM Domain object.`,
			},
			"enable_vm_folder_data_retrieval": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable VM Folder data retrieval for the VMM Domain object.`,
			},
			"encapsulation_mode": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The encapsulation mode of the VMM Domain object. When default_encapsulation_mode is not specified, the encapsulation_mode is automatically set based on the encapsulation blocks associated with the domain.`,
			},
			"switching_enforcement_preference": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The switching enforcement preference of the VMM Domain object. This determines whether switching is done within the virtual switch (Local Switching) or whether all switched traffic must go through the fabric (No Local Switching).`,
			},
			"endpoint_inventory_type": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The endpoint inventory type of the VMM Domain object. When set to on-link type the inventory will contain all endpoints that share a fabric uplink.`,
			},
			"endpoint_retention_time": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The endpoint retention time of the VMM Domain object.`,
			},
			"host_availability_assurance": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `Enable host availability assurance, which creates a vSphere Proactive HA provider object that resides in VMware vCenter. The object enables VMware vCenter to quarantine a host with a nonworking Cisco Application Centric Infrastructure Virtual Edge and move its VMs.`,
			},
			"multicast_address": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The multicast address of the VMM Domain object.`,
			},
			"switch_type": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The switch type of the VMM Domain object.`,
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: `The name of the VMM Domain object.`,
			},
			"name_alias": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The name alias of the VMM Domain object.`,
			},
			"owner_key": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The key for enabling clients to own their data for entity correlation.`,
			},
			"owner_tag": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `A tag for enabling clients to add their own data. For example, to indicate who created this object.`,
			},
			"default_encapsulation_mode": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: `The default encapsulation mode of the VMM Domain object.`,
			},
			"relation_to_ip_address_pool": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To IP Address Pool object.`,
					},
					"target_dn": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The distinguished name of the target.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_vlan_pool": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the policy definition for ID ranges used for VLAN encapsulation.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To Vlan Pool object.`,
					},
					"target_dn": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The distinguished name of the target.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"relation_to_multicast_pool": schema.SingleNestedAttribute{
				MarkdownDescription: `A source relation to the policy definition of the multicast IP address ranges.`,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To Multicast Pool object.`,
					},
					"target_dn": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The distinguished name of the target.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"relation_to_lacp_enhanced_lag_policy": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the Relation To LACP Enhanced Lag Policy object.`,
					},
					"target_dn": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The distinguished name of the target.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
				},
			},
			"vmm_uplink_container": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"annotation": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The annotation of the VMM Uplink Container object.`,
					},
					"name_alias": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The name alias of the VMM Uplink Container object.`,
					},
					"number_of_uplinks": schema.StringAttribute{
						Computed:            true,
						MarkdownDescription: `The number of uplinks in the VMM Uplink Container object.`,
					},
					"annotations": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"tags": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The key used to uniquely identify this configuration object.`,
								},
								"value": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The value of the property.`,
								},
							},
						},
					},
					"uplink_policies": schema.SetNestedAttribute{
						MarkdownDescription: ``,
						Computed:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"annotation": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The annotation of the VMM Uplink Policy object.`,
								},
								"name_alias": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The name alias of the VMM Uplink Policy object.`,
								},
								"uplink_id": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The uplink identifier of the VMM Uplink Policy object.`,
								},
								"uplink_name": schema.StringAttribute{
									Computed:            true,
									MarkdownDescription: `The uplink name of the VMM Uplink Policy object.`,
								},
								"annotations": schema.SetNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"key": schema.StringAttribute{
												Computed:            true,
												MarkdownDescription: `The key used to uniquely identify this configuration object.`,
											},
											"value": schema.StringAttribute{
												Computed:            true,
												MarkdownDescription: `The value of the property.`,
											},
										},
									},
								},
								"tags": schema.SetNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"key": schema.StringAttribute{
												Computed:            true,
												MarkdownDescription: `The key used to uniquely identify this configuration object.`,
											},
											"value": schema.StringAttribute{
												Computed:            true,
												MarkdownDescription: `The value of the property.`,
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
		Blocks: map[string]schema.Block{},
	}
	tflog.Debug(ctx, "End schema of datasource: aci_vmm_domain")
}

func (d *VmmDomPDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of datasource: aci_vmm_domain")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = client
	tflog.Debug(ctx, "End configure of datasource: aci_vmm_domain")
}

func (d *VmmDomPDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	tflog.Debug(ctx, "Start read of datasource: aci_vmm_domain")
	var data *VmmDomPResourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	setVmmDomPId(ctx, data)

	// Create a copy of the Id for when not found during getAndSetVmmDomPAttributes
	cachedId := data.Id.ValueString()

	tflog.Debug(ctx, fmt.Sprintf("Read of datasource aci_vmm_domain with id '%s'", data.Id.ValueString()))

	getAndSetVmmDomPAttributes(ctx, &resp.Diagnostics, d.client, data)

	if data.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Failed to read aci_vmm_domain data source",
			fmt.Sprintf("The aci_vmm_domain data source with id '%s' has not been found", cachedId),
		)
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End read of datasource aci_vmm_domain with id '%s'", data.Id.ValueString()))
}
