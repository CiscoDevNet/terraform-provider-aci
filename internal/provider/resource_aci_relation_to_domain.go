// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &FvRsDomAttResource{}
var _ resource.ResourceWithImportState = &FvRsDomAttResource{}

func NewFvRsDomAttResource() resource.Resource {
	return &FvRsDomAttResource{}
}

// FvRsDomAttResource defines the resource implementation.
type FvRsDomAttResource struct {
	client *client.Client
}

// FvRsDomAttResourceModel describes the resource data model.
type FvRsDomAttResourceModel struct {
	Id                  types.String `tfsdk:"id"`
	ParentDn            types.String `tfsdk:"parent_dn"`
	Annotation          types.String `tfsdk:"annotation"`
	BindingType         types.String `tfsdk:"binding_type"`
	ClassPref           types.String `tfsdk:"class_preference"`
	CustomEpgName       types.String `tfsdk:"custom_epg_name"`
	Delimiter           types.String `tfsdk:"delimiter"`
	Encap               types.String `tfsdk:"encapsulation"`
	EncapMode           types.String `tfsdk:"encapsulation_mode"`
	EpgCos              types.String `tfsdk:"epg_cos"`
	EpgCosPref          types.String `tfsdk:"epg_cos_pref"`
	InstrImedcy         types.String `tfsdk:"deployment_immediacy"`
	IpamDhcpOverride    types.String `tfsdk:"ipam_dhcp_override"`
	IpamEnabled         types.String `tfsdk:"ipam_enabled"`
	IpamGateway         types.String `tfsdk:"ipam_gateway"`
	LagPolicyName       types.String `tfsdk:"lag_policy_name"`
	NetflowDir          types.String `tfsdk:"netflow_direction"`
	NetflowPref         types.String `tfsdk:"enable_netflow"`
	NumPorts            types.String `tfsdk:"number_of_ports"`
	PortAllocation      types.String `tfsdk:"port_allocation"`
	PrimaryEncap        types.String `tfsdk:"primary_encapsulation"`
	PrimaryEncapInner   types.String `tfsdk:"primary_encapsulation_inner"`
	ResImedcy           types.String `tfsdk:"resolution_immediacy"`
	SecondaryEncapInner types.String `tfsdk:"secondary_encapsulation_inner"`
	SwitchingMode       types.String `tfsdk:"switching_mode"`
	TDn                 types.String `tfsdk:"target_dn"`
	Untagged            types.String `tfsdk:"untagged"`
	VnetOnly            types.String `tfsdk:"vnet_only"`
	TagAnnotation       types.Set    `tfsdk:"annotations"`
	TagTag              types.Set    `tfsdk:"tags"`
}

func getEmptyFvRsDomAttResourceModel() *FvRsDomAttResourceModel {
	return &FvRsDomAttResourceModel{
		Id:                  basetypes.NewStringNull(),
		ParentDn:            basetypes.NewStringNull(),
		Annotation:          basetypes.NewStringNull(),
		BindingType:         basetypes.NewStringNull(),
		ClassPref:           basetypes.NewStringNull(),
		CustomEpgName:       basetypes.NewStringNull(),
		Delimiter:           basetypes.NewStringNull(),
		Encap:               basetypes.NewStringNull(),
		EncapMode:           basetypes.NewStringNull(),
		EpgCos:              basetypes.NewStringNull(),
		EpgCosPref:          basetypes.NewStringNull(),
		InstrImedcy:         basetypes.NewStringNull(),
		IpamDhcpOverride:    basetypes.NewStringNull(),
		IpamEnabled:         basetypes.NewStringNull(),
		IpamGateway:         basetypes.NewStringNull(),
		LagPolicyName:       basetypes.NewStringNull(),
		NetflowDir:          basetypes.NewStringNull(),
		NetflowPref:         basetypes.NewStringNull(),
		NumPorts:            basetypes.NewStringNull(),
		PortAllocation:      basetypes.NewStringNull(),
		PrimaryEncap:        basetypes.NewStringNull(),
		PrimaryEncapInner:   basetypes.NewStringNull(),
		ResImedcy:           basetypes.NewStringNull(),
		SecondaryEncapInner: basetypes.NewStringNull(),
		SwitchingMode:       basetypes.NewStringNull(),
		TDn:                 basetypes.NewStringNull(),
		Untagged:            basetypes.NewStringNull(),
		VnetOnly:            basetypes.NewStringNull(),
		TagAnnotation: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
		TagTag: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
				"key":   types.StringType,
				"value": types.StringType,
			},
		}),
	}
}

// TagAnnotationFvRsDomAttResourceModel describes the resource data model for the children without relation ships.
type TagAnnotationFvRsDomAttResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagAnnotationFvRsDomAttResourceModel() TagAnnotationFvRsDomAttResourceModel {
	return TagAnnotationFvRsDomAttResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

// TagTagFvRsDomAttResourceModel describes the resource data model for the children without relation ships.
type TagTagFvRsDomAttResourceModel struct {
	Key   types.String `tfsdk:"key"`
	Value types.String `tfsdk:"value"`
}

func getEmptyTagTagFvRsDomAttResourceModel() TagTagFvRsDomAttResourceModel {
	return TagTagFvRsDomAttResourceModel{
		Key:   basetypes.NewStringNull(),
		Value: basetypes.NewStringNull(),
	}
}

type FvRsDomAttIdentifier struct {
	TDn types.String
}

func (r *FvRsDomAttResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if !req.Plan.Raw.IsNull() {
		var planData, stateData *FvRsDomAttResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) && !planData.ParentDn.IsUnknown() && !planData.TDn.IsUnknown() {
			setFvRsDomAttId(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "fvRsDomAtt", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}

		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func (r *FvRsDomAttResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_relation_to_domain")
	resp.TypeName = req.ProviderTypeName + "_relation_to_domain"
	tflog.Debug(ctx, "End metadata of resource: aci_relation_to_domain")
}

func (r *FvRsDomAttResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_relation_to_domain")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The relation_to_domain resource for the 'fvRsDomAtt' class",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the Relation To Domain object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"parent_dn": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
			},
			"annotation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Default:             stringdefault.StaticString(globalAnnotation),
				MarkdownDescription: `The annotation of the Relation To Domain object.`,
			},
			"binding_type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("dynamicBinding", "ephemeral", "none", "staticBinding"),
				},
				MarkdownDescription: `The binding type of the Relation To Domain object.`,
			},
			"class_preference": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("encap", "useg"),
				},
				MarkdownDescription: `The class preference of the Relation To Domain object. Set 'useg' to allow microsegmentation.`,
			},
			"custom_epg_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The display name of the user configured port-group.`,
			},
			"delimiter": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The delimiter of the Relation To Domain object.`,
			},
			"encapsulation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The encapsulation of the Relation To Domain object. The encapsulation refers to the EPG VLAN when class preference is set to 'encap, or to the Secondary VLAN when class preference is set to 'useg'.`,
			},
			"encapsulation_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("auto", "vlan", "vxlan"),
				},
				MarkdownDescription: `The encapsulation mode of the Relation To Domain object.`,
			},
			"epg_cos": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("Cos0", "Cos1", "Cos2", "Cos3", "Cos4", "Cos5", "Cos6", "Cos7"),
				},
				MarkdownDescription: `The class of service (CoS) of the Relation To Domain object.`,
			},
			"epg_cos_pref": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("disabled", "enabled"),
				},
				MarkdownDescription: `The class of service (CoS) preference of the Relation To Domain object.`,
			},
			"deployment_immediacy": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("immediate", "lazy"),
				},
				MarkdownDescription: `The deployment immediacy of the Relation To Domain object. Specifies when the policy is pushed into the hardware policy content-addressable memory (CAM).`,
			},
			"ipam_dhcp_override": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The IP address management (IPAM) DHCP override of the Relation To Domain object. Only applicable for Nutanix domains.`,
			},
			"ipam_enabled": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The IP address management (IPAM) enabled status of the Relation To Domain object. Only applicable for Nutanix domains.`,
			},
			"ipam_gateway": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The IP address management (IPAM) gateway of the Relation To Domain object. Only applicable for Nutanix domains.`,
			},
			"lag_policy_name": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The link aggregation group (LAG) policy name of the Relation To Domain object.`,
			},
			"netflow_direction": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("both", "egress", "ingress"),
				},
				MarkdownDescription: `The NetFlow monitoring direction of the Relation To Domain object.`,
			},
			"enable_netflow": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("disabled", "enabled"),
				},
				MarkdownDescription: `The Netflow enabled status for the Relation To Domain object.`,
			},
			"number_of_ports": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The number of ports of the Relation To Domain object.`,
			},
			"port_allocation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("elastic", "fixed", "none"),
				},
				MarkdownDescription: `Port allocation for ports.`,
			},
			"primary_encapsulation": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The primary encapsulation of the Relation To Domain object. This is used when the class preference is set to 'useg'.`,
			},
			"primary_encapsulation_inner": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The primary inner encapsulation of the Relation To Domain object. This is used for the portgroup at the VMWare Distributed Virtual Switch (DVS). This VLAN is internal to the DVS and is used for communication between the other VMs and the AVE VM at a host. Traffic is not forwarded to the fabric over the VLAN. Only applicable for Cisco ACI Virtual Edge (AVE) domains.`,
			},
			"resolution_immediacy": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("immediate", "lazy", "pre-provision"),
				},
				MarkdownDescription: `The resolution immediacy of the Relation To Domain object. Specifies if policies are resolved immmediately or when needed.`,
			},
			"secondary_encapsulation_inner": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				MarkdownDescription: `The secondary inner encapsulation of the Relation To Domain object. This is used for the portgroup at the VMWare Distributed Virtual Switch (DVS). This VLAN is internal to the DVS and is used for communication between the other VMs and the AVE VM at a host. Traffic is not forwarded to the fabric over the VLAN. Only applicable for Cisco ACI Virtual Edge (AVE) domains.`,
			},
			"switching_mode": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("AVE", "native"),
				},
				MarkdownDescription: `The switching mode of the Relation To Domain object.`,
			},
			"target_dn": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					stringplanmodifier.RequiresReplace(),
				},
				MarkdownDescription: `The distinguished name of the target Domain object.`,
			},
			"untagged": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The untagged status of the Relation To Domain object.`,
			},
			"vnet_only": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("no", "yes"),
				},
				MarkdownDescription: `The VNET only status of the Relation To Domain object.`,
			},
			"annotations": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
			"tags": schema.SetNestedAttribute{
				MarkdownDescription: ``,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The key used to uniquely identify this configuration object.`,
						},
						"value": schema.StringAttribute{
							Required: true,
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							MarkdownDescription: `The value of the property.`,
						},
					},
				},
			},
		},
	}
	tflog.Debug(ctx, "End schema of resource: aci_relation_to_domain")
}

func (r *FvRsDomAttResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_relation_to_domain")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_relation_to_domain")
}

func (r *FvRsDomAttResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_relation_to_domain")
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *FvRsDomAttResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		SetFvRsDomAttId(ctx, stateData)
	}
	getAndSetFvRsDomAttAttributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The fvRsDomAtt object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	}

	var data *FvRsDomAttResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	if data.Id.IsUnknown() || data.Id.IsNull() {
		SetFvRsDomAttId(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvRsDomAttResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvRsDomAttResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := GetFvRsDomAttCreateJsonPayload(ctx, &resp.Diagnostics, true, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvRsDomAttAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvRsDomAttResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_relation_to_domain")
	var data *FvRsDomAttResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))

	getAndSetFvRsDomAttAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *FvRsDomAttResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvRsDomAttResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_relation_to_domain")
	var data *FvRsDomAttResourceModel
	var stateData *FvRsDomAttResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))

	var tagAnnotationPlan, tagAnnotationState []TagAnnotationFvRsDomAttResourceModel
	data.TagAnnotation.ElementsAs(ctx, &tagAnnotationPlan, false)
	stateData.TagAnnotation.ElementsAs(ctx, &tagAnnotationState, false)
	var tagTagPlan, tagTagState []TagTagFvRsDomAttResourceModel
	data.TagTag.ElementsAs(ctx, &tagTagPlan, false)
	stateData.TagTag.ElementsAs(ctx, &tagTagState, false)
	jsonPayload := GetFvRsDomAttCreateJsonPayload(ctx, &resp.Diagnostics, false, data, tagAnnotationPlan, tagAnnotationState, tagTagPlan, tagTagState)

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSetFvRsDomAttAttributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvRsDomAttResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_relation_to_domain")
	var data *FvRsDomAttResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "fvRsDomAtt", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_relation_to_domain with id '%s'", data.Id.ValueString()))
}

func (r *FvRsDomAttResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_relation_to_domain")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	var stateData *FvRsDomAttResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_relation_to_domain with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_relation_to_domain")
}

func getAndSetFvRsDomAttAttributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *FvRsDomAttResourceModel) {
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=children&rsp-subtree-class=%s", data.Id.ValueString(), "fvRsDomAtt,tagAnnotation,tagTag"), "GET", nil)

	*data = *getEmptyFvRsDomAttResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("fvRsDomAtt").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("fvRsDomAtt").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					data.Id = basetypes.NewStringValue(attributeValue.(string))
					setFvRsDomAttParentDn(ctx, attributeValue.(string), data)
				}
				if attributeName == "annotation" {
					data.Annotation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "bindingType" && attributeValue.(string) == "" {
					data.BindingType = basetypes.NewStringValue("none")
				} else if attributeName == "bindingType" {
					data.BindingType = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "classPref" {
					data.ClassPref = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "customEpgName" {
					data.CustomEpgName = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "delimiter" {
					data.Delimiter = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "encap" {
					data.Encap = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "encapMode" {
					data.EncapMode = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "epgCos" {
					data.EpgCos = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "epgCosPref" {
					data.EpgCosPref = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "instrImedcy" {
					data.InstrImedcy = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ipamDhcpOverride" {
					data.IpamDhcpOverride = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ipamEnabled" {
					data.IpamEnabled = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "ipamGateway" {
					data.IpamGateway = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "lagPolicyName" {
					data.LagPolicyName = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "netflowDir" {
					data.NetflowDir = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "netflowPref" {
					data.NetflowPref = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "numPorts" {
					data.NumPorts = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "portAllocation" && attributeValue.(string) == "" {
					data.PortAllocation = basetypes.NewStringValue("none")
				} else if attributeName == "portAllocation" {
					data.PortAllocation = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "primaryEncap" {
					data.PrimaryEncap = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "primaryEncapInner" {
					data.PrimaryEncapInner = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "resImedcy" {
					data.ResImedcy = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "secondaryEncapInner" {
					data.SecondaryEncapInner = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "switchingMode" {
					data.SwitchingMode = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "tDn" {
					data.TDn = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "untagged" {
					data.Untagged = basetypes.NewStringValue(attributeValue.(string))
				}
				if attributeName == "vnetOnly" {
					data.VnetOnly = basetypes.NewStringValue(attributeValue.(string))
				}
			}
			TagAnnotationFvRsDomAttList := make([]TagAnnotationFvRsDomAttResourceModel, 0)
			TagTagFvRsDomAttList := make([]TagTagFvRsDomAttResourceModel, 0)
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						if childClassName == "tagAnnotation" {
							TagAnnotationFvRsDomAtt := getEmptyTagAnnotationFvRsDomAttResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagAnnotationFvRsDomAtt.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagAnnotationFvRsDomAtt.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagAnnotationFvRsDomAttList = append(TagAnnotationFvRsDomAttList, TagAnnotationFvRsDomAtt)
						}
						if childClassName == "tagTag" {
							TagTagFvRsDomAtt := getEmptyTagTagFvRsDomAttResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								if childAttributeName == "key" {
									TagTagFvRsDomAtt.Key = basetypes.NewStringValue(childAttributeValue.(string))
								}
								if childAttributeName == "value" {
									TagTagFvRsDomAtt.Value = basetypes.NewStringValue(childAttributeValue.(string))
								}
							}
							TagTagFvRsDomAttList = append(TagTagFvRsDomAttList, TagTagFvRsDomAtt)
						}
					}
				}
			}
			tagAnnotationSet, _ := types.SetValueFrom(ctx, data.TagAnnotation.ElementType(ctx), TagAnnotationFvRsDomAttList)
			data.TagAnnotation = tagAnnotationSet
			tagTagSet, _ := types.SetValueFrom(ctx, data.TagTag.ElementType(ctx), TagTagFvRsDomAttList)
			data.TagTag = tagTagSet
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class 'fvRsDomAtt'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		data.Id = basetypes.NewStringNull()
	}
}

func getFvRsDomAttRn(ctx context.Context, data *FvRsDomAttResourceModel) string {
	rn := "rsdomAtt-[{tDn}]"
	for _, identifier := range []string{"tDn"} {
		fieldName := fmt.Sprintf("%s%s", strings.ToUpper(identifier[:1]), identifier[1:])
		fieldValue := reflect.ValueOf(data).Elem().FieldByName(fieldName).Interface().(basetypes.StringValue).ValueString()
		rn = strings.ReplaceAll(rn, fmt.Sprintf("{%s}", identifier), fieldValue)
	}
	return rn
}

func setFvRsDomAttParentDn(ctx context.Context, dn string, data *FvRsDomAttResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
}

func SetFvRsDomAttId(ctx context.Context, data *FvRsDomAttResourceModel) {
	rn := getFvRsDomAttRn(ctx, data)
	data.Id = types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
}

func getFvRsDomAttTagAnnotationChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvRsDomAttResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvRsDomAttResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagAnnotation.IsUnknown() {
		tagAnnotationIdentifiers := []TagAnnotationIdentifier{}
		for _, tagAnnotation := range tagAnnotationPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagAnnotation.Key.IsUnknown() && !tagAnnotation.Key.IsNull() {
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
			}
			if !tagAnnotation.Value.IsUnknown() && !tagAnnotation.Value.IsNull() {
				childMap["attributes"]["value"] = tagAnnotation.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			tagAnnotationIdentifier := TagAnnotationIdentifier{}
			tagAnnotationIdentifier.Key = tagAnnotation.Key
			tagAnnotationIdentifiers = append(tagAnnotationIdentifiers, tagAnnotationIdentifier)
		}
		for _, tagAnnotation := range tagAnnotationState {
			delete := true
			for _, tagAnnotationIdentifier := range tagAnnotationIdentifiers {
				if tagAnnotationIdentifier.Key == tagAnnotation.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagAnnotation.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagAnnotation": childMap})
			}
		}
	} else {
		data.TagAnnotation = types.SetNull(data.TagAnnotation.ElementType(ctx))
	}

	return childPayloads
}
func getFvRsDomAttTagTagChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *FvRsDomAttResourceModel, tagTagPlan, tagTagState []TagTagFvRsDomAttResourceModel) []map[string]interface{} {

	childPayloads := []map[string]interface{}{}
	if !data.TagTag.IsUnknown() {
		tagTagIdentifiers := []TagTagIdentifier{}
		for _, tagTag := range tagTagPlan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
			if !tagTag.Key.IsUnknown() && !tagTag.Key.IsNull() {
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
			}
			if !tagTag.Value.IsUnknown() && !tagTag.Value.IsNull() {
				childMap["attributes"]["value"] = tagTag.Value.ValueString()
			}
			childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			tagTagIdentifier := TagTagIdentifier{}
			tagTagIdentifier.Key = tagTag.Key
			tagTagIdentifiers = append(tagTagIdentifiers, tagTagIdentifier)
		}
		for _, tagTag := range tagTagState {
			delete := true
			for _, tagTagIdentifier := range tagTagIdentifiers {
				if tagTagIdentifier.Key == tagTag.Key {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
				childMap["attributes"]["key"] = tagTag.Key.ValueString()
				childPayloads = append(childPayloads, map[string]interface{}{"tagTag": childMap})
			}
		}
	} else {
		data.TagTag = types.SetNull(data.TagTag.ElementType(ctx))
	}

	return childPayloads
}

func GetFvRsDomAttCreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *FvRsDomAttResourceModel, tagAnnotationPlan, tagAnnotationState []TagAnnotationFvRsDomAttResourceModel, tagTagPlan, tagTagState []TagTagFvRsDomAttResourceModel) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}
	childPayloads := []map[string]interface{}{}

	TagAnnotationchildPayloads := getFvRsDomAttTagAnnotationChildPayloads(ctx, diags, data, tagAnnotationPlan, tagAnnotationState)
	if TagAnnotationchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagAnnotationchildPayloads...)

	TagTagchildPayloads := getFvRsDomAttTagTagChildPayloads(ctx, diags, data, tagTagPlan, tagTagState)
	if TagTagchildPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, TagTagchildPayloads...)

	payloadMap["children"] = childPayloads
	if !data.Annotation.IsNull() && !data.Annotation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["annotation"] = data.Annotation.ValueString()
	}
	if !data.BindingType.IsNull() && !data.BindingType.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["bindingType"] = data.BindingType.ValueString()
	}
	if !data.ClassPref.IsNull() && !data.ClassPref.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["classPref"] = data.ClassPref.ValueString()
	}
	if !data.CustomEpgName.IsNull() && !data.CustomEpgName.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["customEpgName"] = data.CustomEpgName.ValueString()
	}
	if !data.Delimiter.IsNull() && !data.Delimiter.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["delimiter"] = data.Delimiter.ValueString()
	}
	if !data.Encap.IsNull() && !data.Encap.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["encap"] = data.Encap.ValueString()
	}
	if !data.EncapMode.IsNull() && !data.EncapMode.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["encapMode"] = data.EncapMode.ValueString()
	}
	if !data.EpgCos.IsNull() && !data.EpgCos.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["epgCos"] = data.EpgCos.ValueString()
	}
	if !data.EpgCosPref.IsNull() && !data.EpgCosPref.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["epgCosPref"] = data.EpgCosPref.ValueString()
	}
	if !data.InstrImedcy.IsNull() && !data.InstrImedcy.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["instrImedcy"] = data.InstrImedcy.ValueString()
	}
	if !data.IpamDhcpOverride.IsNull() && !data.IpamDhcpOverride.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ipamDhcpOverride"] = data.IpamDhcpOverride.ValueString()
	}
	if !data.IpamEnabled.IsNull() && !data.IpamEnabled.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ipamEnabled"] = data.IpamEnabled.ValueString()
	}
	if !data.IpamGateway.IsNull() && !data.IpamGateway.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["ipamGateway"] = data.IpamGateway.ValueString()
	}
	if !data.LagPolicyName.IsNull() && !data.LagPolicyName.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["lagPolicyName"] = data.LagPolicyName.ValueString()
	}
	if !data.NetflowDir.IsNull() && !data.NetflowDir.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["netflowDir"] = data.NetflowDir.ValueString()
	}
	if !data.NetflowPref.IsNull() && !data.NetflowPref.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["netflowPref"] = data.NetflowPref.ValueString()
	}
	if !data.NumPorts.IsNull() && !data.NumPorts.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["numPorts"] = data.NumPorts.ValueString()
	}
	if !data.PortAllocation.IsNull() && !data.PortAllocation.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["portAllocation"] = data.PortAllocation.ValueString()
	}
	if !data.PrimaryEncap.IsNull() && !data.PrimaryEncap.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["primaryEncap"] = data.PrimaryEncap.ValueString()
	}
	if !data.PrimaryEncapInner.IsNull() && !data.PrimaryEncapInner.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["primaryEncapInner"] = data.PrimaryEncapInner.ValueString()
	}
	if !data.ResImedcy.IsNull() && !data.ResImedcy.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["resImedcy"] = data.ResImedcy.ValueString()
	}
	if !data.SecondaryEncapInner.IsNull() && !data.SecondaryEncapInner.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["secondaryEncapInner"] = data.SecondaryEncapInner.ValueString()
	}
	if !data.SwitchingMode.IsNull() && !data.SwitchingMode.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["switchingMode"] = data.SwitchingMode.ValueString()
	}
	if !data.TDn.IsNull() && !data.TDn.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["tDn"] = data.TDn.ValueString()
	}
	if !data.Untagged.IsNull() && !data.Untagged.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["untagged"] = data.Untagged.ValueString()
	}
	if !data.VnetOnly.IsNull() && !data.VnetOnly.IsUnknown() {
		payloadMap["attributes"].(map[string]string)["vnetOnly"] = data.VnetOnly.ValueString()
	}

	payload, err := json.Marshal(map[string]interface{}{"fvRsDomAtt": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
