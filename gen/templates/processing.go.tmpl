{{define "processResource"}}
func processResource(resourceName string, resourceValues map[string]interface{}) map[string]Item {
	attributes := make(map[string]interface{})
	var children []map[string]Item

	switch resourceName {
	{{range $resource := .Resources}}
	case "{{$resource.ResourceName}}":
		{{range $attribute := $resource.Properties}}
		if val, exists := resourceValues["{{$attribute.PropertyName}}"].(string); exists && val != "" {
			attributes["{{$attribute.SnakeCaseName}}"] = val
		}
		{{end}}
		if val, exists := resourceValues["parent_dn"].(string); exists && val != "" {
			attributes["dn"] = fmt.Sprintf("{{$resource.RnFormat}}", val{{range $field := $resource.IdentifiedBy}}, attributes["{{$field}}"]{{end}})
			attributes["parent_dn"] = val
		}
		if status, exists := attributes["status"].(string); exists {
			attributes["status"] = status
		}

		children = createChildrenFromAttributes(resourceValues)
		return map[string]Item{
			"{{$resource.ResourceClassName}}": {
				Attributes: attributes,
				Children:   children,
			},
		}
	{{end}}
	}
	return nil
}
{{end}}

{{define "createChildrenFromAttributes"}}
func createChildrenFromAttributes(attributes map[string]interface{}) []map[string]Item {
	var children []map[string]Item

	for key, value := range attributes {
		if nestedObjects, exists := value.([]interface{}); exists {
			children = append(children, extractRelations(key, nestedObjects)...)
		}
	}
	return children
}
{{end}}

{{define "extractRelations"}}
func extractRelations(relationType string, relations []interface{}) []map[string]Item {
	var children []map[string]Item
	for _, relation := range relations {
		if relationMap, ok := relation.(map[string]interface{}); ok {
			child := map[string]Item{
				relationType: {
					Attributes: relationMap,
				},
			}
			children = append(children, child)
		}
	}
	return children
}
{{end}}

{{template "extractRelations"}}
{{template "createChildrenFromAttributes"}}
{{template "processResource"}}
