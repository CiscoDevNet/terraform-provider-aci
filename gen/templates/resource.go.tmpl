// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"fmt"
	"encoding/json"
	{{- if .IdentifiedBy}}
	"reflect"
	{{- end}}
	"strings"
	
	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	{{- if or .HasBitmask .HasChildWithoutIdentifier}}
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	{{- end}}
	{{- if .HasValidValues}}
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	{{- if or .HasAnnotation}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	{{- if or .HasChild .HasBitmask}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	{{- if or .HasValidValues .HasChildWithoutIdentifier}}
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &{{.ResourceClassName}}Resource{}
var _ resource.ResourceWithImportState = &{{.ResourceClassName}}Resource{}

func New{{.ResourceClassName}}Resource() resource.Resource {
	return &{{.ResourceClassName}}Resource{}
}

// {{.ResourceClassName}}Resource defines the resource implementation.
type {{.ResourceClassName}}Resource struct {
	client *client.Client
}

// {{.ResourceClassName}}ResourceModel describes the resource data model.
type {{.ResourceClassName}}ResourceModel struct {
	Id types.String `tfsdk:"id"`
	{{- if .HasParent}}
	ParentDn types.String `tfsdk:"parent_dn"`
	{{- end}}
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- range .Children}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{- .ResourceName}}"`
	{{- end}}
}

{{- range .Children}}
// {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel describes the resource data model for the children without relation ships.
type {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel struct {
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
}
{{- end}}

{{if .IdentifiedBy}}
type {{.ResourceClassName}}Identifier struct {
	{{- range .Properties}}
	{{- if .IsNaming}}
	{{ .Name }} types.String
	{{- end}}
	{{- end}}
}
{{- end}}

func (r *{{.ResourceClassName}}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_{{.ResourceName}}")
	resp.TypeName = req.ProviderTypeName + "_{{.ResourceName}}"
	tflog.Debug(ctx, "End metadata of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_{{.ResourceName}}")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The {{.ResourceName}} resource for the '{{.PkgName}}' class",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the {{getResourceNameAsDescription .ResourceName $.Definitions}} object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			{{- if .HasParent}}
			"parent_dn": schema.StringAttribute{
				{{- if getDefaultValues .PkgName "parent_dn" $.Definitions}}
				Optional:            true,
				Computed:            true,
				Default: 			 stringdefault.StaticString("{{getDefaultValues .PkgName "parent_dn" $.Definitions}}"),
				{{- else}}
				Required:            true,
				{{- end}}
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
			},
			{{- end}}
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
			"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.SetAttribute{
				MarkdownDescription: `{{.Comment}}`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				{{- if .ValidValues}}
				Validators: []validator.Set{
					setvalidator.SizeAtMost({{ len .ValidValues }}),
					setvalidator.ValueStringsAre(
						stringvalidator.OneOf({{- validatorString .ValidValues}}),
					),
				},
				{{- end}}
				ElementType: types.StringType,
			},
				{{- else}}
			"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
					{{- if or .IsNaming .IsRequired}}
				Required:            true,
					{{- else }}
				Optional:            true,
				Computed:            true,
					{{- end}}
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					{{- if or .IsNaming .CreateOnly}}
					stringplanmodifier.RequiresReplace(),
					{{- end}}
				},
					{{- if eq .Name "Annotation"}}
				Default: stringdefault.StaticString(globalAnnotation),
					{{- end}}
					{{- if .ValidValues}}
				Validators: []validator.String{
					stringvalidator.OneOf({{- validatorString .ValidValues}}),
				},
					{{- end}}
				MarkdownDescription: `{{.Comment}}`,
			},
				{{- end}}
			{{- end}}
			{{- range .Children}}
			"{{- .ResourceName}}": schema.SetNestedAttribute{
				MarkdownDescription: `{{.Comment}}`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				{{- if not .IdentifiedBy}}
				Validators: []validator.Set{
					setvalidator.SizeAtMost(1),
				},
				{{- end}}
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
					{{- range .Properties}}
						{{- if eq .ValueType "bitmask"}}
						"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.SetAttribute{
							MarkdownDescription: `{{.Comment}}`,
							Optional:            true,
							Computed:            true,
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							{{- if .ValidValues}}
							Validators: []validator.Set{
								setvalidator.SizeAtMost({{ len .ValidValues }}),
								setvalidator.ValueStringsAre(
									stringvalidator.OneOf({{- validatorString .ValidValues}}),
								),
							},
							{{- end}}
							ElementType: types.StringType,
						},
						{{- else}}
						"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
							{{- if or .IsNaming .IsRequired}}
							Required:            true,
							{{- else }}
							Optional:            true,
							Computed:            true,
							{{- end}}
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							{{- if .ValidValues}}
							Validators: []validator.String{
								stringvalidator.OneOf({{- validatorString .ValidValues}}),
							},
							{{- end}}
							MarkdownDescription: `{{.Comment}}`,
						},
						{{- end}}
					{{- end}}
					},
				},
			},
			{{- end}}
		},
	}
	tflog.Debug(ctx, "End schema of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_{{.ResourceName}}")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_{{.ResourceName}}")
	
	{{- if .HasChild}}
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *{{.ResourceClassName}}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	set{{.ResourceClassName}}Id(ctx, stateData)
	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, stateData)
	{{- end}}

	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	
	set{{.ResourceClassName}}Id(ctx, data)

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{ if .HasChild}}
		{{- range .Children}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
		{{- end}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, data)
	{{- end}}

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	
	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *{{.ResourceClassName}}ResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel
	{{- if .HasChild}}
	var stateData *{{.ResourceClassName}}ResourceModel
	{{- end}}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	{{- if .HasChild}}
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	{{- end}}

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
	
	{{ if .HasChild}}
		{{- range .Children}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
		{{- end}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, data)
	{{- end}}
	
	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	
	if resp.Diagnostics.HasError() {
		return
	}

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{- if .AllowDelete}}
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "{{.PkgName}}", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	{{- else}}
	parentDnMessage := "Delete on apic is only possible when deleting the parent object with dn"
	parentDn := data.Id.ValueString()
	if parentDn == "" {
		parentDnMessage = fmt.Sprintf("%s.", parentDnMessage)
	} else {
		parentDnMessage = fmt.Sprintf("%s '%s'.", parentDnMessage, parentDn)
	}
	message := fmt.Sprintf("resource with dn '%s' not removed from apic", data.Id.ValueString())
	messageDetail := fmt.Sprintf("Only removing resource from state because apic does not allow deletion of class '{{.PkgName}}' objects. %s", parentDnMessage)
	resp.Diagnostics.AddWarning(message, messageDetail)
	{{- end}}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_{{.ResourceName}}")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	
	var stateData *{{.ResourceClassName}}ResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_{{.ResourceName}} with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_{{.ResourceName}}")
}

func getAndSet{{.ResourceClassName}}Attributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *{{.ResourceClassName}}ResourceModel) {
	{{- if .HasChild}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=children&rsp-subtree-class=%s", data.Id.ValueString(), "{{- .PkgName}},{{- listToString .ChildClasses}}"), "GET", nil)
	{{- else}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "GET", nil)
	{{- end}}
	
	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("{{.PkgName}}").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("{{.PkgName}}").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					data.Id = basetypes.NewStringValue(attributeValue.(string))
					{{- if .HasParent}}
					set{{.ResourceClassName}}ParentDn(ctx, attributeValue.(string), data)
					{{- end}}
				}
				{{- range .Properties}}
					{{- if eq .ValueType "bitmask"}}
				if attributeName == "{{.PropertyName}}" {
					{{.PropertyName}}List := make([]string, 0)
					if attributeValue.(string) != "" {
                        {{.PropertyName}}List = strings.Split(attributeValue.(string), ",")
                    }
					{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, data.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
					data.{{.Name}} = {{.PropertyName}}Set
				}
					{{- else}}
						{{- if containsNoneAttributeValue .ValidValues}}
				if attributeName == "{{.PropertyName}}" && attributeValue.(string) == "" {
					data.{{.Name}} = basetypes.NewStringValue("none")
				} else if attributeName == "{{.PropertyName}}" {
					data.{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
				}
						{{- else}}
				if attributeName == "{{.PropertyName}}" {
					data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(attributeValue.(string))
				}
						{{- end}}
					{{- end}}
				{{- end}}
			}
			
			{{- if .HasChild}}
				{{- range .Children}}
					{{- if .IdentifiedBy}}
			{{ .ResourceClassName }}{{$.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
					{{- else}}
			{{ .ResourceClassName }}{{$.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 1)
					{{- end}}
				{{- end}}
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						{{- range .Children}}
						if childClassName == "{{ .PkgName }}" {
							{{.ResourceClassName}}{{$.ResourceClassName}} := {{ .ResourceClassName}}{{$.ResourceClassName}}ResourceModel{}
							for childAttributeName, childAttributeValue := range childAttributes {
								{{- range .Properties}}
									{{- if eq .ValueType "bitmask"}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), []string{"none"})
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								}
										{{- end}}
									{{- else}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue("none")
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(childAttributeValue.(string))
								}
										{{- end}}
									{{- end}}
								{{- end}}
							}
							{{- if .IdentifiedBy}}
							{{.ResourceClassName}}{{$.ResourceClassName}}List = append({{.ResourceClassName}}{{$.ResourceClassName}}List, {{.ResourceClassName}}{{$.ResourceClassName}})
							{{- else}}
							{{.ResourceClassName}}{{$.ResourceClassName}}List[0] =  {{.ResourceClassName}}{{$.ResourceClassName}}
							{{- end}}
						}
						{{- end}}
					}
				}
			}
				{{- range .Children}}
			{{ .PkgName }}Set, _ := types.SetValueFrom(ctx, data.{{ .ResourceClassName }}.ElementType(ctx), {{ .ResourceClassName }}{{$.ResourceClassName}}List)
			data.{{ .ResourceClassName }} = {{ .PkgName }}Set
				{{- end}}
			{{- end}}
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class '{{.PkgName}}'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		data.Id = basetypes.NewStringNull()
	}
}

func get{{.ResourceClassName}}Rn(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) string {
	{{- if .IdentifiedBy}}
	rn := "{{.RnFormat}}"
	for _, identifier := range []string{ {{- fromInterfacesToString .IdentifiedBy}} } {
		fieldName := fmt.Sprintf("%s%s", strings.ToUpper(identifier[:1]), identifier[1:])
		fieldValue := reflect.ValueOf(data).Elem().FieldByName(fieldName).Interface().(basetypes.StringValue).ValueString()
		rn = strings.ReplaceAll(rn, fmt.Sprintf("{%s}", identifier), fieldValue)
	}
	return rn
	{{- else}}
	return "{{.RnFormat}}"
	{{- end}}
}

{{ if .HasParent}}
func set{{.ResourceClassName}}ParentDn(ctx context.Context, dn string, data *{{.ResourceClassName}}ResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	{{- if eq .RnPrepend ""}}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
	{{- else}}
	parentDn := dn[:rnIndex]
	parentDn = parentDn[:strings.Index(parentDn, "/{{.RnPrepend}}")]
	data.ParentDn = basetypes.NewStringValue(parentDn)
	{{- end}}
}
{{- end}}

func set{{.ResourceClassName}}Id(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) {
	rn := get{{.ResourceClassName}}Rn(ctx, data)
	{{- if .HasParent}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
	{{- else}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", strings.Split([]string{ {{- fromInterfacesToString .DnFormats}} }[0], "/")[0], rn))
	{{- end}}
}

{{ range .Children}}
func get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *{{$.ResourceClassName}}ResourceModel, {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel) []map[string]interface{} {
	
	childPayloads := []map[string]interface{}{}
	if !data.{{ .ResourceClassName }}.IsUnknown() {
	{{- if .IdentifiedBy}}
		{{ .PkgName }}Identifiers := []{{ .ResourceClassName }}Identifier{}
	{{- end}}
		for _, {{ .PkgName }} := range {{ .PkgName }}Plan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
		{{- range .Properties}}
			if !{{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
			{{- if eq .ValueType "bitmask"}}
				var tmp{{ .Name }} []string
				{{ .PkgName }}.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
				childMap["attributes"]["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")				
			{{- else if eq .Name "Id"}}
				childMap["attributes"]["{{ .PropertyName }}"] = {{ .PkgName }}.{{.ResourceClassName}}{{ .Name }}.ValueString()
			{{- else}}
				childMap["attributes"]["{{ .PropertyName }}"] = {{ .PkgName }}.{{ .Name }}.ValueString()
			{{- end}}
			} {{- if eq .Name "Annotation" }} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			} {{- end}}
		{{- end}}
			childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
		{{- if .IdentifiedBy}}
			{{ .PkgName }}Identifier := {{ .ResourceClassName }}Identifier{}
				{{- range .Properties}}
					{{- if .IsNaming}}
			{{ .PkgName }}Identifier.{{.Name}} = {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}
					{{- end}}
				{{- end}}
			{{ .PkgName }}Identifiers = append({{ .PkgName }}Identifiers, {{ .PkgName }}Identifier)
		{{- end}}
		}
		{{- if .IdentifiedBy}}
		for _, {{ .PkgName }} := range {{ .PkgName }}State {
			delete := true
			for _, {{ .PkgName }}Identifier := range {{ .PkgName }}Identifiers { {{$i := 1}}{{$length := len .IdentifiedBy}}
				if 
				{{- range .Properties}}
					{{- if .IsNaming }}
					{{ .PkgName }}Identifier.{{.Name}} == {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}{{- if ne $length $i}} {{$i = add $i 1}} && {{- end}}
					{{- end}}
				{{- end}} {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
			{{- range .Properties}}
				{{- if .IsNaming }}
				childMap["attributes"]["{{.PropertyName}}"] = {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
				{{- end}}
			{{- end}}
				childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
			}
		}
		{{- else}}
		if len({{ .PkgName }}Plan) == 0 && len({{ .PkgName }}State) == 1 {
			{{- if .AllowDelete}}
			childMap := map[string]map[string]interface{}{"attributes": {}}
			childMap["attributes"]["status"] = "deleted"
			childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
			{{- else}}
			diags.AddError(
				"{{ .ResourceClassName }} object cannot be deleted",
				"deletion of child is only possible upon deletion of the parent",
			)
			return nil
			{{- end }}
		}
		{{- end}}
	} else {
		data.{{ .ResourceClassName }} = types.SetNull(data.{{ .ResourceClassName }}.ElementType(ctx))
	}

	return childPayloads
}
{{- end}}

func get{{.ResourceClassName}}CreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, data *{{.ResourceClassName}}ResourceModel{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{{- end}}) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}
	{{- if .HasChild}}
	childPayloads := []map[string]interface{}{}
		{{ range .Children}}
	{{ .ResourceClassName }}childPayloads := get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx, diags, data, {{.PkgName}}Plan, {{.PkgName}}State)
	if {{ .ResourceClassName }}childPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, {{ .ResourceClassName }}childPayloads...)

		{{ end}}
	payloadMap["children"] = childPayloads
	{{- end}}

	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	if !data.{{ .Name }}.IsNull() && !data.{{ .Name }}.IsUnknown() {
		var tmp{{ .Name }} []string
		data.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")
	}
		{{- else}}
	if !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull() && !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
	}
		{{- end}}
	{{- end}}

	payload, err := json.Marshal(map[string]interface{}{"{{.PkgName}}": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
