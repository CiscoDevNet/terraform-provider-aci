// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).


package provider

import (
	"context"
	"fmt"
	"encoding/json"
	
	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	"github.com/CiscoDevNet/terraform-provider-aci/v2/internal/validators"
	customTypes "github.com/CiscoDevNet/terraform-provider-aci/v2/internal/custom_types"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &{{.ResourceClassName}}Resource{}
var _ resource.ResourceWithImportState = &{{.ResourceClassName}}Resource{}

func New{{.ResourceClassName}}Resource() resource.Resource {
	return &{{.ResourceClassName}}Resource{}
}

// {{.ResourceClassName}}Resource defines the resource implementation.
type {{.ResourceClassName}}Resource struct {
	client *client.Client
}

// {{.ResourceClassName}}ResourceModel describes the resource data model.
type {{.ResourceClassName}}ResourceModel struct {
	Id types.String `tfsdk:"id"`
	{{- if .HasParent}}
	ParentDn types.String `tfsdk:"parent_dn"`
	{{- end}}
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if .HasCustomType}}
	{{ .Name }} customTypes.{{.ResourceClassName}}{{.Name}}StringValue `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- range .Children}}
		{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	{{ .ResourceClassName }} types.Object `tfsdk:"{{overwriteProperty .PkgName .ResourceName $.Definitions}}"`
		{{- else}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{overwriteProperty .PkgName .ResourceName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- if .LegacyAttributes}}
		{{- range .LegacyAttributes}}
			{{- if ne .ReplacedBy.AttributeName "" }}
	Deprecated{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
			{{- else if containsString .Name .AttributeName}}
	{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
			{{- end }}
		{{- end }}
		{{- range .LegacyBlocks}}
	Deprecated{{ capitalize .ClassName }} types.Set `tfsdk:"{{.Name}}"`
		{{- end }}
	{{- end }}
}

func getEmpty{{.ResourceClassName}}ResourceModel() *{{.ResourceClassName}}ResourceModel {
	return &{{.ResourceClassName}}ResourceModel{
		Id: basetypes.NewStringNull(),
		{{- if .HasParent }}
		ParentDn: basetypes.NewStringNull(),
		{{- end}}
		{{- range .Properties}}
			{{- if eq .ValueType "bitmask"}}
		{{ .Name }}: types.SetNull(types.StringType),
			{{- else if eq .Name "Id"}}
		{{.ResourceClassName}}{{ .Name }}: basetypes.NewStringNull(),
			{{- else if .HasCustomType}}
		{{ .Name }}: customTypes.New{{.ResourceClassName}}{{.Name}}StringNull(),
			{{- else}}
		{{ .Name }}: basetypes.NewStringNull(),
			{{- end}}
		{{- end}}
		{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		{{ .ResourceClassName }}: types.ObjectNull(map[string]attr.Type{
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
				{{- else}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
				{{- end}}
			{{- end}}
			{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- else}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- end}}
			{{- end}}
		}),
			{{- else}}
		{{ .ResourceClassName }}: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
				{{- else}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
				{{- end}}
			{{- end}}
			{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- else}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- end}}
			{{- end}}
			},
		}),
			{{- end}}
		{{- end}}
		{{- if .LegacyAttributes}}
			{{- range .LegacyAttributes}}
				{{- if ne .ReplacedBy.AttributeName "" }}
					{{- if eq (getMigrationType .ValueType) "String"}}
		Deprecated{{ .Name }}: types.{{getMigrationType .ValueType}}{},
					{{- else if eq (getMigrationType .ValueType) "Set"}}
		Deprecated{{ .Name }}: types.SetNull(types.StringType),
					{{- end }}
				{{- else if containsString .Name .AttributeName}}
					{{- if eq (getMigrationType .ValueType) "String"}}
		{{ .Name }}: types.{{getMigrationType .ValueType}}{},
					{{- else if eq (getMigrationType .ValueType) "Set"}}
		{{ .Name }}: types.SetNull(types.StringType),
					{{- end }}
				{{- end }}
			{{- end }}
			{{- range .LegacyBlocks}}
		Deprecated{{ capitalize .ClassName }}: types.SetNull(deprecated{{ capitalize .ClassName }}Type),
			{{- end }}
		{{- end }}
	}
}

{{- range .Children}}
	{{- template "childStructsAndAttributeTypes" . }}
{{- end}}

{{if .IdentifiedBy}}
type {{.ResourceClassName}}Identifier struct {
	{{- range .Properties}}
	{{- if .IsNaming}}
	{{ .Name }} types.String
	{{- end}}
	{{- end}}
}
{{- end}}

{{ if .LegacyAttributes}}
{{- range .LegacyBlocks}}
var deprecated{{ capitalize .ClassName }}Type = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		{{- range .Attributes}}
			{{- if eq (getMigrationType .ValueType) "String"}}
				"{{.AttributeName}}": basetypes.StringType{},
			{{- end}}
		{{- end}}
	},
}
{{ end}}

type {{.ResourceClassName}}ResourceModelV{{.LegacySchemaVersion}} struct {
	{{- range .LegacyAttributes}}
	{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
	{{- end }}
	{{- range .LegacyBlocks}}
	{{ capitalize .ClassName }} types.Set `tfsdk:"{{.Name}}"`
	{{- end }}
}

	{{ range .LegacyBlocks}}
type {{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}} struct {
		{{- range .Attributes}}
	{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
		{{- end}}
}

func getEmpty{{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}() {{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}} {
	return {{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}{
		{{- range .Attributes}}
		{{ .Name }}: basetypes.NewStringNull(),
		{{- end}}
	}
}

	{{ end}}

func (r *{{.ResourceClassName}}Resource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		{{.LegacySchemaVersion}}: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					{{- range .LegacyAttributes}}
						{{- if eq (getMigrationType .ValueType) "String"}}
					"{{.AttributeName}}": schema.StringAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
					},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "Set"}}
					"{{.AttributeName}}": schema.SetAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
						ElementType: types.StringType,
					},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "List"}}
					"{{.AttributeName}}": schema.ListAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
						ElementType: types.StringType,
					},
						{{- end}}
					{{- end}}
				},
				Blocks: map[string]schema.Block{
					{{- range .LegacyBlocks}}
					"{{ .Name }}": schema.SetNestedBlock{
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							{{- range .Attributes}}
								{{- if eq (getMigrationType .ValueType) "String"}}
							"{{.AttributeName}}": schema.StringAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
							},
								{{- end}}
								{{- if eq (getMigrationType .ValueType) "Set"}}
							"{{.AttributeName}}": schema.SetAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
								ElementType: types.StringType,
							},
								{{- end}}
								{{- if eq (getMigrationType .ValueType) "List"}}
							"{{.AttributeName}}": schema.ListAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
								ElementType: types.StringType,
							},
								{{- end}}
							{{- end}}
							},
						},
					},
					{{- end }}
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData {{.ResourceClassName}}ResourceModelV{{.LegacySchemaVersion}}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := {{.ResourceClassName}}ResourceModel{
					Id: priorStateData.Id,
					{{- if .HasParent}}
					ParentDn: priorStateData.ParentDn,
					{{- end}}
					{{- range .Properties}}
						{{- if isLegacyAttribute .Name $.LegacyAttributes}}
							{{- if .HasCustomType}}
					{{ .Name }}: customTypes.{{.ResourceClassName}}{{.Name}}StringValue{ StringValue: priorStateData.{{ .Name }} },
							{{- else}}
					{{ .Name }}: priorStateData.{{ .Name }},
							{{- end}}
						{{- else if ne .ValueType "bitmask"}}
					{{ .Name }}: basetypes.NewStringNull(),
						{{- else if eq .ValueType "bitmask"}}
					{{ .Name }}: types.SetNull(types.StringType),
						{{- end}}
					{{- end}}
					{{- range .LegacyAttributes}}
						{{- if ne .ReplacedBy.AttributeName "" }}
							{{- if eq (getMigrationType .ValueType) "String"}}
					Deprecated{{ .Name }}: priorStateData.{{ .Name }},
							{{- end }}
						{{- else if containsString .Name .AttributeName}}
					{{ .Name }}: priorStateData.{{ .Name }},
						{{- end }}
					{{- end }}
				}

				{{ range .Children}}{{ $ResourceName := .ResourceName }}
					{{- if isLegacyChild .PkgName $.LegacyChildren}}{{ $PkgName := .PkgName}}
					{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
						{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
							{{- if eq $childClassType "string" }}
				{{.ResourceClassName}}Object := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
								{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if eq $AttributeName ""}}
					{{ .Name }}: basetypes.NewStringNull(),
									{{- else}}
										{{- if isNewNamedClassAttribute $Overwrite }}
											{{- if isNewNamedClassAttributeMatch $Overwrite $ResourceName}}
					{{ .Name }}: basetypes.NewStringValue(GetMOName(priorStateData.{{ $AttributeName }}.ValueString())),
											{{- else}}
					{{ .Name }}: basetypes.NewStringNull(),
											{{- end }}
										{{- else}}
					{{ .Name }}: priorStateData.{{ $AttributeName }},
										{{- end}}
									{{- end}}
								{{- end}}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
								{{ .ResourceClassName }}: basetypes.ObjectNull(map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
									{{- end}}
								}),
									{{- else}}
								{{ .ResourceClassName }}: basetypes.NewSetNull(types.ObjectType{
									AttrTypes: map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
							{{- end}}
								},
							}),
							{{- end}}
					{{- end}}
				}
				{{ .PkgName }}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{.ResourceClassName}}Object)
				upgradedStateData.{{ .ResourceClassName }} = {{ .PkgName }}Object
							{{- end }}
						{{- else}}
				{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
							{{- if eq $childClassType "string" }}
				{{.ResourceClassName}} := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
								{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if eq $AttributeName ""}}
					{{ .Name }}: basetypes.NewStringNull(),
									{{- else}}
										{{- if isNewNamedClassAttribute $Overwrite }}
					{{ .Name }}: basetypes.NewStringValue(GetMOName(priorStateData.{{ $AttributeName }}.ValueString())),
										{{- else}}
					{{ .Name }}: priorStateData.{{ $AttributeName }},
										{{- end}}
									{{- end}}
								{{- end}}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
								{{ .ResourceClassName }}: basetypes.ObjectNull(map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
									{{- end}}
								}),
									{{- else}}
								{{ .ResourceClassName }}: basetypes.NewSetNull(types.ObjectType{
									AttrTypes: map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
							{{- end}}
								},
							}),
							{{- end}}
					{{- end}}
				}
				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{.ResourceClassName}})
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
							{{- else if eq $childClassType "block,set" }}
				var priorStateData{{.ResourceClassName}}List []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}
				priorStateData.{{.ResourceClassName}}.ElementsAs(ctx, &priorStateData{{.ResourceClassName}}List, false)
				for _, priorStateData{{.ResourceClassName}} := range priorStateData{{.ResourceClassName}}List {
					{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
								{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if eq $AttributeName ""}}
						{{ .Name }}: basetypes.NewStringNull(),
									{{- else if .HasCustomType}}
						{{ .Name }}: customTypes.{{.ResourceClassName}}{{.Name}}StringValue{StringValue: priorStateData{{.ResourceClassName}}.{{ $AttributeName }}},
									{{- else}}
						{{ .Name }}: priorStateData{{.ResourceClassName}}.{{ $AttributeName }},
									{{- end}}
								{{- end}}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
								{{ .ResourceClassName }}: basetypes.ObjectNull(map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
									{{- end}}
								}),
									{{- else}}
								{{ .ResourceClassName }}: basetypes.NewSetNull(types.ObjectType{
									AttrTypes: map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
							{{- end}}
								},
							}),
							{{- end}}
					{{- end}}
					}
					{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
				}
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
							{{- else if eq $childClassType "set,string" }}
				var priorStateData{{.ResourceClassName}}List []string
				priorStateData.{{.ResourceClassName}}.ElementsAs(ctx, &priorStateData{{.ResourceClassName}}List, false)
				for _, priorStateData{{.ResourceClassName}} := range priorStateData{{.ResourceClassName}}List {
					{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
								{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if eq $AttributeName ""}}
						{{ .Name }}: basetypes.NewStringNull(),
									{{- else}}
										{{- if isNewNamedClassAttribute $Overwrite }}
						{{ .Name }}: basetypes.NewStringValue(GetMOName(priorStateData{{ .ResourceClassName }})),
										{{- else if eq .Name "TDn"}}
						{{ .Name }}: basetypes.NewStringValue(priorStateData{{ .ResourceClassName }}),
										{{- end}}
									{{- end}}
								{{- end}}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
								{{ .ResourceClassName }}: basetypes.ObjectNull(map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
									{{- end}}
								}),
									{{- else}}
								{{ .ResourceClassName }}: basetypes.NewSetNull(types.ObjectType{
									AttrTypes: map[string]attr.Type{
									{{- range .Properties}}
										{{- if eq .ValueType "bitmask"}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
										{{- else}}
										"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
										{{- end}}
									{{- end}}
									{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- else}}
									"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
									{{- end}}
							{{- end}}
								},
							}),
							{{- end}}
					{{- end}}
					}
					{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
				}
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
							{{- end}}
						{{- end}}
					{{ else}}
						{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
				upgradedStateData.{{ .ResourceClassName }} = types.ObjectNull({{ .ResourceClassName }}{{$.ResourceClassName}}Type)
						{{- else}}
				upgradedStateData.{{ .ResourceClassName }} = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							{{- range .Properties}}
								{{- if ne .ValueType "bitmask"}}
								"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": basetypes.StringType{},
								{{- end}}
							{{- end}}
							{{- range .Children}}
							{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
						"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": basetypes.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
							{{- else}}
						"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": basetypes.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
							{{- end}}
						{{- end}}
						},
					},
				)
						{{- end}}
					{{ end}}
				{{- end}}

				{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
					{{- if or (eq (getMigrationType .ValueType) "Set") (eq (getMigrationType .ValueType) "List")}}
				var deprecated{{ .Name }}List []string
				priorStateData.{{ .Name }}.ElementsAs(ctx, &deprecated{{ .Name }}List, false)
				Deprecated{{ .Name }}Set, _ := types.SetValueFrom(ctx, types.StringType, deprecated{{ .Name }}List)
				upgradedStateData.Deprecated{{ .Name }} = Deprecated{{ .Name }}Set
					{{ end }}{{- end }}
				{{- end }}

				{{ range .LegacyBlocks}}
				var {{ capitalize .ClassName }}V1List []{{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}
				priorStateData.{{ capitalize .ClassName }}.ElementsAs(ctx, &{{ capitalize .ClassName }}V1List, false)
				{{ capitalize .ClassName }}V1Set, _ := types.SetValueFrom(ctx, deprecated{{ capitalize .ClassName }}Type, {{ capitalize .ClassName }}V1List)
				upgradedStateData.Deprecated{{ capitalize .ClassName }} = {{ capitalize .ClassName }}V1Set
				{{ end}}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
	}
}

func set{{ .ResourceClassName }}LegacyAttributes(ctx context.Context, diags *diag.Diagnostics, data, staticData *{{.ResourceClassName}}ResourceModel, classReadInfo []interface{}) {
	{{- if .HasParent}}
	data.DeprecatedParentDn = data.ParentDn
	{{- end}}
	{{- range .LegacyAttributes}}
		{{-  if containsString .Name .AttributeName}}
			{{- if or (eq (getMigrationType .ValueType) "Set") (eq (getMigrationType .ValueType) "List")}}
	if !staticData.{{ .Name }}.IsUnknown() && !staticData.{{ .Name }}.IsNull() {
		data.{{ .Name }} = staticData.{{ .Name }}
	} else {
		{{ .Name }}Set, _ := types.SetValueFrom(ctx, types.StringType, []string{})
		data.{{ .Name }} = {{ .Name }}Set
	}
			{{- else}}
	if !staticData.{{ .Name }}.IsUnknown() {
		data.{{ .Name }} = staticData.{{ .Name }}
	}
			{{- end}}
		{{- end }}
	{{- end }}
	attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
	for attributeName, attributeValue := range attributes {
		{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
			{{- if and (isNewAttributeStringType .ReplacedBy.AttributeName) (ne .Name "ParentDn")}}
				{{- if legacyAttributeContainsNoneValue . $.Properties}}
		if attributeName == "{{decapitalize .Name}}" && attributeValue.(string) == "" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue("none")
		} else if attributeName == "{{decapitalize .Name}}" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
		}
				{{- else}}
		if attributeName == "{{decapitalize .Name}}" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
		}
				{{- end}}
			{{- end }}{{- end }}
		{{- end }}
	}

	{{- if .HasChild}}
		{{- range $.Children}}{{- if isLegacyChild .PkgName $.LegacyChildren}}
		{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
			{{- if eq $childClassType "string" }}
	data.Deprecated{{.ResourceClassName}} = basetypes.NewStringNull()
			{{- else if eq $childClassType "set,string" }}
	Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List := make([]string, 0)
			{{- else if eq $childClassType "block,set" }}
	Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModelV1, 0)
			{{- end }}
		{{- end }}
	{{- end }}

	_, ok := classReadInfo[0].(map[string]interface{})["children"]
	if ok {
		children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
		for _, child := range children {
			for childClassName, childClassDetails := range child.(map[string]interface{}) {
				childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
				{{- range .Children}}
					{{- if isLegacyChild .PkgName $.LegacyChildren}}{{$ResourceName := .ResourceName}}
				{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
						{{- if eq $childClassType "string" }}
				if childClassName == "{{ .PkgName }}" {
					for childAttributeName, childAttributeValue := range childAttributes {
							{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
								{{- if and (eq $AttributeName (capitalize .PkgName)) (isNewNamedClassAttributeMatch $Overwrite $ResourceName)}}
						if childAttributeName == "tDn" {
							data.Deprecated{{.ResourceClassName}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
								{{- else if and (ne $AttributeName "") (isNewNamedClassAttributeMatch $Overwrite $ResourceName)}}
						if childAttributeName == "{{.PropertyName}}" {
							data.Deprecated{{.ResourceClassName}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
								{{- end}}
							{{- end}}
					}
				}
						{{- else if eq $childClassType "set,string" }}
				if childClassName == "{{ .PkgName }}" {
					for childAttributeName, childAttributeValue := range childAttributes {
							{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
								{{- if eq $AttributeName (capitalize .PkgName)}}
						if childAttributeName == "tDn" && childAttributeValue != "" && !ContainsString(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, childAttributeValue.(string)) {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List = append(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, childAttributeValue.(string))
						}{{break}}
								{{- else if ne $AttributeName ""}}
						if childAttributeName == "{{.PropertyName}}" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List = append(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, childAttributeValue.(string))
						} // {{$AttributeName}}
								{{- end}}
							{{- end}}
					}
				}
						{{- else if eq $childClassType "block,set" }}
				if childClassName == "{{ .PkgName }}" {
					Deprecated{{.ResourceClassName}}{{$.ResourceClassName}} := getEmpty{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModelV1()
					for childAttributeName, childAttributeValue := range childAttributes {
							{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
								{{- if eq $AttributeName "TargetDn"}}
						if childAttributeName == "tDn" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}.TargetDn = basetypes.NewStringValue(childAttributeValue.(string))
						}
								{{- else if isNewNamedClassAttribute $Overwrite}}
						if childAttributeName == "tDn" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
								{{- else if ne .Name "Annotation"}}
						if childAttributeName == "{{.PropertyName}}" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
								{{- end}}
							{{- end}}
					}
					Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List = append(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, Deprecated{{.ResourceClassName}}{{$.ResourceClassName}})
				}
						{{- end }}
					{{- end }}
				{{- end }}
			}
		}

		{{- range .Children}}{{- if isLegacyChild .PkgName $.LegacyChildren}}
		{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
			{{- if or (eq $childClassType "set,string") (eq $childClassType "block,set") }}
		{{ .PkgName }}Set, _ := types.SetValueFrom(ctx, data.Deprecated{{ .ResourceClassName }}.ElementType(ctx), Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List)
		data.Deprecated{{ .ResourceClassName }} = {{ .PkgName }}Set
			{{- end}}
		{{- end}}{{- end}}
	}
	{{- end }}
}
{{- end }}

func (r *{{.ResourceClassName}}Resource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
    if !req.Plan.Raw.IsNull() {
		var planData, stateData{{ if or .LegacyAttributes (containsSingleNestedChildren .Children)}}, configData{{end}} *{{.ResourceClassName}}ResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		{{ if or .LegacyAttributes (containsSingleNestedChildren .Children)}}resp.Diagnostics.Append(req.Config.Get(ctx, &configData)...){{end}}

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) {{if .HasParent }}&& !planData.ParentDn.IsUnknown() {{end}}{{range .Properties}}{{if .IsNaming}}&& !planData.{{ .Name }}.IsUnknown() {{end}}{{end}}{
			set{{.ResourceClassName}}Id(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "{{.PkgName}}", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}
		{{- range .Children}}
			{{- if containsSingleNestedChildren .Children}}
				{{- template "declareChildListsInGetandSetAttributesFunctionWithGetEmpty" . }}
				{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		var {{ .ResourceClassName }}ConfigData {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		configData.{{ .ResourceClassName }}.As(ctx, &{{ .ResourceClassName }}ConfigData, basetypes.ObjectAsOptions{})
				{{- else}}
		var {{ .ResourceClassName }}ConfigData []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		configData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .ResourceClassName }}ConfigData, false)
				{{- end}}
				{{- $resource := . }}
				{{- range .Children}}
				{{- $newCtx := addToTemplateProperties . "configData" $resource -}}
				{{- template "modifyPlanForSingleNestedChildren" $newCtx }}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			if !configData.{{ .ResourceClassName }}.IsNull() && stateData != nil {
				if IsEmptySingleNestedAttribute(configData.{{ .ResourceClassName }}.Attributes()) {
					{{.ResourceClassName}}Object, _ := types.ObjectValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}Type, getEmpty{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel())
					planData.{{.ResourceClassName}} = {{.ResourceClassName}}Object
				} {{- if containsSingleNestedChildren .Children}} else {
					{{- range .Properties}}
					{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.ResourceClassName}}ConfigData.{{.Name}}
					{{- end}}
					{{.ResourceClassName}}{{.ParentHierarchy}}List = append({{.ResourceClassName}}{{.ParentHierarchy}}List, {{.ResourceClassName}}{{.ParentHierarchy}})
					{{.ResourceClassName}}Object, _ := types.ObjectValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}Type, {{ .ResourceClassName }}{{.ParentHierarchy}}List[0])
					planData.{{.ResourceClassName}} = {{.ResourceClassName}}Object
				} {{- end}}
			}
			{{- else}}
				{{- if containsSingleNestedChildren .Children}}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{ .ResourceClassName }}Type, {{ .ResourceClassName }}{{.ParentHierarchy}}List[0])
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
				{{- end}}
			{{- end}}
		{{- end}}
		{{ if .LegacyAttributes}}{{ $ResourceClassName := .ResourceClassName}}
			{{ range .LegacyAttributes}}{{$SetName := .Name}}
				{{- if and (ne .ReplacedBy.AttributeName "") (eq (getMigrationType .ValueType) "String") (isNewAttributeStringType .ReplacedBy.AttributeName) }}
		if !configData.Deprecated{{ .Name }}.IsNull() {
					{{- if .NeedsCustomType}}
			planData.{{ .Name }} = customTypes.{{$ResourceClassName}}{{.Name}}StringValue{StringValue: configData.Deprecated{{ .Name }} }
					{{- else}}
			planData.{{ .Name }} = configData.Deprecated{{ .Name }}
					{{- end}}
		}
				{{- else if and (ne .ReplacedBy.AttributeName "") (eq (getMigrationType .ValueType) "String") }}
					{{- range $.Children}}{{$ResourceName := .ResourceName}}
						{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
							{{- if eq $SetName (capitalize .PkgName)}}
		if !configData.Deprecated{{ $SetName }}.IsNull() {
			var newAttributeValues {{ $SetName }}{{.ParentHierarchy}}ResourceModel
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
									{{- else}}
			{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.SetValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, make([]{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel, 0))
									{{- end}}	
								{{- end}}
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- if eq .Name "Annotation"}}
			{{ .Name | decapitalize }}Value := planData.{{ .Name }}
									{{- else if not (isNewNamedClassAttribute $Overwrite) }}
			{{ .Name | decapitalize }}Value := basetypes.NewStringUnknown()
									{{- end}}
								{{- end}}
			if stateData != nil && !IsEmptySingleNestedAttribute(stateData.{{ $SetName }}.Attributes()) {
				stateData.{{ $SetName }}.As(ctx, &newAttributeValues, basetypes.ObjectAsOptions{})
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- if not (isNewNamedClassAttribute $Overwrite) }}
				{{ .Name | decapitalize }}Value = newAttributeValues.{{.Name}}
									{{- end}}
								{{- end}}
								{{- range .Children}}
				{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value = newAttributeValues.{{.ResourceClassName}}
								{{- end}}
			}
								{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if isNewNamedClassAttribute $Overwrite }}
										{{- if isNewNamedClassAttributeMatch $Overwrite $ResourceName}}
				{{ .Name | decapitalize }}Value := basetypes.NewStringUnknown()
				if !configData.Deprecated{{ $SetName }}.IsUnknown() {
					{{ .Name | decapitalize }}Value = basetypes.NewStringValue(GetMOName(configData.Deprecated{{ $AttributeName }}.ValueString()))
				}
										{{- end}}
									{{- end}}
								{{- end}}
			{{$SetName}} := {{$SetName}}{{$.ResourceClassName}}ResourceModel{
								{{- range .Properties}}
								{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
								{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if or (eq .Name "Annotation") (eq $AttributeName "")}}
				{{ .Name }}: {{ .Name | decapitalize }}Value,
									{{- else}}
										{{- if isNewNamedClassAttribute $Overwrite }}
											{{- if isNewNamedClassAttributeMatch $Overwrite $ResourceName}}
				{{ .Name }}: {{ .Name | decapitalize }}Value,
											{{- else}}
				{{ .Name }}: basetypes.NewStringValue(""),
											{{- end }}
										{{- else}}
				{{ .Name }}: configData.Deprecated{{ .Name }},
										{{- end}}
									{{- end}}
								{{- end}}
								{{- range .Children}}
				{{ .ResourceClassName }}: {{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value,
								{{- end}}
			}
			{{$SetName}}Object, _ := types.ObjectValueFrom(ctx, {{$SetName}}{{$.ResourceClassName}}Type, {{$SetName}})
			planData.{{$SetName}} = {{$SetName}}Object
		}			
							{{- end}}	
						{{- else}}
							{{- if isLegacyChild .PkgName $.LegacyChildren}}
								{{- if eq $SetName (capitalize .PkgName)}}
		if !configData.Deprecated{{ $SetName }}.IsNull() {
			{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
			{{.ResourceClassName}} := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
									{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
										{{- if eq .Name "Annotation"}}
				{{ .Name }}: planData.Annotation,
										{{- else if eq $AttributeName ""}}
				{{ .Name }}: basetypes.NewStringNull(),
										{{- else}}
				{{ .Name }}: {{- if isNewNamedClassAttribute $Overwrite }}basetypes.NewStringValue(GetMOName(configData.Deprecated{{ $AttributeName }}.ValueString())){{- else }}configData.Deprecated{{ .Name }}{{- end }},
										{{- end}}
									{{- end}}
			}
			{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{.ResourceClassName}})
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
		}
								{{- end }}
							{{- end }}
						{{- end }}
					{{- end }}
				{{- else if ne .ReplacedBy.AttributeName "" }}
					{{- range $.Children}}
						{{- if isLegacyChild .PkgName $.LegacyChildren}}
							{{- if eq $SetName (capitalize .PkgName)}}{{$tDn := false}}
		if !configData.Deprecated{{ $SetName }}.IsNull() {
			{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
			var attributeValues []basetypes.StringValue
			var newAttributeValues []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
			planData.Deprecated{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.{{.ResourceClassName}}.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				{{.ResourceClassName}}Value := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
					if newAttributeValue.{{ .Name }}.ValueString() == {{- if isNewNamedClassAttribute $Overwrite }}GetMOName(attributeValue.ValueString()){{- else}}attributeValue.ValueString(){{- end}} {
						{{.ResourceClassName}}Value = newAttributeValue
						foundAttributeValue = true
						break
					}
									{{- end}}
								{{- end}}
				}
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
				{{ .Name | decapitalize}}Value := basetypes.NewStringUnknown()
				if !attributeValue.IsUnknown(){
					{{ .Name | decapitalize }}Value = {{- if isNewNamedClassAttribute $Overwrite }}basetypes.NewStringValue(GetMOName(attributeValue.ValueString())){{- else}}basetypes.NewStringValue(attributeValue.ValueString()){{- end}}
				}
									{{- end}}
								{{- end}}
				{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
								{{- range .Properties}}
								{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
								{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
					{{ .Name }}: {{ .Name | decapitalize }}Value,
									{{- end}}
								{{- end}}
				}

				if foundAttributeValue {
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if and (ne .Name "TDn") (not (isNewNamedClassAttribute $Overwrite))}}
					{{ .ResourceClassName }}.{{ .Name }} = {{.ResourceClassName}}Value.{{ .Name }}
									{{- end}}
								{{- end}}
				} else {
								{{- range .Properties}}
									{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
									{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
									{{- if eq .Name "Annotation"}}
					{{ .ResourceClassName }}.{{ .Name }} = planData.Annotation
									{{- else if ne .DefaultValue ""}}
										{{- if .HasCustomType}}
					{{ .ResourceClassName }}.{{ .Name }} = customTypes.New{{.ResourceClassName}}{{.Name}}StringUnknown()
										{{- else}}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringUnknown()
										{{- end}}
									{{- else if and (ne .Name "TDn") (not (isNewNamedClassAttribute $Overwrite))}}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringUnknown()
									{{- end}}
								{{- end}}
				}
								{{- $resourceClassName:= .ResourceClassName}}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
				{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
									{{- else}}
				{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.SetValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, make([]{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel, 0))
									{{- end}}	
				{{ $resourceClassName }}.{{.ResourceClassName}} = {{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value
								{{- end}}
				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
			}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
		}
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
		{{ end }}

		{{ range .LegacyBlocks}}{{$ClassName := .ClassName}}{{$Attributes := .Attributes}}
		if !configData.Deprecated{{ capitalize .ClassName }}.IsNull() {
			{{- range $.Children}}
				{{- if isLegacyChild .PkgName $.LegacyChildren}}
					{{- if eq $ClassName .PkgName}}
			{{ .ResourceClassName }}List := make([]{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel, 0)
			var attributeValues []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModelV1
			{{- $NewProperties := getNewChildAttributes (getChildAttributesFromBlocks $ClassName $.LegacyBlocks) .Properties}}
			var newAttributeValues []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel
			if stateData != nil {
				stateData.{{.ResourceClassName}}.ElementsAs(ctx, &newAttributeValues, false)
			}
			planData.Deprecated{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			for _, attributeValue := range attributeValues {
				planned{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel{}
    			foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
							{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if and (ne $AttributeName "") (.IsRequired) (or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)) }}
					if newAttributeValue.{{ .Name }}.ValueString() == {{- if isNewNamedClassAttribute $Overwrite }}GetMOName(attributeValue.{{ $AttributeName }}.ValueString()){{- else}}attributeValue.TDn.ValueString(){{- end}} {
						planned{{ .ResourceClassName }} = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
							{{- end}}
					{{- end}}
					{{- range .Properties}}
				{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
				{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
				{{ .Name | decapitalize }}Value := basetypes.NewStringUnknown()
				if !attributeValue.{{ $AttributeName }}.IsUnknown() {
					{{ .Name | decapitalize }}Value = {{ if isNewNamedClassAttribute $Overwrite }}basetypes.NewStringValue(GetMOName(attributeValue.{{ $AttributeName }}.ValueString())){{- else}}basetypes.NewStringValue(attributeValue.TDn.ValueString()){{- end}}
				}
						{{- end}}
					{{- end}}
				{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
					{{- range .Properties}}
						{{- if or .IsRequired (eq .Name "Annotation")}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite) }}
					{{ .Name }}: {{ .Name | decapitalize }}Value,
							{{ else if eq .Name "Annotation"}}
					{{ .Name }}: planData.{{ .Name  }},
							{{- else if and (ne $AttributeName "") (not (isNewNamedClassAttribute $Overwrite)) }}
								{{- if .HasCustomType}}
					{{ .Name }}: customTypes.{{.ResourceClassName}}{{.Name}}StringValue{StringValue: attributeValue.{{ .Name }}},
								{{- else}}
					{{ .Name }}: attributeValue.{{ .Name }},
								{{- end}}
							{{- end}}
						{{- end}}
					{{- end}}
				}
					{{- range .Properties}}
						{{- if and (not .IsRequired) (ne .Name "Annotation")}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
				if !attributeValue.{{ .Name }}.IsNull() {
							{{- if .HasCustomType}}
					{{ .ResourceClassName }}.{{ .Name }} = customTypes.{{.ResourceClassName}}{{.Name}}StringValue{StringValue: attributeValue.{{ .Name }}}
							{{- else}}
					{{ .ResourceClassName }}.{{ .Name }} = attributeValue.{{ .Name }}
							{{- end}}
				} else {
							{{- if .HasCustomType}}
					{{ .ResourceClassName }}.{{ .Name }} = customTypes.{{.ResourceClassName}}{{.Name}}StringValue{StringValue: basetypes.NewStringUnknown()}
							{{- else}}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringUnknown()
							{{- end}}
				}
						{{- end}}
					{{- end}}
				if foundAttributeValue {
						{{- range $NewProperties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
					{{ .ResourceClassName }}.{{ .Name }} = planned{{ .ResourceClassName }}.{{ .Name }}
						{{- end}}
						{{- range .Properties}}
							{{- if eq .Name "Annotation"}}
					{{ .ResourceClassName }}.{{ .Name }} = planned{{ .ResourceClassName }}.{{ .Name }}
							{{- end}}
						{{- end}}
				}

					{{- $resourceClassName:= .ResourceClassName}}
					{{- range .Children}}
						{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
				{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
						{{- else}}
				{{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value, _ := types.SetValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, make([]{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel, 0))
						{{- end}}	
				{{ $resourceClassName }}.{{.ResourceClassName}} = {{ .ResourceClassName | decapitalize }}{{.ParentHierarchy}}Value
					{{- end}}
				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
			}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
		} else if !configData.{{.ResourceClassName}}.IsNull() && stateData == nil {
			setUnknownDeprecated{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModelToPlan(ctx , planData)
		}
				{{- end }}
			{{- end }}
		{{- end }}
		{{ end }}
		{{ end }}
		{{- if .LegacyAttributes}}
		
		// Workaround to compare the state with plan to avoid plan changes with only known after apply
		if stateData != nil {
			avoid{{.ResourceClassName}}PlanChangeForKnownAfterApplyOnly(ctx, planData, stateData, configData)
 		}
		{{- end}}
		
		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

{{- if .LegacyAttributes}}

	{{- if .LegacyBlocks}}
		{{- range .LegacyBlocks}}
func setUnknownDeprecated{{capitalize .ClassName}}{{$.ResourceClassName}}ResourceModelToPlan(ctx context.Context, planData *{{$.ResourceClassName}}ResourceModel) {
	var attributeValues []{{capitalize .ClassName}}{{$.ResourceClassName}}ResourceModel
	var legacyAttributeValues []{{capitalize .ClassName}}{{$.ResourceClassName}}ResourceModelV1
	planData.{{capitalize .ClassName}}.ElementsAs(ctx, &attributeValues, false)
	for i := 0; i < len(attributeValues); i++ {
		legacyAttributeValues = append(legacyAttributeValues, {{capitalize .ClassName}}{{$.ResourceClassName}}ResourceModelV1{ {{- range .Attributes}}
			{{.Name}}: basetypes.NewStringUnknown(),
			{{- end}}
		})
	}
	Deprecated{{capitalize .ClassName}}Set, _ := types.SetValueFrom(ctx, deprecated{{capitalize .ClassName}}Type, legacyAttributeValues)
	planData.Deprecated{{capitalize .ClassName}} = Deprecated{{capitalize .ClassName}}Set
}
		{{- end}}
	{{- end}}

func avoid{{.ResourceClassName}}PlanChangeForKnownAfterApplyOnly(ctx context.Context, planData, stateData, configData *{{.ResourceClassName}}ResourceModel) {
	// Set read-only and deprecated attributes in planData from stateData
	{{- range .Properties}}
		{{- if .ReadOnly}}
	planData.{{.Name}} = stateData.{{.Name}}
		{{- end}}
	{{- end}}
	{{- range .LegacyAttributes}}
		{{- if ne .ReplacedBy.AttributeName "" }}
	if configData.Deprecated{{ .Name }}.IsNull() {
		planData.Deprecated{{.Name}} = stateData.Deprecated{{.Name}}
	}
		{{- end}}
	{{- end }}
	{{- range .LegacyBlocks}}
	if configData.Deprecated{{ capitalize .ClassName }}.IsNull() {
		planData.Deprecated{{ capitalize .ClassName }} = stateData.Deprecated{{ capitalize .ClassName }}
	}
	{{- end }}

	// Compare the string representation of the planData and stateData because structs cannot be compared directly
	if fmt.Sprintf("%s", planData) != fmt.Sprintf("%s", stateData) {
	{{- range .Properties}}
		{{- if .ReadOnly}}
		planData.{{.Name}} = basetypes.NewStringUnknown()
		{{- end}}
	{{- end}}
	{{- range .LegacyAttributes}}
		{{- if ne .ReplacedBy.AttributeName "" }}
			{{- if eq (getMigrationType .ValueType) "String"}}
		if configData.Deprecated{{.Name}}.IsNull() {
			planData.Deprecated{{.Name}} = basetypes.NewStringUnknown()
		}
			{{- else if eq (getMigrationType .ValueType) "Set"}}
		if configData.Deprecated{{.Name}}.IsNull() {
			planData.Deprecated{{.Name}} = basetypes.NewSetUnknown(basetypes.StringType{})
		}
			{{- end}}
		{{- end}}
	{{- end }}
	{{- if .LegacyBlocks}}
		{{- range .LegacyBlocks}}
		if configData.Deprecated{{ capitalize .ClassName }}.IsNull() { 
			setUnknownDeprecated{{capitalize .ClassName}}{{$.ResourceClassName}}ResourceModelToPlan(ctx, planData)
		}
		{{- end}}
	{{- end}}
	}
}
{{- end}}

{{- if .TypeChanges}}
	{{- range $version, $value := .TypeChanges}}
type {{$.ResourceClassName}}ResourceModelV{{$version}} struct {
	Id types.String `tfsdk:"id"`
	{{- if $.HasParent}}
	ParentDn types.String `tfsdk:"parent_dn"`
	{{- end}}
	{{- range $.Properties}}{{$oldType := getOldType .PropertyName $value}}
		{{- if ne $oldType ""}}
	// {{.PropertyName}}
		{{- else if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- range $.Children}}{{$oldType := getOldType .PkgName $value}}
		{{- if ne $oldType ""}}
			{{- if eq $oldType "SetNestedAttribute"}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{- .ResourceName}}"`
			{{- end}}
		{{- else if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	{{ .ResourceClassName }} types.Object `tfsdk:"{{- .ResourceName}}"`
		{{- else}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{- .ResourceName}}"`
		{{- end}}
	{{- end}}
}
	{{- end}}

func (r *{{.ResourceClassName}}Resource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		{{- range $version, $value := .TypeChanges}}
		{{$version}}: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					{{- if $.HasParent}}
					"parent_dn": schema.StringAttribute{
						Required: false,
						Optional: true,
						Computed: true,
					},
					{{- end}}
					{{- range $.Properties}}{{$oldType := getOldType .PropertyName $value}}
						{{- if ne $oldType ""}}
					// {{.PropertyName}} // Add logic when needed, current no type change on properties
						{{- else }}
					"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
						Required: {{- if or .IsNaming .IsRequired}}true{{else}}false{{end}},
						Optional: {{- if not .ReadOnly}}true{{else}}false{{end}},
						Computed: true,
					},
						{{- end}}
					{{- end}}
					{{- range $.Children}}{{$oldType := getOldType .PkgName $value}}
						{{- if ne $oldType ""}}
							{{- if eq $oldType "SetNestedAttribute"}}
					"{{- .ResourceName}}": schema.SetNestedAttribute{
						Required: false,
						Optional: true,
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
							{{- range .Properties}}{{$oldType := getOldType .PropertyName $value}}
								{{- if ne $oldType ""}}
								// {{.PropertyName}} // Add logic when needed, current no type change on properties
								{{- else }}
								"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
									Required: {{- if or .IsNaming .IsRequired}}true{{else}}false{{end}},
									Optional: {{- if or .IsNaming .IsRequired}}false{{else}}true{{end}},
									Computed: {{- if or .IsNaming .IsRequired}}false{{else}}true{{end}},
								},
								{{- end}}
							{{- end}}
							},
						},
					},
							{{- end}}
						{{- else if or (not .IdentifiedBy) .MaxOneClassAllowed}}
					// "{{- .ResourceName}}" map
						{{- else}}
					"{{- .ResourceName}}": schema.SetNestedAttribute{
						Required: false,
						Optional: true,
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
							{{- range .Properties}}{{$oldType := getOldType .PropertyName $value}}
								{{- if ne $oldType ""}}
								// {{.PropertyName}} // Add logic when needed, current no type change on properties
								{{- else }}
								"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
									Required: {{- if or .IsNaming .IsRequired}}true{{else}}false{{end}},
									Optional: {{- if or .IsNaming .IsRequired}}false{{else}}true{{end}},
									Computed: {{- if or .IsNaming .IsRequired}}false{{else}}true{{end}},
								},
								{{- end}}
							{{- end}}
							},
						},
					},
						{{- end}}
	{{- end}}
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData {{$.ResourceClassName}}ResourceModelV{{$version}}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := {{$.ResourceClassName}}ResourceModel{
					Id:         priorStateData.Id,
					{{- if $.HasParent}}
					ParentDn:   priorStateData.ParentDn,
					{{- end}}
					{{- range $.Properties}}{{$oldType := getOldType .PropertyName $value}}
						{{- if ne $oldType ""}}
					// {{.PropertyName}} // Add logic when needed, current no type change on properties
						{{- else }}
					{{ .Name }}: priorStateData.{{ .Name }},
						{{- end}}
					{{- end}}
					{{- range $.Children}}{{$oldType := getOldType .PkgName $value}}
						{{- if ne $oldType ""}}
					{{.ResourceClassName}}: types.ObjectNull({{.ResourceClassName}}{{$.ResourceClassName}}Type),
						{{- else }}
					{{ .ResourceClassName }}: priorStateData.{{ .ResourceClassName }},
						{{- end}}
					{{- end}}
				}

				{{- range $.Children}}{{$oldType := getOldType .PkgName $value}}
					{{- if ne $oldType ""}}
				
				var {{.ResourceClassName}}{{$.ResourceClassName}}List []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
				priorStateData.{{.ResourceClassName}}.ElementsAs(ctx, &{{.ResourceClassName}}{{$.ResourceClassName}}List, false)

				if len({{.ResourceClassName}}{{$.ResourceClassName}}List) > 0 {
					{{.ResourceClassName}}Object, _ := types.ObjectValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}Type, {{.ResourceClassName}}{{$.ResourceClassName}}List[0])
					upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Object
				}
					{{- end}}
				{{- end}}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
		{{- end}}
	}
}

{{- end }}

func (r *{{.ResourceClassName}}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_{{.ResourceName}}")
	resp.TypeName = req.ProviderTypeName + "_{{.ResourceName}}"
	tflog.Debug(ctx, "End metadata of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_{{.ResourceName}}")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The {{.ResourceName}} resource for the '{{.PkgName}}' class",
		{{- if .LegacyAttributes}}
		Version: {{add .LegacySchemaVersion 1}},
		{{- else if .LegacySchemaVersion}}
		Version: {{.LegacySchemaVersion}},
		{{- end}}
		{{- if .TypeChanges}}
		Version: {{.SchemaVersion}},
		{{- end}}

		Attributes: map[string]schema.Attribute{
			{{- if .LegacyAttributes}}{{$ResourceName := .ResourceName}}
			// Deprecated attributes
				{{- range .LegacyAttributes}}
					{{- if ne .ReplacedBy.AttributeName "" }}
						{{- if eq (getMigrationType .ValueType) "String"}}
			"{{.AttributeName}}": schema.StringAttribute{
				Optional: true,
				Computed: true,
				DeprecationMessage: "Attribute '{{.AttributeName}}' is deprecated, please refer to '{{.ReplacedBy.AttributeName}}' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "Set"}}
			"{{.AttributeName}}": schema.SetAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute '{{.AttributeName}}' is deprecated, please refer to '{{.ReplacedBy.AttributeName}}' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "List"}}
			"{{.AttributeName}}": schema.ListAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute '{{.AttributeName}}' is deprecated, please refer to '{{.ReplacedBy.AttributeName}}' instead. The attribute will be removed in the next major version of the provider.",
				Validators: []validator.List{
					listvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
					{{- else if containsString .Name .AttributeName}}
						{{- if eq (getMigrationType .ValueType) "String"}}
			"{{.AttributeName}}": schema.StringAttribute{
				Optional: true,
				Computed: true,
				DeprecationMessage: "Attribute `{{.AttributeName}}` is deprecated. The attribute will be removed in the next major version of the provider.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "Set"}}
			"{{.AttributeName}}": schema.SetAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute `{{.AttributeName}}` is deprecated. The attribute will be removed in the next major version of the provider.",
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "List"}}
			"{{.AttributeName}}": schema.ListAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute `{{.AttributeName}}` is deprecated. The attribute will be removed in the next major version of the provider.",
				PlanModifiers: []planmodifier.List{
					listplanmodifier.UseStateForUnknown(),
				},
			},
						{{- end}}
					{{- end}}
				{{- end}}
			// End of deprecated attributes
			{{- end}}
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the {{getResourceNameAsDescription .ResourceName $.Definitions}} object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			{{- if .HasParent}}
			"parent_dn": schema.StringAttribute{
				{{- $LegacyAttributeName := getPropertyNameForLegacyAttribute "parent_dn" $.LegacyAttributes}}
				{{- if ne $LegacyAttributeName ""}}
				Optional: true,
				Computed: true,
				{{- else if getDefaultValues .PkgName "parent_dn" $.Definitions}}
				Optional:            true,
				Computed:            true,
				Default: 			 stringdefault.StaticString("{{getDefaultValues .PkgName "parent_dn" $.Definitions}}"),
				{{- else}}
				Required:            true,
				{{- end}}
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
				{{- if ne $LegacyAttributeName ""}}
				Validators: []validator.String{
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("{{$LegacyAttributeName}}"),
					}...),
				},
				{{- end}}
			},
			{{- end}}
			{{- range .Properties}}
			{{- $OverwritePropertyName := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
			{{- $LegacyAttributeName := getPropertyNameForLegacyAttribute $OverwritePropertyName $.LegacyAttributes}}
				{{- if eq .ValueType "bitmask"}}
			"{{$OverwritePropertyName}}": schema.SetAttribute{
				MarkdownDescription: `{{.Comment}}`,
					{{- if not .ReadOnly }}
				Optional:            true,
					{{- end }}
				{{- if ne .ValueType "password"}}
				Computed:            true,
				{{- else}}
				Sensitive:           true,
				{{- end}}
				{{- if not .ReadOnly }}
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
					SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(nil),

				},
				{{- end}}
					{{- if .ValidValues}}
				Validators: []validator.Set{
					setvalidator.SizeAtMost({{ len .ValidValues }}),
					setvalidator.ValueStringsAre(
						stringvalidator.OneOf({{- validatorString .ValidValues}}),
					),
				},
					{{- end}}
				ElementType: types.StringType,
			},
				{{- else}}
			"{{$OverwritePropertyName}}": schema.StringAttribute{
					{{- if .HasCustomType}}
				CustomType: customTypes.{{.ResourceClassName}}{{.Name}}StringType{},
					{{- end}}
					{{- if or .IsNaming .IsRequired}}
						{{- if ne $LegacyAttributeName ""}}
							{{- if not .ReadOnly }}
				Optional: true,
							{{- end }}
				Computed: true,
						{{else if $.HasReadOnlyProperties}}
				Optional: true,
				Computed: true,
						{{- else}}
				Required:            true,
						{{- end}}
					{{- else }}
				{{- if not .ReadOnly }}
				Optional:            true,
				{{- end }}
				{{- if ne .ValueType "password"}}
				Computed:            true,
				{{- else}}
				Sensitive:            true,
				{{- end}}
					{{- end}}
				{{- if not .ReadOnly }}
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					{{- if or .IsNaming .CreateOnly}}
					stringplanmodifier.RequiresReplace(),
					{{- end}}
				},
				{{- end}}
					{{- if eq .Name "Annotation"}}
				Default: stringdefault.StaticString(globalAnnotation),
					{{- end}}
					{{- if .HasCustomType}}
				Validators: []validator.String{
					stringvalidator.Any(
						stringvalidator.OneOf({{- validatorStringCustomType .ValidValues .ValidValuesMap}}),
						validators.InBetweenFromString({{- index .Validators 0 "min"}}, {{- index .Validators 0 "max"}}),
					),
				},
					{{- else if or .ValidValues (ne $LegacyAttributeName "")}}
				Validators: []validator.String{
						{{- if .ValidValues}}
					stringvalidator.OneOf({{- validatorString .ValidValues}}),
						{{- end}}
						{{- if and (ne $LegacyAttributeName "") (or .IsNaming .IsRequired)}}
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("{{$LegacyAttributeName}}"),
					}...),
						{{- end}}
				},
				    {{- else if and (or .IsNaming .IsRequired) $.HasReadOnlyProperties}}
				Validators: []validator.String{
					MakeStringRequired(),
				},
					{{- end}}
				MarkdownDescription: `{{.Comment}}`,
			},
				{{- end}}
			{{- end}}
			{{- range .Children}}
				{{- $newCtx := addToTemplateProperties . "HasReadOnlyProperties" $.HasReadOnlyProperties -}}
				{{- template "childAttributes" $newCtx }}
			{{- end}}	
		},
		{{- if .LegacyAttributes}}
		Blocks: map[string]schema.Block{
			{{- range .LegacyBlocks}}
			"{{ .Name }}": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
					{{- range .Attributes}}
						{{- if eq (getMigrationType .ValueType) "String"}}
						"{{.AttributeName}}": schema.StringAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
								{{- if .Required }}
								MakeStringRequired(),
								{{- end }}
							},
						},
							{{- end}}
							{{- if eq (getMigrationType .ValueType) "Set"}}
						"{{.AttributeName}}": schema.SetAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.Set{
								setvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
							},
						},
							{{- end}}
							{{- if eq (getMigrationType .ValueType) "List"}}
						"{{.AttributeName}}": schema.ListAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.List{
								listvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
							},	
						},
						{{- end}}
					{{- end}}
					},
				},
			},
			{{- end }}
		},
		{{- end}}
	}
	tflog.Debug(ctx, "End schema of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_{{.ResourceName}}")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_{{.ResourceName}}")
	
	{{- if .HasChild }}
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *{{ .ResourceClassName }}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		set{{.ResourceClassName}}Id(ctx, stateData)
	}
	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The {{.PkgName}} object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	} 
	{{- end}}

	var data *{{ .ResourceClassName }}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	
	if data.Id.IsUnknown() || data.Id.IsNull() {
		set{{.ResourceClassName}}Id(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{ if not .MultiParentFormats }}
	{{ if .HasChild}}
		{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	var {{.PkgName}}Plan, {{.PkgName}}State {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	data.{{ .ResourceClassName }}.As(ctx, &{{.PkgName}}Plan, basetypes.ObjectAsOptions{})
	stateData.{{ .ResourceClassName }}.As(ctx, &{{.PkgName}}State, basetypes.ObjectAsOptions{})
			{{- else}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
			{{- end}}
		{{- end}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, true, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, true, data)
	{{- end}}

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	{{- else }}
	{{- if .HasChild }}
			{{- range .Children }}
	var {{ .PkgName }}Plan, {{ .PkgName }}State []{{ .ResourceClassName }}{{ $.ResourceClassName }}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .PkgName }}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .PkgName }}State, false)
			{{- end }}
	jsonPayload := get{{ .ResourceClassName }}CreateJsonPayload(ctx, &resp.Diagnostics, true, data{{- range .Children }}, {{ .PkgName }}Plan, {{ .PkgName }}State{{- end }})    
		{{- else }}
	jsonPayload := get{{ .ResourceClassName }}CreateJsonPayload(ctx, &resp.Diagnostics, true, data)
		{{- end }}

	if resp.Diagnostics.HasError() {
		return
	}

	wrapperClassMap := map[string]string{ {{- range $key, $value := .MultiParentFormats }} "{{ $value.RnPrepend }}": "{{ $value.WrapperClass }}", {{- end }} }
	for rnPrepend, wrapperClass := range wrapperClassMap {
		if strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass != "" {
			DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s%s.json", strings.Split(data.Id.ValueString(), rnPrepend)[0], rnPrepend), "POST", jsonPayload)
			break
		} else if strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass == "" {
			DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
			break
		}
	}
	{{- end }}

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *{{.ResourceClassName}}ResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel
		{{- if .HasChild }}
    var stateData *{{ .ResourceClassName }}ResourceModel
		{{- end }}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	{{- if .HasChild}}
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		{{- range .Children}}
			{{- if and (or (not .IdentifiedBy) .MaxOneClassAllowed) (not .AllowDelete)}}
	// Error out when child object {{.PkgName}} is being deleted
	if IsEmptySingleNestedAttribute(data.{{ .ResourceClassName }}.Attributes()) && !IsEmptySingleNestedAttribute(stateData.{{ .ResourceClassName }}.Attributes()) {
		resp.Diagnostics.AddError(
			"{{ .ResourceClassName }} object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
			{{- end}}
		{{- if containsDeletableSingleNestedChildren .Children}}
		{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		var {{ .ResourceClassName }}Data {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		var {{ .ResourceClassName }}StateData {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		data.{{ .ResourceClassName }}.As(ctx, &{{ .ResourceClassName }}Data, basetypes.ObjectAsOptions{})
		stateData.{{ .ResourceClassName }}.As(ctx, &{{ .ResourceClassName }}StateData, basetypes.ObjectAsOptions{})
		{{- else}}
		var {{ .ResourceClassName }}Data []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		var {{ .ResourceClassName }}StateData []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
		data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .ResourceClassName }}Data, false)
		stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .ResourceClassName }}StateData, false)
		{{- end}}
		{{- $resource := . }}
		{{- range .Children}}
			{{- $newCtx := addToTemplateProperties . "data" $resource -}}
			{{- template "isDeleteAllowedForSingleNestedChildren" $newCtx }}
		{{- end}}
		{{- end}}
		{{- end}}
	{{- end}}

if resp.Diagnostics.HasError() {
    return
}

tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_{{ .ResourceName }} with id '%s'", data.Id.ValueString()))

{{ if not .MultiParentFormats }}
	{{ if .HasChild}}
		{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	var {{.PkgName}}Plan, {{.PkgName}}State {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.As(ctx, &{{.PkgName}}Plan, basetypes.ObjectAsOptions{})
	stateData.{{ .ResourceClassName }}.As(ctx, &{{.PkgName}}State, basetypes.ObjectAsOptions{})
			{{- else}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
			{{- end}}
		{{- end}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, false, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, false, data)
	{{- end}}
	
	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
{{- else }}
	{{- if .HasChild }}
        {{- range .Children }}
    var {{ .PkgName }}Plan, {{ .PkgName }}State []{{ .ResourceClassName }}{{ $.ResourceClassName }}ResourceModel
    data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .PkgName }}Plan, false)
    stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{ .PkgName }}State, false)
        {{- end }}
    jsonPayload := get{{ .ResourceClassName }}CreateJsonPayload(ctx, &resp.Diagnostics, false, data{{- range .Children }}, {{ .PkgName }}Plan, {{ .PkgName }}State{{- end }})
    {{- else }}
    jsonPayload := get{{ .ResourceClassName }}CreateJsonPayload(ctx, &resp.Diagnostics, false, data)
    {{- end }}

    if resp.Diagnostics.HasError() {
        return
    }

    wrapperClassMap := map[string]string{
        {{- range $key, $value := .MultiParentFormats }}
        "{{ $value.RnPrepend }}": "{{ $value.WrapperClass }}",
        {{- end }}
    }
    for rnPrepend, wrapperClass := range wrapperClassMap {
        if strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass != "" {
            DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s%s.json", strings.Split(data.Id.ValueString(), rnPrepend)[0], rnPrepend), "POST", jsonPayload)
			break
        } else if strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass == "" {
            DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
			break
        }
    }
{{- end }}

	if resp.Diagnostics.HasError() {
		return
	}

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{- if .AllowDelete}}
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "{{.PkgName}}", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	{{- else}}
	parentDnMessage := "Delete on apic is only possible when deleting the parent object with dn"
	parentDn := data.Id.ValueString()
	if parentDn == "" {
		parentDnMessage = fmt.Sprintf("%s.", parentDnMessage)
	} else {
		parentDnMessage = fmt.Sprintf("%s '%s'.", parentDnMessage, parentDn)
	}
	message := fmt.Sprintf("resource with dn '%s' not removed from apic", data.Id.ValueString())
	messageDetail := fmt.Sprintf("Only removing resource from state because apic does not allow deletion of class '{{.PkgName}}' objects. %s", parentDnMessage)
	resp.Diagnostics.AddWarning(message, messageDetail)
	{{- end}}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_{{.ResourceName}}")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	
	var stateData *{{.ResourceClassName}}ResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_{{.ResourceName}} with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_{{.ResourceName}}")
}

func getAndSet{{.ResourceClassName}}Attributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *{{.ResourceClassName}}ResourceModel) {
	{{- if .HasChild}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=full&rsp-subtree-class=%s", data.Id.ValueString(), "{{- .PkgName}},{{ template "rspSubtreeClassFilter" . }}"), "GET", nil)
	{{- else}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "GET", nil)
	{{- end}}

	readData := getEmpty{{.ResourceClassName}}ResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("{{.PkgName}}").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("{{.PkgName}}").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					readData.Id = basetypes.NewStringValue(attributeValue.(string))
					{{- if .HasParent}}
					set{{.ResourceClassName}}ParentDn(ctx, attributeValue.(string), readData)
					{{- end}}
				}
				{{- range .Properties}}
					{{- if eq .ValueType "bitmask"}}
				if attributeName == "{{.PropertyName}}" {
					{{.PropertyName}}List := make([]string, 0)
					if attributeValue.(string) != "" {
                        {{.PropertyName}}List = strings.Split(attributeValue.(string), ",")
                    }
					{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, readData.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
					readData.{{.Name}} = {{.PropertyName}}Set
				}
					{{- else if eq .ValueType "password"}}
					    // Sensitive attributes are not returned by the APIC, so they are explicitly set to their current state values.
						readData.{{.Name}} = data.{{.Name}}
					{{- else}}
						{{- if containsNoneAttributeValue .ValidValues}}
				if attributeName == "{{.PropertyName}}" && attributeValue.(string) == "" {
					readData.{{.Name}} = basetypes.NewStringValue("none")
				} else if attributeName == "{{.PropertyName}}" {
					readData.{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
				}
						{{- else}}
				if attributeName == "{{.PropertyName}}" {
							{{- if .HasCustomType}}
					readData.{{.Name}} = customTypes.New{{.ResourceClassName}}{{.Name}}StringValue(attributeValue.(string))
							{{- else}}
					readData.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(attributeValue.(string))
							{{- end}}
				}
						{{- end}}
					{{- end}}
				{{- end}}
			}

			{{- if .HasChild}}
				{{- range .Children}}
					{{- template "declareChildListsInGetandSetAttributesFunction" . }}
				{{- end}}
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						{{- range .Children}}
						if childClassName == "{{ .PkgName }}" {
							{{.ResourceClassName}}{{.ParentHierarchy}} := getEmpty{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								{{- range .Properties}}
									{{- if eq .ValueType "bitmask"}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), []string{"none"})
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									var data{{.ResourceClassName}}{{$.ResourceClassName}} []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
									data.{{.ResourceClassName}}.ElementsAs(ctx,&data{{.ResourceClassName}}{{$.ResourceClassName}},false)
									for _, {{.ResourceClassName | decapitalize}} := range data{{.ResourceClassName}}{{$.ResourceClassName}} {
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName | decapitalize}}.{{.Name}}.ElementType(ctx),{{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
									}
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, basetypes.StringType{},{{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
									
								}
										{{- end}}
									{{- else}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue("none")
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
											{{- if .HasCustomType}}
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = customTypes.New{{.ResourceClassName}}{{.Name}}StringValue(childAttributeValue.(string))
											{{- else}}
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(childAttributeValue.(string))
											{{- end}}
								}
										{{- end}}
									{{- end}}
								{{- end}}
								{{/* $enteredGrandChildGetAndSetAttributesZone is used here because the presence of grand children is unknown while rendering the template unlike .HasChild used for the immediate children. It is also used because there can be more than one grandchild in the same level. */}}
								{{- $enteredGrandChildGetAndSetAttributesZone := false }}
								{{- $children := .Children }} 
								{{- range .Children}}
									{{- if not $enteredGrandChildGetAndSetAttributesZone }}
										{{- $enteredGrandChildGetAndSetAttributesZone = true }}
										}
										{{- range $children}}
										{{ .ResourceClassName }}{{.ParentHierarchy}}List := make([]{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel, 0)
										{{- end}}
										childrenOf{{.ParentHierarchy}}, childrenOf{{.ParentHierarchy}}Exist:= childClassDetails.(map[string]interface{})["children"]
										if childrenOf{{.ParentHierarchy}}Exist {
										for _, child{{.ParentHierarchy}} := range childrenOf{{.ParentHierarchy}}.([]interface{}) {
											for childClassName{{.ParentHierarchy}}, childClassDetails{{.ParentHierarchy}} := range child{{.ParentHierarchy}}.(map[string]interface{}) {
									{{- end}}
								    {{- template "getAndSetGrandChildren" . }}
								{{- end }}
								{{- if $enteredGrandChildGetAndSetAttributesZone }}
										}
									}
								}
								{{- range .Children}}
									{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
								if len({{.ResourceClassName}}{{.ParentHierarchy}}List) == 1 {
									{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{ .ResourceClassName }}{{.ParentHierarchy}}List[0])
									{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
								} else {
									{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
									{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
								}
										{{- else}}
								{{.ResourceClassName}}{{.ParentHierarchy}}Set,_ := types.SetValueFrom(ctx,{{.ResourceClassName}}{{.ParentHierarchy}}Type,{{.ResourceClassName}}{{.ParentHierarchy}}List)
								{{.ParentHierarchy}}.{{.ResourceClassName}} = {{.ResourceClassName}}{{.ParentHierarchy}}Set
										{{- end}}
								{{- end}}
								{{- else}}
								}
								{{- end}}
							{{.ResourceClassName}}{{$.ResourceClassName}}List = append({{.ResourceClassName}}{{$.ResourceClassName}}List, {{.ResourceClassName}}{{$.ResourceClassName}})
							}
						{{- end}}
						}
				}
			}
				{{- range .Children}}
					{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			if len({{.ResourceClassName}}{{$.ResourceClassName}}List) == 1 {
				{{ .PkgName }}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{$.ResourceClassName}}Type, {{ .ResourceClassName }}{{$.ResourceClassName}}List[0])
				readData.{{ .ResourceClassName }} = {{ .PkgName }}Object
			} else {
				{{ .PkgName }}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{$.ResourceClassName}}Type, getEmpty{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel())
				readData.{{ .ResourceClassName }} = {{ .PkgName }}Object
			}
					{{- else}}
			{{ .PkgName }}Set, _ := types.SetValueFrom(ctx, readData.{{ .ResourceClassName }}.ElementType(ctx), {{ .ResourceClassName }}{{$.ResourceClassName}}List)
			readData.{{ .ResourceClassName }} = {{ .PkgName }}Set
					{{- end}}
				{{- end}}
			{{- end}}
			{{- if .LegacyAttributes}}
			set{{ .ResourceClassName }}LegacyAttributes(ctx, diags, readData, data, classReadInfo)
			{{- end}}
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class '{{.PkgName}}'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		readData.Id = basetypes.NewStringNull()
	}
	*data = *readData
}

func get{{.ResourceClassName}}Rn(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) string {
	return fmt.Sprintf("{{getRnFormat .RnFormat .IdentifiedBy}}", {{$i := 1}}{{$length := len .IdentifiedBy}}{{ range .IdentifiedBy}}data.{{capitalize .}}{{- if identifierIsCustomType . $.Properties}}.NamedValueString(){{else}}.ValueString(){{end}}{{ if ne $length $i}}{{$i = add $i 1}}, {{end}}{{- end}})
}

{{ if .HasParent}}
func set{{.ResourceClassName}}ParentDn(ctx context.Context, dn string, data *{{.ResourceClassName}}ResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	{{- if .MultiParentFormats }}
	parentDn := dn[:rnIndex]
    rnMap := map[string]string{
        {{- range $key, $value := .MultiParentFormats }}
            {{- if ne $key "default" }}
        "{{ $key }}": "{{ $value.RnPrepend }}",
            {{- end }}
        {{- end }}
    }
    for parentIdentifier, rnPrepend := range rnMap {
        if strings.Contains(parentDn, parentIdentifier) {
            parentDn = parentDn[:strings.Index(parentDn, fmt.Sprintf("/%s", rnPrepend))]
			break
        }
    }
	data.ParentDn = basetypes.NewStringValue(parentDn)
	{{- else if eq .RnPrepend ""}}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
	{{- else}}
	parentDn := dn[:rnIndex]
	parentDn = parentDn[:strings.Index(parentDn, "/{{.RnPrepend}}")]
	data.ParentDn = basetypes.NewStringValue(parentDn)
	{{- end}}
}
{{- end}}

func set{{.ResourceClassName}}Id(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) {
	rn := get{{.ResourceClassName}}Rn(ctx, data)
	{{- if .MultiParentFormats }}
	parentDn := data.ParentDn.ValueString()
	rnMap := map[string]string{
        {{- range $key, $value := .MultiParentFormats }}
			{{- if ne $key "default" }}
        "{{ $key }}": "{{ $value.RnPrepend }}",
			{{- end }}
        {{- end }}
    }
	id :=  fmt.Sprintf("%s/%s", parentDn, rn)
    for parentIdentifier, rnPrepend := range rnMap {
         if strings.Contains(parentDn, parentIdentifier) {
		 id = fmt.Sprintf("%s/%s/%s", parentDn, rnPrepend, rn)
			break
        }
    }
	data.Id = types.StringValue(id)
	{{- else }}
		{{- if .HasParent}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
		{{- else}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", strings.Split([]string{ {{- fromInterfacesToString .DnFormats}} }[0], "/")[0], rn))
		{{- end}}
	{{- end}}
}


{{ range .Children}}
{{- $child:= .}}
func get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *{{$.ResourceClassName}}ResourceModel, {{.PkgName}}{{.ParentHierarchy}}Plan, {{.PkgName}}{{.ParentHierarchy}}State {{if not ( or (not .IdentifiedBy) .MaxOneClassAllowed)}}[]{{end}}{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel) []map[string]interface{} {
	childPayloads := []map[string]interface{}{}
	{{- $enteredGrandChildDeclarationZone := false }}
    {{- range .Children}}   
    	{{- $enteredGrandChildDeclarationZone = true }}
    	{{- template "grandChildDeclarationInChildPayloadFunction" . }}
    {{- end}}
	if !data.{{.ResourceClassName}}.IsNull() && !data.{{.ResourceClassName}}.IsUnknown() {
        {{- if and (and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))) (not (or (not .IdentifiedBy) .MaxOneClassAllowed))}}
        {{ .PkgName }}Identifiers := []{{.ResourceClassName}}Identifier{}
        {{- end}}
        		{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		{{.ResourceClassName}}{{.ParentHierarchy}}Children := make([]map[string]interface{}, 0)
		childMap := NewAciObject()
		if !IsEmptySingleNestedAttribute(data.{{ .ResourceClassName }}.Attributes()) {
			{{- range .Properties}}
				if !{{ .PkgName }}{{$child.ParentHierarchy}}Plan.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown() &&  !{{ .PkgName }}{{$child.ParentHierarchy}}Plan.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull(){
				{{- if eq .ValueType "bitmask"}}
					var tmp{{ .Name }} []string
					{{ .PkgName }}{{$child.ParentHierarchy}}Plan.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
					childMap.Attributes["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")				
				{{- else if eq .Name "Id"}}
					childMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$child.ParentHierarchy}}Plan.{{.ResourceClassName}}{{ .Name }}.ValueString()
				{{- else}}
					childMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$child.ParentHierarchy}}Plan.{{ .Name }}.ValueString()
				{{- end}}
				} {{- if eq .Name "Annotation" }} else {
					childMap.Attributes["annotation"] = globalAnnotation
				} {{- end}}
			{{- end}}
		}{{- if .AllowDelete}} else {
			{{- range .Properties}}
				{{- if .IsNaming }}
			childMap.Attributes["{{.PropertyName}}"] = {{.PkgName}}{{$child.ParentHierarchy}}State.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
				{{- end}}
			{{- end}}
			childMap.Attributes["status"] = "deleted"
		}{{- end}}
		{{- $enteredGrandChildPayloadZone := false }}
			{{- range .Children}}
				{{- $enteredGrandChildPayloadZone = true }}
                {{- template "grandChildPayload" . }}
            {{- end}}
		{{- range .Children}}
		{{- if $enteredGrandChildPayloadZone }}
		{{- $enteredGrandChildPayloadZone = false }}
		childMap.Children = {{.ParentHierarchy}}Children
		{{- end}}
		{{- end}}
		childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
		{{- else}}
	for _, {{ .PkgName }}{{.ParentHierarchy}} := range {{ .PkgName }}{{.ParentHierarchy}}Plan {
			{{- if $enteredGrandChildDeclarationZone }}
			{{- $enteredGrandChildDeclarationZone = false }}
			{{.ResourceClassName}}{{.ParentHierarchy}}Children := make([]map[string]interface{}, 0)
			{{- end}}
			childMap := NewAciObject()
            {{- range .Properties}}
            if !{{ .PkgName }}{{$child.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull() && !{{ .PkgName }}{{$child.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
                {{- if eq .ValueType "bitmask"}}
                var tmp{{ .Name }} []string
                {{ .PkgName }}{{$child.ParentHierarchy}}.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
                childMap.Attributes["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")                
                {{- else if eq .Name "Id"}}
                childMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$child.ParentHierarchy}}.{{.ResourceClassName}}{{ .Name }}.ValueString()
                {{- else}}
                childMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$child.ParentHierarchy}}.{{ .Name }}.ValueString()
                {{- end}}
            } {{- if eq .Name "Annotation" }} else {
                childMap.Attributes["annotation"] = globalAnnotation
            } {{- end}}
			{{- end}}
			{{- $enteredGrandChildPayloadZone := false }}
			{{- range .Children}}
				{{- $enteredGrandChildPayloadZone = true }}
				{{- $newCtx := addToTemplateProperties . "AlreadyInPlan" true -}}
                {{- template "grandChildPayload" $newCtx }}
            {{- end}}
		{{- range .Children}}
		{{- if $enteredGrandChildPayloadZone }}
		{{- $enteredGrandChildPayloadZone = false }}
		childMap.Children = {{.ParentHierarchy}}Children
		{{- end}}
		{{- end}}
		childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
		{{- if and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))}}
			{{ .PkgName }}Identifier := {{ .ResourceClassName }}Identifier{}
					{{- range .Properties}}
						{{- if .IsNaming}}
							{{- if .HasCustomType}}
			{{ .PkgName }}Identifier.{{.Name}} = basetypes.NewStringValue({{ .PkgName }}{{$child.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}.ValueString(){{ .Name }}{{- else}}{{.Name}}.ValueString(){{- end}})
							{{- else}}
			{{ .PkgName }}Identifier.{{.Name}} = {{ .PkgName }}{{$child.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}
							{{- end}}
						{{- end}}
					{{- end}}
			{{ .PkgName }}Identifiers = append({{ .PkgName }}Identifiers, {{ .PkgName }}Identifier)
			{{- end}}
		}
			{{- if and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))}}
		for _, {{ .PkgName }} := range {{ .PkgName }}{{.ParentHierarchy}}State {
			delete := true
			for _, {{ .PkgName }}Identifier := range {{ .PkgName }}Identifiers { {{$i := 1}}{{$length := len .IdentifiedBy}}
				if 
					{{- range .Properties}}
						{{- if .IsNaming }}
							{{- if .HasCustomType}}
					{{ .PkgName }}Identifier.{{.Name}} == basetypes.NewStringValue({{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}.ValueString(){{ .Name }}{{- else}}{{.Name}}.ValueString(){{- end}}){{- if ne $length $i}} {{$i = add $i 1}} && {{- end}}
							{{- else}}
					{{ .PkgName }}Identifier.{{.Name}} == {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}{{- if ne $length $i}} {{$i = add $i 1}} && {{- end}}
							{{- end}}
						{{- end}}
					{{- end}} {
					delete = false
					break
				}
			}
			if delete {
				{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete := NewAciObject()
				{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["status"] = "deleted"
			{{- range .Properties}}
				{{- if .IsNaming }}
				{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["{{.PropertyName}}"] = {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
				{{- end}}
			{{- end}}
				childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": {{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete})
			}
		}
		{{- else}}
			{{- if not (or (not .IdentifiedBy) .MaxOneClassAllowed)}}
		if len({{ .PkgName }}{{.ParentHierarchy}}Plan) == 0 && len({{ .PkgName }}{{.ParentHierarchy}}State) == 1 {
			{{- if .AllowDelete}}
			{{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete := NewAciObject()
			{{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete.Attributes["status"] = "deleted"
						{{- if .IdentifiedBy}}
							{{- range .Properties}}
								{{- if .IsNaming }}
			{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["{{.PropertyName}}"] = {{ .PkgName }}State[0].{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
								{{- end}}
							{{- end}}
						{{- end}}
			childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": {{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete})
			{{- else}}
			diags.AddError(
				"{{ .ResourceClassName }} object cannot be deleted",
				"deletion of child is only possible upon deletion of the parent",
			)
			return nil
					{{- end }}
		}
				{{- end}}
			{{- end}}
		{{- end}}
	} else {
		{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		{{ .ResourceClassName }}Object, _ := types.ObjectValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}Type, getEmpty{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel())
		data.{{ .ResourceClassName }} = {{ .ResourceClassName }}Object
		{{- else}}
		data.{{ .ResourceClassName }} = types.SetNull(data.{{ .ResourceClassName }}.ElementType(ctx))
		{{- end}}
	}

	return childPayloads
}
{{ end}}

func get{{.ResourceClassName}}CreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *{{.ResourceClassName}}ResourceModel{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State {{if not ( or (not .IdentifiedBy) .MaxOneClassAllowed)}}[]{{end}}{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{{- end}}) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}

	{{- if .HasChild}}
	childPayloads := []map[string]interface{}{}
		{{ range .Children}}
	{{ .ResourceClassName }}childPayloads := get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx, diags, data, {{.PkgName}}Plan, {{.PkgName}}State)
	if {{ .ResourceClassName }}childPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, {{ .ResourceClassName }}childPayloads...)

		{{ end}}
	payloadMap["children"] = childPayloads
	{{- end}}

	{{- range .Properties}}{{- if not .ReadOnly}}
		{{- if eq .ValueType "bitmask"}}
	if !data.{{ .Name }}.IsNull() && !data.{{ .Name }}.IsUnknown() {
		var tmp{{ .Name }} []string
		data.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")
	}
		{{- else}}
	if !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull() && !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
	}
		{{- end}}
	{{- end}}{{- end}}
	{{- if .MultiParentFormats }}
	wrapperClassMap := map[string]string{
        {{- range $key, $value := .MultiParentFormats }}
        "{{ $value.RnPrepend }}": "{{ $value.WrapperClass }}",
        {{- end }}
    }

    var payload []byte
    var err error
    for rnPrepend, wrapperClass := range wrapperClassMap {
        if strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass != "" && createType {
            wrapperPayloadMap := map[string]interface{}{
                wrapperClass: map[string]interface{}{
                    "attributes": map[string]interface{}{},
                    "children":   []interface{}{map[string]interface{}{"{{ .PkgName }}": payloadMap}},
                },
            }
            payload, err = json.Marshal(wrapperPayloadMap)
			break
        } else if (strings.Contains(data.Id.ValueString(), rnPrepend) && wrapperClass == "") || !createType {
            payload, err = json.Marshal(map[string]interface{}{"{{ .PkgName }}": payloadMap})
			break
        }
    }
	{{- else }}
	payload, err := json.Marshal(map[string]interface{}{"{{.PkgName}}": payloadMap})
	{{- end}}
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}


{{/* Sub Templates */}}

{{/* A sub template for the child structs used in the structs definiton section. */}}
{{- define "childStructsAndAttributeTypes" }}
// {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel describes the resource data model for the children without relation ships.
type {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel struct {
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
	{{- else if .HasCustomType}}
	{{ .Name }} customTypes.{{.ResourceClassName}}{{.Name}}StringValue `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- range .Children}}
		{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	{{ .ResourceClassName }} types.Object `tfsdk:"{{overwriteProperty .PkgName .ResourceName $.Definitions}}"`
		{{- else}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{overwriteProperty .PkgName .ResourceName $.Definitions}}"`
		{{- end}}
	{{- end}}
}

func getEmpty{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel() {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel {
	return {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel{
		{{- range .Properties}}
			{{- if eq .ValueType "bitmask"}}
	{{ .Name }}: types.SetNull(types.StringType),
			{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }}: basetypes.NewStringNull(),
			{{- else if .HasCustomType}}
	{{ .Name }}: customTypes.New{{.ResourceClassName}}{{.Name}}StringNull(),
			{{- else}}
	{{ .Name }}: basetypes.NewStringNull(),
		{{- end}}
			{{- end}}
	{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		{{ .ResourceClassName }}: types.ObjectNull(map[string]attr.Type{
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
				{{- else}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
				{{- end}}
			{{- end}}
			{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- else}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- end}}
			{{- end}}
		}),
			{{- else}}
		{{ .ResourceClassName }}: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
				{{- else}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
				{{- end}}
			{{- end}}
			{{- range .Children}}
			{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- else}}
			"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
			{{- end}}
			{{- end}}
			},
		}),
			{{- end}}
		{{- end}}
    }
}

{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
var {{.ResourceClassName}}{{.ParentHierarchy}}Type = map[string]attr.Type{
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
		"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
		{{- else}}
		"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
		{{- end}}
	{{- end}}
	{{- range .Children}}
	{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
	{{- else}}
	"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
	{{- end}}
	{{- end}}
}
{{- else}}
var {{.ResourceClassName}}{{.ParentHierarchy}}Type = types.ObjectType{
	AttrTypes:map[string]attr.Type{
    {{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType{ElemType: types.StringType},
		{{- else if eq .Name "Id"}}
	"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
		{{- else}}
	"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
		{{- end}}
	{{- end}}
	{{- range .Children}}
	{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.ObjectType{AttrTypes: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
	{{- else}}
	"{{overwriteProperty .PkgName .ResourceName $.Definitions}}": types.SetType{ElemType: {{.ResourceClassName}}{{.ParentHierarchy}}Type},
	{{- end}}
	{{- end}}
	},
}

{{- if excludeForNullInSetCheck .ResourceClassName}}
func {{.ResourceClassName}}{{.ParentHierarchy}}SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate(ctx context.Context, planValue, stateValue types.Set) basetypes.SetValue {
	//  Function is needed to handle the case that an attribute is not yet suppored in a version and gets set to null during read
	var planSetValues, stateSetValues []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	stateValue.ElementsAs(ctx, &stateSetValues, false)
	planValue.ElementsAs(ctx, &planSetValues, false)
	
	// If the length of the state and plan values are different a change is already detected the loop can be skipped
	if len(stateSetValues) == len(planSetValues) {
		for index, stateValue := range stateSetValues {
 			nullInStateFound := false
			{{- range .Properties}}
			if stateValue.{{ .Name }}.IsNull() {
				nullInStateFound = true
				{{- if eq .ValueType "bitmask"}}
				planSetValues[index].{{ .Name }} = basetypes.NewSetNull(types.StringType)
 				{{- else if .HasCustomType}}
 				planSetValues[index].{{ .Name }} = customTypes.New{{.ResourceClassName}}{{.Name}}StringNull()
				{{- else}}
				planSetValues[index].{{ .Name }} = basetypes.NewStringNull()
 				{{- end}}
			}
			{{- end}}
 			if !nullInStateFound {
				// when there are no null fields we can conclude the version supports all attributes in set
				break
			}
		}
	}
	planSet, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{.ParentHierarchy}}Type, planSetValues)
	return planSet
	
}
{{- end}}
{{- end}}
{{- range .Children}}
	{{- template "childStructsAndAttributeTypes" . }}
{{- end}}
{{- end}}


{{/* A sub template for the child attributes used in the Attributes block. */}}
{{- define "childAttributes" }}
  {{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
    "{{overwriteProperty .PkgName .ResourceName $.Definitions}}": schema.SingleNestedAttribute{
    MarkdownDescription: `{{.Comment}}`,
    Optional:            true,
    Computed:            true,
    PlanModifiers: []planmodifier.Object{
        objectplanmodifier.UseStateForUnknown(),
    },
    {{- if .RequiredPropertiesNames }}
    Validators: []validator.Object{
        MakeSingleNestedAttributeRequiredAttributesNotProvidedValidator("{{.ResourceName}}", []string{"{{listToString .RequiredPropertiesNames}}"}),
    },
    {{- end }}
    Attributes: map[string]schema.Attribute{
    {{- range .Properties}}
        {{- if eq .ValueType "bitmask"}}
        "{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.SetAttribute{
            MarkdownDescription: `{{.Comment}}`,
            {{- if not .ReadOnly }}
            Optional:            true,
            {{- end }}
            Computed:            true,
			{{- if not .ReadOnly }}
            PlanModifiers: []planmodifier.Set{
                setplanmodifier.UseStateForUnknown(),
            },
			{{- end}}
            {{- if .ValidValues}}
            Validators: []validator.Set{
                setvalidator.SizeAtMost({{ len .ValidValues }}),
                setvalidator.ValueStringsAre(
                    stringvalidator.OneOf({{- validatorString .ValidValues}}),
                ),
            },
            {{- end}}
            ElementType: types.StringType,
        },
        {{- else}}
        "{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
            Optional:            true,
            Computed:            true,
			{{- if not .ReadOnly }}
            PlanModifiers: []planmodifier.String{
                stringplanmodifier.UseStateForUnknown(),
            },
			{{- end}}
            {{- if or .ValidValues }}
            Validators: []validator.String{
                stringvalidator.OneOf({{- validatorString .ValidValues}}),
            },
            {{- end}}
            MarkdownDescription: `{{.Comment}}`,
        },
        {{- end}}
        {{- end}}
		{{- range .Children }}
			{{- $newCtx := addToTemplateProperties . "HasReadOnlyProperties" $.TemplateProperties.HasReadOnlyProperties -}}
        	{{- template "childAttributes" $newCtx }}
  		{{- end }}
        },
    },
    {{- else }}
    "{{overwriteProperty .PkgName .ResourceName $.Definitions}}": schema.SetNestedAttribute{
    MarkdownDescription: `{{.Comment}}`,
    Optional:            true,
    Computed:            true,
    PlanModifiers: []planmodifier.Set{
        setplanmodifier.UseStateForUnknown(),
		{{- if excludeForNullInSetCheck .ResourceClassName}}
		SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate({{.ResourceClassName}}{{.ParentHierarchy}}SetToSetNullWhenStateIsNullPlanIsUnknownDuringUpdate),
		{{- end}}
    },
    NestedObject: schema.NestedAttributeObject{
        Attributes: map[string]schema.Attribute{
        {{- range .Properties}}
            {{- if eq .ValueType "bitmask"}}
            "{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.SetAttribute{
                MarkdownDescription: `{{.Comment}}`,
                {{- if not .ReadOnly }}
                Optional:            true,
                {{- end }}
                {{- if ne .ValueType "password"}}
                Computed:            true,
                {{- else}}
                Sensitive:            true,
                {{- end}}
				{{- if not .ReadOnly }}
                PlanModifiers: []planmodifier.Set{
                    setplanmodifier.UseStateForUnknown(),
                },
				{{- end}}
                {{- if .ValidValues}}
                Validators: []validator.Set{
                    setvalidator.SizeAtMost({{ len .ValidValues }}),
                    setvalidator.ValueStringsAre(
                        stringvalidator.OneOf({{- validatorString .ValidValues}}),
                    ),
                },
                {{- end}}
                ElementType: types.StringType,
            },
            {{- else}}
            "{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
                {{- if .HasCustomType}}
                CustomType: customTypes.{{.ResourceClassName}}{{.Name}}StringType{},
                {{- end}}
                {{- if and (or .IsNaming .IsRequired) (not $.TemplateProperties.HasReadOnlyProperties)}}
                Required:            true,
                {{- else }}
                Optional:            true,
                {{- if ne .ValueType "password"}}
                Computed:            true,
                {{- else}}
                Sensitive:            true,
                {{- end}}
                {{- end}}
				{{- if not .ReadOnly }}
                PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
                },
				{{- end}}
                {{- if .HasCustomType}}
                Validators: []validator.String{
                    stringvalidator.Any(
                        stringvalidator.OneOf({{- validatorStringCustomType .ValidValues .ValidValuesMap}}),
                        validators.InBetweenFromString({{- index .Validators 0 "min"}}, {{- index .Validators 0 "max"}}),
                    ),
                },
                {{- else if or .ValidValues $.TemplateProperties.HasReadOnlyProperties}}
                Validators: []validator.String{
                    {{- if .ValidValues}}
                    stringvalidator.OneOf({{- validatorString .ValidValues}}),
                    {{- end}}
                    {{- if or .IsNaming .IsRequired}}
                    MakeStringRequired(),
                    {{- end}}
                },
                {{- end}}
                MarkdownDescription: `{{.Comment}}`,
            },
            {{- end}}
        {{- end}}
      {{- range .Children }}
	  	{{- $newCtx := addToTemplateProperties . "HasReadOnlyProperties" $.TemplateProperties.HasReadOnlyProperties -}}
        {{- template "childAttributes"  $newCtx }}
  {{- end }}
  	  },
    },
  },
{{- end }}
{{- end }}

{{/* A sub template for the grand child attributes used in the Payload function. */}}
{{- define "grandChildPayload" }}
{{$grandChild:= .}}
{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
var {{.PkgName}}{{.ParentHierarchy}}Plan, {{.PkgName}}{{.ParentHierarchy}}State {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
{{- else}}
var {{.PkgName}}{{.ParentHierarchy}}Plan, {{.PkgName}}{{.ParentHierarchy}}State  []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
{{- end}}
{{- if .TemplateProperties.AlreadyInPlan }}
{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
{{.ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}Plan, basetypes.ObjectAsOptions{})
if !{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.IsNull(){
	{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}State, basetypes.ObjectAsOptions{})
}
{{- else}}
{{.ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}Plan, false)
for _, {{ .PkgName }}{{.ParentHierarchy}}state := range {{.ParentHierarchy | decapitalize}}State {
	{{ .PkgName }}{{.ParentHierarchy}}state.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}State, false)
}
{{- end}}
if !{{ .ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.IsNull() && !{{ .ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.IsUnknown(){
{{- else}}
{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
{{.ParentHierarchy | decapitalize}}Plan.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}Plan, basetypes.ObjectAsOptions{})
if !{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.IsNull(){
	{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}State, basetypes.ObjectAsOptions{})
}
{{- else}}
{{.ParentHierarchy | decapitalize}}Plan.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}Plan, false)
if !{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.IsNull(){
	{{.ParentHierarchy | decapitalize}}State.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}State, false)
}
{{- end}}
if !{{ .ParentHierarchy | decapitalize}}Plan.{{.ResourceClassName}}.IsNull() && !{{ .ParentHierarchy | decapitalize}}Plan.{{.ResourceClassName}}.IsUnknown(){
{{- end}}
	{{- if and (and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))) (not (or (not .IdentifiedBy) .MaxOneClassAllowed))}}
        {{ .PkgName }}Identifiers := []{{.ResourceClassName}}Identifier{}
	{{- end}}
{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
		{{.PkgName}}{{.ParentHierarchy}}ChildMap := NewAciObject()
		if !IsEmptySingleNestedAttribute({{ .ParentHierarchy | decapitalize}}Plan.{{.ResourceClassName}}.Attributes()) {
			{{- range .Properties}}
				if !{{ .PkgName }}{{$.ParentHierarchy}}Plan.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown() &&  !{{ .PkgName }}{{$.ParentHierarchy}}Plan.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull(){
				{{- if eq .ValueType "bitmask"}}
					var tmp{{ .Name }} []string
					{{ .PkgName }}{{$.ParentHierarchy}}Plan.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
					{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")				
				{{- else if eq .Name "Id"}}
					{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$.ParentHierarchy}}Plan.{{.ResourceClassName}}{{ .Name }}.ValueString()
				{{- else}}
					{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$.ParentHierarchy}}Plan.{{ .Name }}.ValueString()
				{{- end}}
				} {{- if eq .Name "Annotation" }} else {
					{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["annotation"] = globalAnnotation
				} {{- end}}
			{{- end}}
		}{{- if .AllowDelete}} else {
			{{- range .Properties}}
				{{- if .IsNaming }}
				{{.PkgName}}{{$.ParentHierarchy}}childMap.Attributes["{{.PropertyName}}"] = {{.PkgName}}State.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
				{{- end}}
			{{- end}}
			{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["status"] = "deleted"
		}{{- end}}
		{{- $enteredGreatGrandChildPayloadZoneOne := false }}
	{{- range .Children}}
	{{- $enteredGreatGrandChildPayloadZoneOne = true }}
		{{- template "grandChildPayload" . }}
	{{- end}}
	{{- range .Children}}
		{{- if $enteredGreatGrandChildPayloadZoneOne }}
			{{- $enteredGreatGrandChildPayloadZoneOne = false }}
	{{$.PkgName}}{{$.ParentHierarchy}}ChildMap.Children = {{.ParentHierarchy}}Children
		{{- end}}
	{{- end}}
	{{ .ParentHierarchy }}Children = append({{ .ParentHierarchy }}Children, map[string]interface{}{"{{.PkgName}}": {{.PkgName}}{{$.ParentHierarchy}}ChildMap})
		{{- else}}
for _, {{ .PkgName }}{{.ParentHierarchy}} := range {{.PkgName}}{{.ParentHierarchy}}Plan {
	{{.PkgName}}{{.ParentHierarchy}}ChildMap := NewAciObject()
	{{- range .Properties}}
	if !{{ .PkgName }}{{$.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull() && !{{ .PkgName }}{{$.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
		{{- if eq .ValueType "bitmask"}}
		var tmp{{ .Name }} []string
		{{ .PkgName }}{{$.ParentHierarchy}}.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
		{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")                
		{{- else if eq .Name "Id"}}
		{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$.ParentHierarchy}}.{{.ResourceClassName}}{{ .Name }}.ValueString()
		{{- else}}
		{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["{{ .PropertyName }}"] = {{ .PkgName }}{{$.ParentHierarchy}}.{{ .Name }}.ValueString()
		{{- end}}
	} {{- if eq .Name "Annotation" }} else {
		{{.PkgName}}{{$.ParentHierarchy}}ChildMap.Attributes["annotation"] = globalAnnotation
	} {{- end}}
	{{- end}}
	{{- $enteredGreatGrandChildPayloadZone := false }}
	{{- range .Children}}
	{{- $enteredGreatGrandChildPayloadZone = true }}
		{{- $newCtx := addToTemplateProperties . "AlreadyInPlan" true -}}
        {{- template "grandChildPayload" $newCtx }}
	{{- end}}
	{{- range .Children}}
		{{- if $enteredGreatGrandChildPayloadZone }}
			{{- $enteredGreatGrandChildPayloadZone = false }}
	{{$.PkgName}}{{$.ParentHierarchy}}ChildMap.Children = {{.ParentHierarchy}}Children
		{{- end}}
	{{- end}}
	{{ .ParentHierarchy }}Children = append({{ .ParentHierarchy }}Children, map[string]interface{}{"{{.PkgName}}": {{.PkgName}}{{$.ParentHierarchy}}ChildMap})
	{{- if .IdentifiedBy}}
	{{ .PkgName }}Identifier := {{ .ResourceClassName }}Identifier{}
		{{- range .Properties}}
			{{- if .IsNaming}}
	{{ .PkgName }}Identifier.{{.Name}} = {{ .PkgName }}{{$grandChild.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}
			{{- end}}
		{{- end}}
	{{ .PkgName }}Identifiers = append({{ .PkgName }}Identifiers, {{ .PkgName }}Identifier)
	{{- end}}
	}
	{{- end}}
	{{- if .IdentifiedBy}}
	for _, {{ .PkgName }}{{.ParentHierarchy}} := range {{ .PkgName }}{{.ParentHierarchy}}State {
		delete := true
	for _, {{ .PkgName }}Identifier := range {{ .PkgName }}Identifiers { {{$i := 1}}{{$length := len .IdentifiedBy}}
		if 
		{{- range .Properties}}
			{{- if .IsNaming }}
			{{ .PkgName }}Identifier.{{.Name}} == {{ .PkgName }}{{$grandChild.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}{{- if ne $length $i}} {{$i = add $i 1}} && {{- end}}
			{{- end}}
		{{- end}} {
			delete = false
			break
		}
	}
	if delete {
		{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete := NewAciObject()
		{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["status"] = "deleted"
	{{- range .Properties}}
		{{- if .IsNaming }}
		{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["{{.PropertyName}}"] = {{ .PkgName }}{{$grandChild.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
		{{- end}}
	{{- end}}
		{{ .ParentHierarchy }}Children = append({{ .ParentHierarchy }}Children, map[string]interface{}{"{{ .PkgName }}": {{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete})
			}
		}
	}
	{{- else}}
	{{- if not (or (not .IdentifiedBy) .MaxOneClassAllowed)}}
		if len({{ .PkgName }}{{.ParentHierarchy}}Plan) == 0 && len({{.PkgName}}{{.ParentHierarchy}}State) == 1 {
			{{- if .AllowDelete}}
			{{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete := NewAciObject()
			{{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete.Attributes["status"] = "deleted"
			{{- if .IdentifiedBy}}
							{{- range .Properties}}
								{{- if .IsNaming }}
			{{.PkgName}}{{$.ParentHierarchy}}ChildMapForDelete.Attributes["{{.PropertyName}}"] = {{ .PkgName }}State[0].{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
								{{- end}}
							{{- end}}
						{{- end}}
			{{ .ParentHierarchy }}Children = append({{ .ParentHierarchy }}Children, map[string]interface{}{"{{.PkgName}}": {{.PkgName}}{{.ParentHierarchy}}ChildMapForDelete})
			{{- else}}
			diags.AddError(
				"{{ .ResourceClassName }} object cannot be deleted",
				"deletion of child is only possible upon deletion of the parent",
			)
			return nil
			{{- end }}
		  }
		{{- end }}
	}
	{{- end}}
{{- end }}


{{/* A sub template to declare child lists in the get and set attributes function. */}}
{{- define "declareChildListsInGetandSetAttributesFunction" }}
{{ .ResourceClassName }}{{.ParentHierarchy}}List := make([]{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel, 0)
{{- end}}

{{- define "declareChildListsInGetandSetAttributesFunctionWithGetEmpty" }}
{{.ResourceClassName}}{{.ParentHierarchy}} := getEmpty{{ .ResourceClassName}}{{.ParentHierarchy}}ResourceModel()
{{ .ResourceClassName }}{{.ParentHierarchy}}List := make([]{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel, 0)
{{- range .Children}}
	{{- template "declareChildListsInGetandSetAttributesFunctionWithGetEmpty" . }}
{{- end}}
{{- end}}

{{/* A sub template for the grand child attributes used in the get and set attributes function. */}}
{{- define "getAndSetGrandChildren" }}
if childClassName{{.ParentHierarchy}} == "{{.PkgName}}"{
{{.ResourceClassName}}{{.ParentHierarchy}} := getEmpty{{ .ResourceClassName}}{{.ParentHierarchy}}ResourceModel()
{{.PkgName}}childAttributeValue:= childClassDetails{{.ParentHierarchy}}.(map[string]interface{})["attributes"].(map[string]interface{})
for childAttributeName, childAttributeValue := range {{.PkgName}}childAttributeValue {
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
			{{- if containsNoneAttributeValue .ValidValues}}
	if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
		{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ParentHierarchy}}.{{.Name}}.ElementType(ctx), []string{"none"})
		{{.ResourceClassName}}{{$.ParentHierarchy}}.{{.Name}} = {{.PropertyName}}Set
	} else if childAttributeName == "{{.PropertyName}}" {
		{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
		var data{{.ParentHierarchy}} []{{.ParentHierarchy}}ResourceModel
		data.{{.ParentHierarchy}}.ElementsAs(ctx,&data{{.ParentHierarchy}},false)
		for _, {{.ParentHierarchy | decapitalize}} := range data{{.ResourceClassName}}{{.ParentHierarchy}} {
		{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.ElementType(ctx),{{.PropertyName}}List)
		{{.ResourceClassName}}{{$.ParentHierarchy}}.{{.Name}} = {{.PropertyName}}Set
		}
	}
			{{- else}}
	if childAttributeName == "{{.PropertyName}}" {
		{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
		var data{{.ParentHierarchy}} []{{.ParentHierarchy}}ResourceModel
		data.{{.ParentHierarchy}}.ElementsAs(ctx,&data{{.ParentHierarchy}},false)
		for _, {{.ParentHierarchy | decapitalize}} := range data{{.ResourceClassName}}{{.ParentHierarchy}} {
		{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ParentHierarchy | decapitalize}}.{{.ResourceClassName}}.ElementType(ctx),{{.PropertyName}}List)
		{{.ResourceClassName}}{{$.ParentHierarchy}}.{{.Name}} = {{.PropertyName}}Set
		}
	}
			{{- end}}
		{{- else}}
			{{- if containsNoneAttributeValue .ValidValues}}
	if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
		{{.ResourceClassName}}{{.ParentHierarchy}}.{{.Name}} = basetypes.NewStringValue("none")
	} else if childAttributeName == "{{.PropertyName}}" {
		{{.ResourceClassName}}{{$.ParentHierarchy}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
	}
			{{- else}}
	if childAttributeName == "{{.PropertyName}}" {
		{{.ResourceClassName}}{{$.ParentHierarchy}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(childAttributeValue.(string))
	}
			{{- end}}
		{{- end}}
	{{- end}}
	{{- $enteredGrandChildGetAndSetAttributesZone := false }}
	{{- $children := .Children }} 
	{{- range .Children}}
		{{- if not $enteredGrandChildGetAndSetAttributesZone }}
			{{- $enteredGrandChildGetAndSetAttributesZone = true }}
			}
			{{- range $children}}
			{{ .ResourceClassName }}{{.ParentHierarchy}}List := make([]{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel, 0)
			{{- end}}
			childrenOf{{.ParentHierarchy}}, childrenOf{{.ParentHierarchy}}Exist:= childClassDetails{{$.ParentHierarchy}}.(map[string]interface{})["children"]
			if childrenOf{{.ParentHierarchy}}Exist {
				for _, child{{.ParentHierarchy}} := range childrenOf{{.ParentHierarchy}}.([]interface{}) {
					for childClassName{{.ParentHierarchy}}, childClassDetails{{.ParentHierarchy}} := range child{{.ParentHierarchy}}.(map[string]interface{}) {
		{{- end}}
		{{- template "getAndSetGrandChildren" . }}
	{{- end }}
	{{- if $enteredGrandChildGetAndSetAttributesZone }}
			}
		}
	}
	{{- range .Children}}
	{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	if len({{.ResourceClassName}}{{.ParentHierarchy}}List) == 1 {
		{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{ .ResourceClassName }}{{.ParentHierarchy}}List[0])
		{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
	} else {
		{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
		{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
	}
			{{- else}}
	{{.ResourceClassName}}{{.ParentHierarchy}}Set,_ := types.SetValueFrom(ctx,{{.ResourceClassName}}{{.ParentHierarchy}}Type,{{.ResourceClassName}}{{.ParentHierarchy}}List)
	{{.ParentHierarchy}}.{{.ResourceClassName}} = {{.ResourceClassName}}{{.ParentHierarchy}}Set
			{{- end}}
	{{- end}}
	{{- else}}
	}
	{{- end}}
	{{.ResourceClassName}}{{$.ParentHierarchy}}List = append({{.ResourceClassName}}{{$.ParentHierarchy}}List, {{.ResourceClassName}}{{$.ParentHierarchy}})
}
{{- end }}


{{/* A sub template for grand child declaration in the child payload function. */}}
{{- define "grandChildDeclarationInChildPayloadFunction" }}
{{- $enteredGrandChildDeclarationZone := false }}
{{- range .Children}}
	{{- $enteredGrandChildDeclarationZone = true }}
	{{- template "grandChildDeclarationInChildPayloadFunction" . }}
{{- end }}
{{- range .Children}}
	{{- if $enteredGrandChildDeclarationZone }}
		{{- $enteredGrandChildDeclarationZone = false }}
{{.ParentHierarchy}}Children := make([]map[string]interface{}, 0)
	{{- end}}
{{- end}}
{{- end}}


{{/* A sub template for joining all the class names as a single string. */}}
{{- define "rspSubtreeClassFilter" -}}
  {{- $currentClasses := listToString .ChildClasses -}}
    {{- $currentClasses -}}
    {{- range .Children -}}
		{{- if not (isListEmpty .ChildClasses) -}}
			,{{- template "rspSubtreeClassFilter" . -}}
		{{- end -}}
    {{- end -}}
{{- end -}}


{{- define "modifyPlanForSingleNestedChildren" }}
{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
	var {{.PkgName}}{{.ParentHierarchy}}ConfigData {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	{{- if .TemplateProperties.configData}}
	if !{{.TemplateProperties.configData.ResourceClassName}}ConfigData.{{.ResourceClassName}}.IsNull() && stateData != nil {
		{{.TemplateProperties.configData.ResourceClassName}}ConfigData.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}ConfigData, basetypes.ObjectAsOptions{})
        if IsEmptySingleNestedAttribute({{.TemplateProperties.configData.ResourceClassName}}ConfigData.{{.ResourceClassName}}.Attributes()) {
            {{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
			{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
        } else {
			{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{.PkgName}}{{.ParentHierarchy}}ConfigData)
			{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
		}
    }
	{{- else}}
	if !{{.ParentHierarchy | decapitalize}}ConfigData.{{.ResourceClassName}}.IsNull() && stateData != nil {
		{{.ParentHierarchy | decapitalize}}ConfigData.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}ConfigData, basetypes.ObjectAsOptions{})
        if IsEmptySingleNestedAttribute({{.ParentHierarchy}}ConfigData.{{.ResourceClassName}}.Attributes()) {
            {{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, getEmpty{{ .ResourceClassName }}{{.ParentHierarchy}}ResourceModel())
			{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
        } else {
			{{.ResourceClassName}}{{.ParentHierarchy}}Object, _ := types.ObjectValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{.PkgName}}{{.ParentHierarchy}}ConfigData)
			{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Object
		}
    }
	{{- end}}
{{- else}}
	var {{.PkgName}}{{.ParentHierarchy}}ConfigData []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	{{- if .TemplateProperties.configData}}
	if !{{.TemplateProperties.configData.ResourceClassName}}ConfigData.{{.ResourceClassName}}.IsNull() && stateData != nil {
		{{.TemplateProperties.configData.ResourceClassName}}ConfigData.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}ConfigData, false)
	{{- else}}
	if !{{.ParentHierarchy | decapitalize}}ConfigData.{{.ResourceClassName}}.IsNull() && stateData != nil {
		{{.ParentHierarchy | decapitalize}}ConfigData.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}ConfigData, false)
	{{- end}}
	{{.ResourceClassName}}{{.ParentHierarchy}}Set, _ := types.SetValueFrom(ctx, {{ .ResourceClassName }}{{.ParentHierarchy}}Type, {{.PkgName}}{{.ParentHierarchy}}ConfigData)
	{{.ParentHierarchy}}.{{ .ResourceClassName }} = {{.ResourceClassName}}{{.ParentHierarchy}}Set
	}
{{- end}}
{{- range .Children}}
	{{- $newCtx := addToTemplateProperties . "configData" "" -}}
	{{- template "modifyPlanForSingleNestedChildren" $newCtx }}
{{- end}}
{{.ResourceClassName}}{{$.ParentHierarchy}}List = append({{.ResourceClassName}}{{$.ParentHierarchy}}List, {{.ResourceClassName}}{{$.ParentHierarchy}})
{{- end}}

{{- define "isDeleteAllowedForSingleNestedChildren" }}
	{{- if or (and (or (not .IdentifiedBy) .MaxOneClassAllowed) (not .AllowDelete)) (containsDeletableSingleNestedChildren .Children)}}
	var {{.PkgName}}{{.ParentHierarchy}}Data {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	var {{.PkgName}}{{.ParentHierarchy}}StateData {{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	{{- if .TemplateProperties.data}}
	{{.TemplateProperties.data.ResourceClassName}}Data.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}Data, basetypes.ObjectAsOptions{})
	{{.TemplateProperties.data.ResourceClassName}}StateData.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}StateData, basetypes.ObjectAsOptions{})
	{{- if (not .AllowDelete)}}
	if IsEmptySingleNestedAttribute({{.TemplateProperties.data.ResourceClassName}}Data.{{.ResourceClassName}}.Attributes()) && !IsEmptySingleNestedAttribute({{.TemplateProperties.data.ResourceClassName}}StateData.{{.ResourceClassName}}.Attributes()) {
		resp.Diagnostics.AddError(
			"{{ .ResourceClassName }} object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
			{{- end}}
	{{- else}}
	{{.ParentHierarchy | decapitalize}}Data.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}Data, basetypes.ObjectAsOptions{})
	{{.ParentHierarchy | decapitalize}}StateData.{{.ResourceClassName}}.As(ctx, &{{.PkgName}}{{.ParentHierarchy}}StateData, basetypes.ObjectAsOptions{})
	{{- if (not .AllowDelete)}}
	if IsEmptySingleNestedAttribute({{.ParentHierarchy}}Data.{{.ResourceClassName}}.Attributes()) && !IsEmptySingleNestedAttribute({{.ParentHierarchy}}StateData.{{.ResourceClassName}}.Attributes()) {
		resp.Diagnostics.AddError(
			"{{ .ResourceClassName }} object cannot be deleted",
			"deletion of child is only possible upon deletion of the parent",
		)
	}
			{{- end}}
	{{- end}}
	{{- else}}
	{{- if containsDeletableSingleNestedChildren .Children}}
	var {{.PkgName}}{{.ParentHierarchy}}Data []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	var {{.PkgName}}{{.ParentHierarchy}}StateData []{{.ResourceClassName}}{{.ParentHierarchy}}ResourceModel
	{{- if .TemplateProperties.data}}
	{{.TemplateProperties.data.ResourceClassName}}Data.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}Data, false)
	{{.TemplateProperties.data.ResourceClassName}}StateData.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}StateData, false)
	{{- else}}
	{{.ParentHierarchy | decapitalize}}Data.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}Data, false)
	{{.ParentHierarchy | decapitalize}}StateData.{{.ResourceClassName}}.ElementsAs(ctx, &{{.PkgName}}{{.ParentHierarchy}}StateData, false)
	{{- end}}
	{{- end}}
	{{- end}}
{{- range .Children}}
	{{- $newCtx := addToTemplateProperties . "data" "" -}}
	{{- template "isDeleteAllowedForSingleNestedChildren" $newCtx }}
{{- end}}
{{- end}}