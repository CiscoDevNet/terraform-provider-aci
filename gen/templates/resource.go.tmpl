// Code generated by "gen/generator.go"; DO NOT EDIT.
// In order to regenerate this file execute `go generate` from the repository root.
// More details can be found in the [README](https://github.com/CiscoDevNet/terraform-provider-aci/blob/master/README.md).

package provider

import (
	"context"
	"fmt"
	"encoding/json"
	{{- if .IdentifiedBy}}
	"reflect"
	{{- end}}
	"strings"
	
	"github.com/ciscoecosystem/aci-go-client/v2/client"
	"github.com/ciscoecosystem/aci-go-client/v2/container"
	{{- if or .HasBitmask .HasChildWithoutIdentifier}}
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	{{- end}}
	{{- if .HasValidValues}}
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	{{- end}}
	{{- if .LegacyAttributes}}
	"github.com/hashicorp/terraform-plugin-framework/attr"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	{{- if or .HasAnnotation}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	{{- if or .HasChild .HasBitmask}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	{{- if or .HasValidValues .HasChildWithoutIdentifier}}
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	{{- end}}
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &{{.ResourceClassName}}Resource{}
var _ resource.ResourceWithImportState = &{{.ResourceClassName}}Resource{}

func New{{.ResourceClassName}}Resource() resource.Resource {
	return &{{.ResourceClassName}}Resource{}
}

// {{.ResourceClassName}}Resource defines the resource implementation.
type {{.ResourceClassName}}Resource struct {
	client *client.Client
}

// {{.ResourceClassName}}ResourceModel describes the resource data model.
type {{.ResourceClassName}}ResourceModel struct {
	Id types.String `tfsdk:"id"`
	{{- if .HasParent}}
	ParentDn types.String `tfsdk:"parent_dn"`
	{{- end}}
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
	{{- range .Children}}
	{{ .ResourceClassName }} types.Set `tfsdk:"{{- .ResourceName}}"`
	{{- end}}
	{{- if .LegacyAttributes}}
		{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
	Deprecated{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
		{{- end }}{{- end }}
		{{- range .LegacyBlocks}}
	Deprecated{{ capitalize .ClassName }} types.Set `tfsdk:"{{.Name}}"`
		{{- end }}
	{{- end }}
}

func getEmpty{{.ResourceClassName}}ResourceModel() *{{.ResourceClassName}}ResourceModel {
	return &{{.ResourceClassName}}ResourceModel{
		Id: basetypes.NewStringNull(),
		{{- if .HasParent}}
		ParentDn: basetypes.NewStringNull(),
		{{- end}}
		{{- range .Properties}}
			{{- if eq .ValueType "bitmask"}}
		{{ .Name }}: types.SetNull(types.StringType),
			{{- else if eq .Name "Id"}}
		{{.ResourceClassName}}{{ .Name }}: basetypes.NewStringNull(),
			{{- else}}
		{{ .Name }}: basetypes.NewStringNull(),
			{{- end}}
		{{- end}}
		{{- range .Children}}
		{{ .ResourceClassName }}: types.SetNull(types.ObjectType{
			AttrTypes: map[string]attr.Type{
			{{- range .Properties}}
				{{- if eq .ValueType "bitmask"}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.SetType(types.StringType),
				{{- else}}
				"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": types.StringType,
				{{- end}}
			{{- end}}
			},
		}),
		{{- end}}
		{{- if .LegacyAttributes}}
			{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
				{{- if eq (getMigrationType .ValueType) "String"}}
		Deprecated{{ .Name }}: types.{{getMigrationType .ValueType}}{},
				{{- else if eq (getMigrationType .ValueType) "Set"}}
		Deprecated{{ .Name }}: types.SetNull(types.StringType),
				{{- end }}
			{{- end }}{{- end }}
			{{- range .LegacyBlocks}}
		Deprecated{{ capitalize .ClassName }}: types.SetNull(deprecated{{ capitalize .ClassName }}Type),
			{{- end }}
		{{- end }}
	}
}

{{- range .Children}}
// {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel describes the resource data model for the children without relation ships.
type {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel struct {
	{{- range .Properties}}
		{{- if eq .ValueType "bitmask"}}
	{{ .Name }} types.Set `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- else}}
	{{ .Name }} types.String `tfsdk:"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}"`
		{{- end}}
	{{- end}}
}

func getEmpty{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel() {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel {
	return {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
		{{- range .Properties}}
			{{- if eq .ValueType "bitmask"}}
	{{ .Name }}: types.SetNull(types.StringType),
			{{- else if eq .Name "Id"}}
	{{.ResourceClassName}}{{ .Name }}: basetypes.NewStringNull(),
			{{- else}}
	{{ .Name }}: basetypes.NewStringNull(),
			{{- end}}
		{{- end}}
	}
}
{{- end}}

{{if .IdentifiedBy}}
type {{.ResourceClassName}}Identifier struct {
	{{- range .Properties}}
	{{- if .IsNaming}}
	{{ .Name }} types.String
	{{- end}}
	{{- end}}
}
{{- end}}

{{ if .LegacyAttributes}}
{{- range .LegacyBlocks}}
var deprecated{{ capitalize .ClassName }}Type = types.ObjectType{
	AttrTypes: map[string]attr.Type{
		{{- range .Attributes}}
			{{- if eq (getMigrationType .ValueType) "String"}}
				"{{.AttributeName}}": basetypes.StringType{},
			{{- end}}
		{{- end}}
	},
}
{{ end}}

type {{.ResourceClassName}}ResourceModelV{{.LegacySchemaVersion}} struct {
	{{- range .LegacyAttributes}}
	{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
	{{- end }}
	{{- range .LegacyBlocks}}
	{{ capitalize .ClassName }} types.Set `tfsdk:"{{.Name}}"`
	{{- end }}
}

	{{ range .LegacyBlocks}}
type {{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}} struct {
		{{- range .Attributes}}
	{{ .Name }} types.{{getMigrationType .ValueType}} `tfsdk:"{{.AttributeName}}"`
		{{- end}}
}
	{{ end}}

func (r *{{.ResourceClassName}}Resource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		{{.LegacySchemaVersion}}: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					{{- range .LegacyAttributes}}
						{{- if eq (getMigrationType .ValueType) "String"}}
					"{{.AttributeName}}": schema.StringAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
					},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "Set"}}
					"{{.AttributeName}}": schema.SetAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
						ElementType: types.StringType,
					},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "List"}}
					"{{.AttributeName}}": schema.ListAttribute{
						Required: {{.Required}},
						Optional: {{.Optional}},
						Computed: {{.Computed}},
						ElementType: types.StringType,
					},
						{{- end}}
					{{- end}}
				},
				Blocks: map[string]schema.Block{
					{{- range .LegacyBlocks}}
					"{{ .Name }}": schema.SetNestedBlock{
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
							{{- range .Attributes}}
								{{- if eq (getMigrationType .ValueType) "String"}}
							"{{.AttributeName}}": schema.StringAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
							},
								{{- end}}
								{{- if eq (getMigrationType .ValueType) "Set"}}
							"{{.AttributeName}}": schema.SetAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
								ElementType: types.StringType,
							},
								{{- end}}
								{{- if eq (getMigrationType .ValueType) "List"}}
							"{{.AttributeName}}": schema.ListAttribute{
								Required: {{.Required}},
								Optional: {{.Optional}},
								Computed: {{.Computed}},
								ElementType: types.StringType,
							},
								{{- end}}
							{{- end}}
							},
						},
					},
					{{- end }}
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorStateData {{.ResourceClassName}}ResourceModelV{{.LegacySchemaVersion}}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorStateData)...)

				if resp.Diagnostics.HasError() {
					return
				}

				upgradedStateData := {{.ResourceClassName}}ResourceModel{
					Id: priorStateData.Id,
					{{- if .HasParent}}
					ParentDn: priorStateData.ParentDn,
					{{- end}}
					{{- range .Properties}}
						{{- if isLegacyAttribute .Name $.LegacyAttributes}}
					{{ .Name }}: priorStateData.{{ .Name }},
						{{- else if ne .ValueType "bitmask"}}
					{{ .Name }}: basetypes.NewStringNull(),
						{{- else if eq .ValueType "bitmask"}}
					{{ .Name }}: types.SetNull(types.StringType),
						{{- end}}
					{{- end}}
					{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
						{{- if eq (getMigrationType .ValueType) "String"}}
					Deprecated{{ .Name }}: priorStateData.{{ .Name }},
						{{- end }}{{- end }}
					{{- end }}
				}

				{{ range .Children}}
					{{- if isLegacyChild .PkgName $.LegacyChildren}}{{ $PkgName := .PkgName}}
				{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
					{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
						{{- if eq $childClassType "string" }}
				{{.ResourceClassName}} := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
							{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
								{{- if eq $AttributeName ""}}
					{{ .Name }}: basetypes.NewStringNull(),
								{{- else}}
									{{- if isNewNamedClassAttribute $Overwrite }}
					{{ .Name }}: basetypes.NewStringValue(GetMOName(priorStateData.{{ $AttributeName }}.ValueString())),
									{{- else}}
					{{ .Name }}: priorStateData.{{ $AttributeName }},
									{{- end}}
								{{- end}}
							{{- end}}
				}
				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{.ResourceClassName}})
				{{.ResourceClassName}}Type := types.ObjectType{
					AttrTypes: map[string]attr.Type{
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						"{{$Overwrite}}": basetypes.StringType{},
					{{- end}}
					},
				}
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
						{{- else if eq $childClassType "block,set" }}
				var priorStateData{{.ResourceClassName}}List []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}
				priorStateData.{{.ResourceClassName}}.ElementsAs(ctx, &priorStateData{{.ResourceClassName}}List, false)
				for _, priorStateData{{.ResourceClassName}} := range priorStateData{{.ResourceClassName}}List {
					{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if eq $AttributeName ""}}
						{{ .Name }}: basetypes.NewStringNull(),
								{{- else}}
						{{ .Name }}: priorStateData{{.ResourceClassName}}.{{ $AttributeName }},
								{{- end}}
						{{- end}}
					}
					{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
				}
				{{.ResourceClassName}}Type := types.ObjectType{
					AttrTypes: map[string]attr.Type{
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						"{{$Overwrite}}": basetypes.StringType{},
					{{- end}}
					},
				}
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
						{{- else if eq $childClassType "set,string" }}
				var priorStateData{{.ResourceClassName}}List []string
				priorStateData.{{.ResourceClassName}}.ElementsAs(ctx, &priorStateData{{.ResourceClassName}}List, false)
				for _, priorStateData{{.ResourceClassName}} := range priorStateData{{.ResourceClassName}}List {
					{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute $PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if eq $AttributeName ""}}
						{{ .Name }}: basetypes.NewStringNull(),
							{{- else}}
								{{- if isNewNamedClassAttribute $Overwrite }}
						{{ .Name }}: basetypes.NewStringValue(GetMOName(priorStateData{{ .ResourceClassName }})),
								{{- else if eq .Name "TDn"}}
						{{ .Name }}: basetypes.NewStringValue(priorStateData{{ .ResourceClassName }}),
								{{- end}}
							{{- end}}
						{{- end}}
					}
					{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
				}
				{{.ResourceClassName}}Type := types.ObjectType{
					AttrTypes: map[string]attr.Type{
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						"{{$Overwrite}}": basetypes.StringType{},
					{{- end}}
					},
				}
				{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
				upgradedStateData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
						{{- end}}

					{{ else}}
				upgradedStateData.{{ .ResourceClassName }} = types.SetNull(
					types.ObjectType{
						AttrTypes: map[string]attr.Type{
							{{- range .Properties}}
								{{- if ne .ValueType "bitmask"}}
									"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": basetypes.StringType{},
								{{- end}}
							{{- end}}
						},
					},
				)
					{{ end}}
				{{- end}}

				{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
					{{- if or (eq (getMigrationType .ValueType) "Set") (eq (getMigrationType .ValueType) "List")}}
				var deprecated{{ .Name }}List []string
				priorStateData.{{ .Name }}.ElementsAs(ctx, &deprecated{{ .Name }}List, false)
				Deprecated{{ .Name }}Set, _ := types.SetValueFrom(ctx, types.StringType, deprecated{{ .Name }}List)
				upgradedStateData.Deprecated{{ .Name }} = Deprecated{{ .Name }}Set
					{{ end }}{{- end }}
				{{- end }}

				{{ range .LegacyBlocks}}
				var {{ capitalize .ClassName }}V1List []{{ capitalize .ClassName }}{{$.ResourceClassName}}ResourceModelV{{$.LegacySchemaVersion}}
				priorStateData.{{ capitalize .ClassName }}.ElementsAs(ctx, &{{ capitalize .ClassName }}V1List, false)
				{{ capitalize .ClassName }}V1Set, _ := types.SetValueFrom(ctx, deprecated{{ capitalize .ClassName }}Type, {{ capitalize .ClassName }}V1List)
				upgradedStateData.Deprecated{{ capitalize .ClassName }} = {{ capitalize .ClassName }}V1Set
				{{ end}}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedStateData)...)
			},
		},
	}
}

func set{{ .ResourceClassName }}LegacyAttributes(ctx context.Context, diags *diag.Diagnostics, data *{{.ResourceClassName}}ResourceModel, classReadInfo []interface{}) {
	{{- if .HasParent}}
	data.DeprecatedParentDn = data.ParentDn
	{{- end}}
	attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
	for attributeName, attributeValue := range attributes {
		{{- range .LegacyAttributes}}{{- if ne .ReplacedBy.AttributeName "" }}
			{{- if and (isNewAttributeStringType .ReplacedBy.AttributeName) (ne .Name "ParentDn")}}
				{{- if legacyAttributeContainsNoneValue . $.Properties}}
		if attributeName == "{{decapitalize .Name}}" && attributeValue.(string) == "" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue("none")
		} else if attributeName == "{{decapitalize .Name}}" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
		}
				{{- else}}
		if attributeName == "{{decapitalize .Name}}" {
			data.Deprecated{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
		}
				{{- end}}
			{{- end }}{{- end }}
		{{- end }}
	}

	{{- if .HasChild}}
		{{- range $.Children}}{{- if isLegacyChild .PkgName $.LegacyChildren}}
		{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
			{{- if eq $childClassType "string" }}
	data.Deprecated{{.ResourceClassName}} = basetypes.NewStringNull()
			{{- else if eq $childClassType "set,string" }}
	Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List := make([]string, 0)
			{{- end }}
		{{- end }}{{- end }}

	_, ok := classReadInfo[0].(map[string]interface{})["children"]
	if ok {
		children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
		for _, child := range children {
			for childClassName, childClassDetails := range child.(map[string]interface{}) {
				childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
				{{- range .Children}}{{- if isLegacyChild .PkgName $.LegacyChildren}}
				{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}{{- if eq $childClassType "string" }}
				if childClassName == "{{ .PkgName }}" {
					for childAttributeName, childAttributeValue := range childAttributes {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if eq $AttributeName (capitalize .PkgName)}}
						if childAttributeName == "tDn" {
							data.Deprecated{{.ResourceClassName}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
							{{- else if ne $AttributeName ""}}
						if childAttributeName == "{{.PropertyName}}" {
							data.Deprecated{{.ResourceClassName}} = basetypes.NewStringValue(childAttributeValue.(string))
						}
							{{- end}}
						{{- end}}
					}
				}
				{{- else if eq $childClassType "set,string" }}
				if childClassName == "{{ .PkgName }}" {
					for childAttributeName, childAttributeValue := range childAttributes {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if eq $AttributeName (capitalize .PkgName)}}
						if childAttributeName == "tDn" && childAttributeValue != "" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List = append(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, childAttributeValue.(string))
						}{{break}}
							{{- else if ne $AttributeName ""}}
						if childAttributeName == "{{.PropertyName}}" {
							Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List = append(Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List, childAttributeValue.(string))
						} // {{$AttributeName}}
							{{- end}}
						{{- end}}
					}
				}
				{{- end }}
				{{- end }}{{- end }}
			}
		}

		{{- range .Children}}{{- if isLegacyChild .PkgName $.LegacyChildren}}
		{{- $childClassType := getValueFromMap .PkgName $.MigrationClassTypes}}
			{{- if eq $childClassType "set,string" }}
		{{ .PkgName }}Set, _ := types.SetValueFrom(ctx, data.Deprecated{{ .ResourceClassName }}.ElementType(ctx), Deprecated{{.ResourceClassName}}{{$.ResourceClassName}}List)
		data.Deprecated{{ .ResourceClassName }} = {{ .PkgName }}Set
			{{- else if eq $childClassType "block,set" }}
		data.Deprecated{{ .ResourceClassName }} = types.SetNull(deprecated{{ .ResourceClassName }}Type)
			{{- end}}
		{{- end}}{{- end}}
	}
	{{- end }}
}
{{- end }}

func (r *{{.ResourceClassName}}Resource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
    if !req.Plan.Raw.IsNull() {
		var planData, stateData{{ if .LegacyAttributes}}, configData{{end}} *{{.ResourceClassName}}ResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &planData)...)
		resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
		{{ if .LegacyAttributes}}resp.Diagnostics.Append(req.Config.Get(ctx, &configData)...){{end}}

		if resp.Diagnostics.HasError() {
			return
		}

		if (planData.Id.IsUnknown() || planData.Id.IsNull()) {{if .HasParent }}&& !planData.ParentDn.IsUnknown() {{end}}{{range .Properties}}{{if .IsNaming}}&& !planData.{{ .Name }}.IsUnknown() {{end}}{{end}}{
			Set{{.ResourceClassName}}Id(ctx, planData)
		}

		if stateData == nil && !globalAllowExistingOnCreate && !planData.Id.IsUnknown() && !planData.Id.IsNull() {
			CheckDn(ctx, &resp.Diagnostics, r.client, "{{.PkgName}}", planData.Id.ValueString())
			if resp.Diagnostics.HasError() {
				return
			}
		}

		{{ if .LegacyAttributes}}
		{{ range .LegacyAttributes}}{{$SetName := .Name}}
			{{- if and (ne .ReplacedBy.AttributeName "") (eq (getMigrationType .ValueType) "String") (isNewAttributeStringType .ReplacedBy.AttributeName) }}
		if !configData.{{ .Name }}.IsNull() {
			planData.Deprecated{{ .Name }} = configData.{{ .Name }}
		} else if !configData.Deprecated{{ .Name }}.IsNull() { 
			planData.{{ .Name }} = configData.Deprecated{{ .Name }}
		} else if stateData != nil { // used to replace use state for unknown
			planData.Deprecated{{ .Name }} = stateData.Deprecated{{ .Name }}
		}
			{{- else if and (ne .ReplacedBy.AttributeName "") (eq (getMigrationType .ValueType) "String") }}
				{{- range $.Children}}
					{{- if isLegacyChild .PkgName $.LegacyChildren}}
						{{- if eq $SetName (capitalize .PkgName)}}
		if !configData.{{ $SetName }}.IsNull() && stateData != nil {
			var attributeValues []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
			configData.{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			for _, attributeValue := range attributeValues {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if ne $AttributeName ""}}
				if GetMOName(stateData.Deprecated{{.ResourceClassName}}.ValueString()) == attributeValue.{{ .Name }}.ValueString() {
					planData.Deprecated{{.ResourceClassName}} = stateData.Deprecated{{.ResourceClassName}}
				}
							{{- end}}
						{{- end}}
			}	
		} else if !configData.Deprecated{{ $SetName }}.IsNull() {
			{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
			{{.ResourceClassName}} := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if eq .Name "Annotation"}}
				{{ .Name }}: planData.Annotation,
							{{- else if eq $AttributeName ""}}
				{{ .Name }}: basetypes.NewStringNull(),
							{{- else}}
				{{ .Name }}: {{- if isNewNamedClassAttribute $Overwrite }}basetypes.NewStringValue(GetMOName(configData.Deprecated{{ $AttributeName }}.ValueString())){{- else }}configData.Deprecated{{ .Name }}{{- end }},
							{{- end}}
						{{- end}}
			}
			{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{.ResourceClassName}})
			{{.ResourceClassName}}Type := types.ObjectType{
				AttrTypes: map[string]attr.Type{
				{{- range .Properties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					"{{$Overwrite}}": basetypes.StringType{},
				{{- end}}
				},
			}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
		} else if stateData != nil { // used to replace use state for unknown
			planData.Deprecated{{.ResourceClassName}} = stateData.Deprecated{{.ResourceClassName}}
		}
						{{- end }}
					{{- end }}
				{{- end }}
			{{- else if ne .ReplacedBy.AttributeName "" }}
				{{- range $.Children}}
					{{- if isLegacyChild .PkgName $.LegacyChildren}}
						{{- if eq $SetName (capitalize .PkgName)}}
		// HasNamedProperties {{.HasNamedProperties}}
		if !configData.{{ $SetName }}.IsNull() && stateData != nil {
			var attributeValues []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
			var newAttributeValues, stateAttributeValues []string
			configData.{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			stateData.Deprecated{{.ResourceClassName}}.ElementsAs(ctx, &stateAttributeValues, false)
			for _, attributeValue := range attributeValues {
						{{- range .Properties}}
							{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
							{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
				newAttributeValues = append(newAttributeValues, attributeValue.{{ .Name }}.ValueString())
							{{- end }}
						{{- end }}
			}

			if len(newAttributeValues) == len(stateAttributeValues) {
				allMatchState := true
				for _, stateAttributeValue := range stateAttributeValues {
					if !ContainsString(newAttributeValues, GetMOName(stateAttributeValue)) {
						allMatchState = false
						break
					}
				}
				if allMatchState {
					{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, basetypes.StringType{}, stateAttributeValues)
					planData.Deprecated{{.ResourceClassName}} = {{.ResourceClassName}}Set
				}
			}
		} else if !configData.Deprecated{{ $SetName }}.IsNull() {
			{{.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
			var attributeValues []string
			var newAttributeValues []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
			configData.Deprecated{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			if stateData != nil {
				stateData.{{.ResourceClassName}}.ElementsAs(ctx, &newAttributeValues, false)
			}
			for _, attributeValue := range attributeValues {
				{{.ResourceClassName}}Value := {{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
					if newAttributeValue.{{ .Name }}.ValueString() == {{- if isNewNamedClassAttribute $Overwrite }}GetMOName(attributeValue){{- else}}attributeValue{{- end}} {
						{{.ResourceClassName}}Value = newAttributeValue
						foundAttributeValue = true
						break
					}
						{{- end}}
					{{- end}}
				}
				{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
						{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
							{{- if or (eq .Name "TDn") (isNewNamedClassAttribute $Overwrite)}}
					{{ .Name }}: {{- if isNewNamedClassAttribute $Overwrite }}basetypes.NewStringValue(GetMOName(attributeValue)){{- else}}basetypes.NewStringValue(attributeValue){{- end}},
							{{- end}}
						{{- end}}
				}

				if foundAttributeValue {
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if and (ne .Name "TDn") (not (isNewNamedClassAttribute $Overwrite))}}
					{{ .ResourceClassName }}.{{ .Name }} = {{.ResourceClassName}}Value.{{ .Name }}
						{{- end}}
					{{- end}}
				} else {
					{{- range .Properties}}
						{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
						{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if eq .Name "Annotation"}}
					{{ .ResourceClassName }}.{{ .Name }} = planData.Annotation
						{{- else if ne .DefaultValue ""}}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringValue("{{ .DefaultValue }}") // Default to default value from meta when not found
						{{- end}}
					{{- end}}
				}
				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
			}
			{{.ResourceClassName}}Type := types.ObjectType{
				AttrTypes: map[string]attr.Type{
				{{- range .Properties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					"{{$Overwrite}}": basetypes.StringType{},
				{{- end}}
				},
			}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
		} else if stateData != nil { // used to replace use state for unknown
			planData.Deprecated{{.ResourceClassName}} = stateData.Deprecated{{.ResourceClassName}}
		}
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
		{{ end }}

		{{ range .LegacyBlocks}}{{$ClassName := .ClassName}}{{$Attributes := .Attributes}}
		planData.Deprecated{{ capitalize .ClassName }} = types.SetNull(deprecated{{ capitalize .ClassName }}Type)
		if !configData.Deprecated{{ capitalize .ClassName }}.IsNull() && stateData != nil {
			{{- range $.Children}}
				{{- if isLegacyChild .PkgName $.LegacyChildren}}
					{{- if eq $ClassName .PkgName}}
			{{ .ResourceClassName }}List := make([]{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel, 0)
			var attributeValues []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModelV1
			var newAttributeValues []{{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel
			configData.Deprecated{{.ResourceClassName}}.ElementsAs(ctx, &attributeValues, false)
			stateData.{{.ResourceClassName}}.ElementsAs(ctx, &newAttributeValues, false)
			for _, attributeValue := range attributeValues {
				{{- $NewProperties := getNewChildAttributes (getChildAttributesFromBlocks $ClassName $.LegacyBlocks) .Properties}}
				{{- if ne (len $NewProperties) 0}}
				{{- range .Properties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
					{{- if and (ne $AttributeName "") .IsRequired }}
				planned{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel{}
				foundAttributeValue := false
				for _, newAttributeValue := range newAttributeValues {
					if newAttributeValue.{{ .Name }}.ValueString() == {{- if isNewNamedClassAttribute $Overwrite }}GetMOName(attributeValue.{{ $AttributeName }}.ValueString()){{- else}}attributeValue.TDn.ValueString(){{- end}} {
						planned{{ .ResourceClassName }} = newAttributeValue
						foundAttributeValue = true
						break
					}
				}
					{{- end}}
				{{- end}}
				{{- end}}
				
				{{ .ResourceClassName }} := {{ .ResourceClassName }}{{$.ResourceClassName}}ResourceModel {
					{{- range .Properties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if eq .Name "Annotation"}}
					{{ .Name }}: planData.Annotation,
						{{- else if and (ne $AttributeName "") (not (isNewNamedClassAttribute $Overwrite)) }}
					{{ .Name }}: attributeValue.{{ .Name }},
						{{- end}}
					{{- end}}
				}

				{{- if ne (len $NewProperties) 0}}
				
				if foundAttributeValue {
					{{- range $NewProperties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
					{{ .ResourceClassName }}.{{ .Name }} = planned{{ .ResourceClassName }}.{{ .Name }}
					{{- end}}
				} else {
					{{- range $NewProperties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					{{- $AttributeName := getLegacyChildAttribute .PkgName $Overwrite . $.LegacyAttributes $.LegacyBlocks}}
						{{- if isNewNamedClassAttribute $Overwrite }}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringValue(GetMOName(attributeValue.{{ $AttributeName }}.ValueString()))
						{{- else if ne .DefaultValue ""}}
					{{ .ResourceClassName }}.{{ .Name }} = basetypes.NewStringValue("{{.DefaultValue}}") // Default to default value from meta when not found
						{{- else}}
					{{ .ResourceClassName }}.{{ .Name }} = attributeValue.{{ .Name }}
						{{- end}}
					{{- end}}
				}
				{{- end}}

				{{.ResourceClassName}}List = append({{.ResourceClassName}}List, {{ .ResourceClassName }})
			}

			{{.ResourceClassName}}Type := types.ObjectType{
				AttrTypes: map[string]attr.Type{
				{{- range .Properties}}
					{{- $Overwrite := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
					"{{$Overwrite}}": basetypes.StringType{},
				{{- end}}
				},
			}
			{{.ResourceClassName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}Type, {{.ResourceClassName}}List)
			planData.{{.ResourceClassName}} = {{.ResourceClassName}}Set
			
					{{- end }}
				{{- end }}
			{{- end }}
		}
		{{ end }}
		{{ end }}
		resp.Diagnostics.Append(resp.Plan.Set(ctx, &planData)...)
	}
}

func (r *{{.ResourceClassName}}Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	tflog.Debug(ctx, "Start metadata of resource: aci_{{.ResourceName}}")
	resp.TypeName = req.ProviderTypeName + "_{{.ResourceName}}"
	tflog.Debug(ctx, "End metadata of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	tflog.Debug(ctx, "Start schema of resource: aci_{{.ResourceName}}")
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "The {{.ResourceName}} resource for the '{{.PkgName}}' class",
		{{- if .LegacyAttributes}}
		Version: {{add .LegacySchemaVersion 1}},
		{{- end}}

		Attributes: map[string]schema.Attribute{
			{{- if .LegacyAttributes}}
			// Deprecated attributes
				{{- range .LegacyAttributes}}
					{{- if ne .ReplacedBy.AttributeName "" }}
						{{- if eq (getMigrationType .ValueType) "String"}}
			"{{.AttributeName}}": schema.StringAttribute{
				Optional: true,
				Computed: true,
				DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
				Validators: []validator.String{
					stringvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "Set"}}
			"{{.AttributeName}}": schema.SetAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
				Validators: []validator.Set{
					setvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
						{{- if eq (getMigrationType .ValueType) "List"}}
			"{{.AttributeName}}": schema.ListAttribute{
				Optional: true,
				Computed: true,
				ElementType: types.StringType,
				DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
				Validators: []validator.List{
					listvalidator.ConflictsWith(path.Expressions{
						path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
					}...),
				},
			},
						{{- end}}
					{{- end}}
				{{- end}}
			// End of deprecated attributes
			{{- end}}
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "The distinguished name (DN) of the {{getResourceNameAsDescription .ResourceName $.Definitions}} object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			{{- if .HasParent}}
			"parent_dn": schema.StringAttribute{
				{{- $LegacyAttributeName := getPropertyNameForLegacyAttribute "parent_dn" $.LegacyAttributes}}
				{{- if ne $LegacyAttributeName ""}}
				Optional: true,
				Computed: true,
				{{- else if getDefaultValues .PkgName "parent_dn" $.Definitions}}
				Optional:            true,
				Computed:            true,
				Default: 			 stringdefault.StaticString("{{getDefaultValues .PkgName "parent_dn" $.Definitions}}"),
				{{- else}}
				Required:            true,
				{{- end}}
				MarkdownDescription: "The distinguished name (DN) of the parent object.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					stringplanmodifier.RequiresReplace(),
				},
				{{- if ne $LegacyAttributeName ""}}
				Validators: []validator.String{
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("{{$LegacyAttributeName}}"),
					}...),
				},
				{{- end}}
			},
			{{- end}}
			{{- range .Properties}}
			{{- $OverwritePropertyName := overwriteProperty .PkgName .SnakeCaseName $.Definitions}}
			{{- $LegacyAttributeName := getPropertyNameForLegacyAttribute $OverwritePropertyName $.LegacyAttributes}}
				{{- if eq .ValueType "bitmask"}}
			"{{$OverwritePropertyName}}": schema.SetAttribute{
				MarkdownDescription: `{{.Comment}}`,
					{{- if not .ReadOnly }}
				Optional:            true,
					{{- end }}
				Computed:            true,
					{{- if not .ReadOnly }}
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
					{{- end}}
					{{- if .ValidValues}}
				Validators: []validator.Set{
					setvalidator.SizeAtMost({{ len .ValidValues }}),
					setvalidator.ValueStringsAre(
						stringvalidator.OneOf({{- validatorString .ValidValues}}),
					),
				},
					{{- end}}
				ElementType: types.StringType,
			},
				{{- else}}
			"{{$OverwritePropertyName}}": schema.StringAttribute{
					{{- if or .IsNaming .IsRequired}}
						{{- if ne $LegacyAttributeName ""}}
				{{- if not .ReadOnly }}
				Optional:            true,
				{{- end }}
				Computed: true,
						{{- else}}
				Required:            true,
						{{- end}}
					{{- else }}
				{{- if not .ReadOnly }}
				Optional:            true,
				{{- end }}
				Computed:            true,
					{{- end}}
					{{- if not .ReadOnly }}
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
					SetToStringNullWhenStateIsNullPlanIsUnknownDuringUpdate(),
					{{- if or .IsNaming .CreateOnly}}
					stringplanmodifier.RequiresReplace(),
					{{- end}}
				},
					{{- end}}
					{{- if eq .Name "Annotation"}}
				Default: stringdefault.StaticString(globalAnnotation),
					{{- end}}
					{{- if or .ValidValues (ne $LegacyAttributeName "")}}
				Validators: []validator.String{
						{{- if .ValidValues}}
					stringvalidator.OneOf({{- validatorString .ValidValues}}),
						{{- end}}
						{{- if and (ne $LegacyAttributeName "") (or .IsNaming .IsRequired)}}
					stringvalidator.AtLeastOneOf(path.Expressions{
						path.MatchRoot("{{$LegacyAttributeName}}"),
					}...),
						{{- end}}
				},
					{{- end}}
				MarkdownDescription: `{{.Comment}}`,
			},
				{{- end}}
			{{- end}}
			{{- range .Children}}
			"{{- .ResourceName}}": schema.SetNestedAttribute{
				MarkdownDescription: `{{.Comment}}`,
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Set{
					setplanmodifier.UseStateForUnknown(),
				},
				{{- if or (not .IdentifiedBy) .MaxOneClassAllowed}}
				Validators: []validator.Set{
					setvalidator.SizeAtMost(1),
				},
				{{- end}}
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
					{{- range .Properties}}
						{{- if eq .ValueType "bitmask"}}
						"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.SetAttribute{
							MarkdownDescription: `{{.Comment}}`,
							{{- if not .ReadOnly }}
							Optional:            true,
							{{- end }}
							Computed:            true,
							{{- if not .ReadOnly }}
							PlanModifiers: []planmodifier.Set{
								setplanmodifier.UseStateForUnknown(),
							},
							{{- end }}
							{{- if .ValidValues}}
							Validators: []validator.Set{
								setvalidator.SizeAtMost({{ len .ValidValues }}),
								setvalidator.ValueStringsAre(
									stringvalidator.OneOf({{- validatorString .ValidValues}}),
								),
							},
							{{- end}}
							ElementType: types.StringType,
						},
						{{- else}}
						"{{overwriteProperty .PkgName .SnakeCaseName $.Definitions}}": schema.StringAttribute{
							{{- if and (or .IsNaming .IsRequired) (not $.HasReadOnlyProperties)}}
							Required:            true,
							{{- else }}
							Optional:            true,
							Computed:            true,
							{{- end}}
							{{- if not .ReadOnly }}
							PlanModifiers: []planmodifier.String{
								stringplanmodifier.UseStateForUnknown(),
							},
							{{- end}}
							{{- if or .ValidValues $.HasReadOnlyProperties}}
							Validators: []validator.String{
								{{- if .ValidValues}}
								stringvalidator.OneOf({{- validatorString .ValidValues}}),
								{{- end}}
								{{- if or .IsNaming .IsRequired}}
								MakeStringRequired(),
								{{- end}}
							},
							{{- end}}
							MarkdownDescription: `{{.Comment}}`,
						},
						{{- end}}
					{{- end}}
					},
				},
			},
			{{- end}}
		},
		{{- if .LegacyAttributes}}
		Blocks: map[string]schema.Block{
			{{- range .LegacyBlocks}}
			"{{ .Name }}": schema.SetNestedBlock{
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
					{{- range .Attributes}}
						{{- if eq (getMigrationType .ValueType) "String"}}
						"{{.AttributeName}}": schema.StringAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.String{
								stringvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
							},
						},
							{{- end}}
							{{- if eq (getMigrationType .ValueType) "Set"}}
						"{{.AttributeName}}": schema.SetAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.Set{
								setvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
							},
						},
							{{- end}}
							{{- if eq (getMigrationType .ValueType) "List"}}
						"{{.AttributeName}}": schema.ListAttribute{
							Optional: true,
							Computed: true,
							DeprecationMessage: "Attribute '{{.AttributeName}}' will be deprecated soon, please use '{{.ReplacedBy.AttributeName}}' instead",
							Validators: []validator.List{
								listvalidator.ConflictsWith(path.Expressions{
									path.MatchRoot("{{getConflictingAttributeName .ReplacedBy.AttributeName}}"),
								}...),
							},	
						},
						{{- end}}
					{{- end}}
					},
				},
			},
			{{- end }}
		},
		{{- end}}
	}
	tflog.Debug(ctx, "End schema of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	tflog.Debug(ctx, "Start configure of resource: aci_{{.ResourceName}}")
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
	tflog.Debug(ctx, "End configure of resource: aci_{{.ResourceName}}")
}

func (r *{{.ResourceClassName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Start create of resource: aci_{{.ResourceName}}")
	
	{{- if .HasChild}}
	// On create retrieve information on current state prior to making any changes in order to determine child delete operations
	var stateData *{{.ResourceClassName}}ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &stateData)...)
	if stateData.Id.IsUnknown() || stateData.Id.IsNull() {
		Set{{.ResourceClassName}}Id(ctx, stateData)
	}
	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, stateData)
	if !globalAllowExistingOnCreate && !stateData.Id.IsNull() {
		resp.Diagnostics.AddError(
			"Object Already Exists",
			fmt.Sprintf("The {{.PkgName}} object with DN '%s' already exists.", stateData.Id.ValueString()),
		)
		return
	} 
	{{- end}}

	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	
	if data.Id.IsUnknown() || data.Id.IsNull() {
		Set{{.ResourceClassName}}Id(ctx, data)
	}

	tflog.Debug(ctx, fmt.Sprintf("Create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{ if .HasChild}}
		{{- range .Children}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
		{{- end}}
	jsonPayload := Get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, true, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := Get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, true, data)
	{{- end}}

	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	
	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End create of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Start read of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	if data.Id.IsNull() {
		var emptyData *{{.ResourceClassName}}ResourceModel
		resp.Diagnostics.Append(resp.State.Set(ctx, &emptyData)...)
	} else {
		resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	}

	tflog.Debug(ctx, fmt.Sprintf("End read of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Start update of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel
	{{- if .HasChild}}
	var stateData *{{.ResourceClassName}}ResourceModel
	{{- end}}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	{{- if .HasChild}}
	resp.Diagnostics.Append(req.State.Get(ctx, &stateData)...)
	{{- end}}

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Update of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
	
	{{ if .HasChild}}
		{{- range .Children}}
	var {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel
	data.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}Plan, false)
	stateData.{{ .ResourceClassName }}.ElementsAs(ctx, &{{.PkgName}}State, false)
		{{- end}}
	jsonPayload := Get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, false, data{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State{{- end}})	
	{{- else}}
	jsonPayload := Get{{.ResourceClassName}}CreateJsonPayload(ctx, &resp.Diagnostics, false, data)
	{{- end}}
	
	if resp.Diagnostics.HasError() {
		return
	}

	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	
	if resp.Diagnostics.HasError() {
		return
	}

	getAndSet{{.ResourceClassName}}Attributes(ctx, &resp.Diagnostics, r.client, data)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
	tflog.Debug(ctx, fmt.Sprintf("End update of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Start delete of resource: aci_{{.ResourceName}}")
	var data *{{.ResourceClassName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("Delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))

	{{- if .AllowDelete}}
	jsonPayload := GetDeleteJsonPayload(ctx, &resp.Diagnostics, "{{.PkgName}}", data.Id.ValueString())
	if resp.Diagnostics.HasError() {
		return
	}
	DoRestRequest(ctx, &resp.Diagnostics, r.client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "POST", jsonPayload)
	if resp.Diagnostics.HasError() {
		return
	}
	{{- else}}
	parentDnMessage := "Delete on apic is only possible when deleting the parent object with dn"
	parentDn := data.Id.ValueString()
	if parentDn == "" {
		parentDnMessage = fmt.Sprintf("%s.", parentDnMessage)
	} else {
		parentDnMessage = fmt.Sprintf("%s '%s'.", parentDnMessage, parentDn)
	}
	message := fmt.Sprintf("resource with dn '%s' not removed from apic", data.Id.ValueString())
	messageDetail := fmt.Sprintf("Only removing resource from state because apic does not allow deletion of class '{{.PkgName}}' objects. %s", parentDnMessage)
	resp.Diagnostics.AddWarning(message, messageDetail)
	{{- end}}
	tflog.Debug(ctx, fmt.Sprintf("End delete of resource aci_{{.ResourceName}} with id '%s'", data.Id.ValueString()))
}

func (r *{{.ResourceClassName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Debug(ctx, "Start import state of resource: aci_{{.ResourceName}}")
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
	
	var stateData *{{.ResourceClassName}}ResourceModel
	resp.Diagnostics.Append(resp.State.Get(ctx, &stateData)...)
	tflog.Debug(ctx, fmt.Sprintf("Import state of resource aci_{{.ResourceName}} with id '%s'", stateData.Id.ValueString()))

	tflog.Debug(ctx, "End import of state resource: aci_{{.ResourceName}}")
}

func getAndSet{{.ResourceClassName}}Attributes(ctx context.Context, diags *diag.Diagnostics, client *client.Client, data *{{.ResourceClassName}}ResourceModel) {
	{{- if .HasChild}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json?rsp-subtree=children&rsp-subtree-class=%s", data.Id.ValueString(), "{{- .PkgName}},{{- listToString .ChildClasses}}"), "GET", nil)
	{{- else}}
	requestData := DoRestRequest(ctx, diags, client, fmt.Sprintf("api/mo/%s.json", data.Id.ValueString()), "GET", nil)
	{{- end}}
	
	*data = *getEmpty{{.ResourceClassName}}ResourceModel()

	if diags.HasError() {
		return
	}
	if requestData.Search("imdata").Search("{{.PkgName}}").Data() != nil {
		classReadInfo := requestData.Search("imdata").Search("{{.PkgName}}").Data().([]interface{})
		if len(classReadInfo) == 1 {
			attributes := classReadInfo[0].(map[string]interface{})["attributes"].(map[string]interface{})
			for attributeName, attributeValue := range attributes {
				if attributeName == "dn" {
					data.Id = basetypes.NewStringValue(attributeValue.(string))
					{{- if .HasParent}}
					set{{.ResourceClassName}}ParentDn(ctx, attributeValue.(string), data)
					{{- end}}
				}
				{{- range .Properties}}
					{{- if eq .ValueType "bitmask"}}
				if attributeName == "{{.PropertyName}}" {
					{{.PropertyName}}List := make([]string, 0)
					if attributeValue.(string) != "" {
                        {{.PropertyName}}List = strings.Split(attributeValue.(string), ",")
                    }
					{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, data.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
					data.{{.Name}} = {{.PropertyName}}Set
				}
					{{- else}}
						{{- if containsNoneAttributeValue .ValidValues}}
				if attributeName == "{{.PropertyName}}" && attributeValue.(string) == "" {
					data.{{.Name}} = basetypes.NewStringValue("none")
				} else if attributeName == "{{.PropertyName}}" {
					data.{{.Name}} = basetypes.NewStringValue(attributeValue.(string))
				}
						{{- else}}
				if attributeName == "{{.PropertyName}}" {
					data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(attributeValue.(string))
				}
						{{- end}}
					{{- end}}
				{{- end}}
			}
			
			{{- if .HasChild}}
				{{- range .Children}}
			{{ .ResourceClassName }}{{$.ResourceClassName}}List := make([]{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel, 0)
				{{- end}}
			_, ok := classReadInfo[0].(map[string]interface{})["children"]
			if ok {
				children := classReadInfo[0].(map[string]interface{})["children"].([]interface{})
				for _, child := range children {
					for childClassName, childClassDetails := range child.(map[string]interface{}) {
						childAttributes := childClassDetails.(map[string]interface{})["attributes"].(map[string]interface{})
						{{- range .Children}}
						if childClassName == "{{ .PkgName }}" {
							{{.ResourceClassName}}{{$.ResourceClassName}} := getEmpty{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel()
							for childAttributeName, childAttributeValue := range childAttributes {
								{{- range .Properties}}
									{{- if eq .ValueType "bitmask"}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), []string{"none"})
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
									{{.PropertyName}}List := strings.Split(childAttributeValue.(string), ",")
									{{.PropertyName}}Set, _ := types.SetValueFrom(ctx, {{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}}.ElementType(ctx), {{.PropertyName}}List)
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = {{.PropertyName}}Set
								}
										{{- end}}
									{{- else}}
										{{- if containsNoneAttributeValue .ValidValues}}
								if childAttributeName == "{{.PropertyName}}" && childAttributeValue.(string) == "" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue("none")
								} else if childAttributeName == "{{.PropertyName}}" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{.Name}} = basetypes.NewStringValue(childAttributeValue.(string))
								}
										{{- else}}
								if childAttributeName == "{{.PropertyName}}" {
									{{.ResourceClassName}}{{$.ResourceClassName}}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}} = basetypes.NewStringValue(childAttributeValue.(string))
								}
										{{- end}}
									{{- end}}
								{{- end}}
							}
							{{.ResourceClassName}}{{$.ResourceClassName}}List = append({{.ResourceClassName}}{{$.ResourceClassName}}List, {{.ResourceClassName}}{{$.ResourceClassName}})
						}
						{{- end}}
					}
				}
			}
				{{- range .Children}}
			{{ .PkgName }}Set, _ := types.SetValueFrom(ctx, data.{{ .ResourceClassName }}.ElementType(ctx), {{ .ResourceClassName }}{{$.ResourceClassName}}List)
			data.{{ .ResourceClassName }} = {{ .PkgName }}Set
				{{- end}}
			{{- end}}
			{{- if .LegacyAttributes}}
			set{{ .ResourceClassName }}LegacyAttributes(ctx, diags, data, classReadInfo)
			{{- end}}
		} else {
			diags.AddError(
				"too many results in response",
				fmt.Sprintf("%v matches returned for class '{{.PkgName}}'. Please report this issue to the provider developers.", len(classReadInfo)),
			)
		}
	} else {
		data.Id = basetypes.NewStringNull()
	}
}

func get{{.ResourceClassName}}Rn(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) string {
	{{- if .IdentifiedBy}}
	rn := "{{.RnFormat}}"
	for _, identifier := range []string{ {{- fromInterfacesToString .IdentifiedBy}} } {
		fieldName := fmt.Sprintf("%s%s", strings.ToUpper(identifier[:1]), identifier[1:])
		fieldValue := reflect.ValueOf(data).Elem().FieldByName(fieldName).Interface().(basetypes.StringValue).ValueString()
		rn = strings.ReplaceAll(rn, fmt.Sprintf("{%s}", identifier), fieldValue)
	}
	return rn
	{{- else}}
	return "{{.RnFormat}}"
	{{- end}}
}

{{ if .HasParent}}
func set{{.ResourceClassName}}ParentDn(ctx context.Context, dn string, data *{{.ResourceClassName}}ResourceModel) {
	bracketIndex := 0
	rnIndex := 0
	for i := len(dn) - 1; i >= 0; i-- {
		if string(dn[i]) == "]" {
			bracketIndex = bracketIndex + 1
		} else if string(dn[i]) == "[" {
			bracketIndex = bracketIndex - 1
		} else if string(dn[i]) == "/" && bracketIndex == 0 {
			rnIndex = i
			break
		}
	}
	{{- if eq .RnPrepend ""}}
	data.ParentDn = basetypes.NewStringValue(dn[:rnIndex])
	{{- else}}
	parentDn := dn[:rnIndex]
	parentDn = parentDn[:strings.Index(parentDn, "/{{.RnPrepend}}")]
	data.ParentDn = basetypes.NewStringValue(parentDn)
	{{- end}}
}
{{- end}}

func Set{{.ResourceClassName}}Id(ctx context.Context, data *{{.ResourceClassName}}ResourceModel) {
	rn := get{{.ResourceClassName}}Rn(ctx, data)
	{{- if .HasParent}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", data.ParentDn.ValueString(), rn))
	{{- else}}
	data.Id =  types.StringValue(fmt.Sprintf("%s/%s", strings.Split([]string{ {{- fromInterfacesToString .DnFormats}} }[0], "/")[0], rn))
	{{- end}}
}

{{ range .Children}}
func get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx context.Context, diags *diag.Diagnostics, data *{{$.ResourceClassName}}ResourceModel, {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel) []map[string]interface{} {
	
	childPayloads := []map[string]interface{}{}
	if !data.{{ .ResourceClassName }}.IsUnknown() {
	{{- if and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))}}
		{{ .PkgName }}Identifiers := []{{ .ResourceClassName }}Identifier{}
	{{- end}}
		for _, {{ .PkgName }} := range {{ .PkgName }}Plan {
			childMap := map[string]map[string]interface{}{"attributes": {}}
		{{- range .Properties}}
			if !{{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown() &&  !{{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull(){
			{{- if eq .ValueType "bitmask"}}
				var tmp{{ .Name }} []string
				{{ .PkgName }}.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
				childMap["attributes"]["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")				
			{{- else if eq .Name "Id"}}
				childMap["attributes"]["{{ .PropertyName }}"] = {{ .PkgName }}.{{.ResourceClassName}}{{ .Name }}.ValueString()
			{{- else}}
				childMap["attributes"]["{{ .PropertyName }}"] = {{ .PkgName }}.{{ .Name }}.ValueString()
			{{- end}}
			} {{- if eq .Name "Annotation" }} else {
				childMap["attributes"]["annotation"] = globalAnnotation
			} {{- end}}
		{{- end}}
			childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
		{{- if and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))}}
			{{ .PkgName }}Identifier := {{ .ResourceClassName }}Identifier{}
				{{- range .Properties}}
					{{- if .IsNaming}}
			{{ .PkgName }}Identifier.{{.Name}} = {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}
					{{- end}}
				{{- end}}
			{{ .PkgName }}Identifiers = append({{ .PkgName }}Identifiers, {{ .PkgName }}Identifier)
		{{- end}}
		}
		{{- if and .IdentifiedBy (not (and .MaxOneClassAllowed (hasPrefix .RnFormat  "rs")))}}
		for _, {{ .PkgName }} := range {{ .PkgName }}State {
			delete := true
			for _, {{ .PkgName }}Identifier := range {{ .PkgName }}Identifiers { {{$i := 1}}{{$length := len .IdentifiedBy}}
				if 
				{{- range .Properties}}
					{{- if .IsNaming }}
					{{ .PkgName }}Identifier.{{.Name}} == {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}{{- if ne $length $i}} {{$i = add $i 1}} && {{- end}}
					{{- end}}
				{{- end}} {
					delete = false
					break
				}
			}
			if delete {
				childMap := map[string]map[string]interface{}{"attributes": {}}
				childMap["attributes"]["status"] = "deleted"
			{{- range .Properties}}
				{{- if .IsNaming }}
				childMap["attributes"]["{{.PropertyName}}"] = {{ .PkgName }}.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
				{{- end}}
			{{- end}}
				childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
			}
		}
		{{- else}}
		if len({{ .PkgName }}Plan) == 0 && len({{ .PkgName }}State) == 1 {
			{{- if .AllowDelete}}
			childMap := map[string]map[string]interface{}{"attributes": {}}
			childMap["attributes"]["status"] = "deleted"
			{{- if .IdentifiedBy}}
				{{- range .Properties}}
					{{- if .IsNaming }}
			childMap["attributes"]["{{.PropertyName}}"] = {{ .PkgName }}State[0].{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
					{{- end}}
				{{- end}}
			{{- end}}
			childPayloads = append(childPayloads, map[string]interface{}{"{{ .PkgName }}": childMap})
			{{- else}}
			diags.AddError(
				"{{ .ResourceClassName }} object cannot be deleted",
				"deletion of child is only possible upon deletion of the parent",
			)
			return nil
			{{- end }}
		}
		{{- end}}
	} else {
		data.{{ .ResourceClassName }} = types.SetNull(data.{{ .ResourceClassName }}.ElementType(ctx))
	}

	return childPayloads
}
{{- end}}

func Get{{.ResourceClassName}}CreateJsonPayload(ctx context.Context, diags *diag.Diagnostics, createType bool, data *{{.ResourceClassName}}ResourceModel{{- range .Children}}, {{.PkgName}}Plan, {{.PkgName}}State []{{.ResourceClassName}}{{$.ResourceClassName}}ResourceModel{{- end}}) *container.Container {
	payloadMap := map[string]interface{}{}
	payloadMap["attributes"] = map[string]string{}

	if createType && !globalAllowExistingOnCreate {
		payloadMap["attributes"].(map[string]string)["status"] = "created"
	}

	{{- if .HasChild}}
	childPayloads := []map[string]interface{}{}
		{{ range .Children}}
	{{ .ResourceClassName }}childPayloads := get{{$.ResourceClassName}}{{ .ResourceClassName }}ChildPayloads(ctx, diags, data, {{.PkgName}}Plan, {{.PkgName}}State)
	if {{ .ResourceClassName }}childPayloads == nil {
		return nil
	}
	childPayloads = append(childPayloads, {{ .ResourceClassName }}childPayloads...)

		{{ end}}
	payloadMap["children"] = childPayloads
	{{- end}}

	{{- range .Properties}}{{- if not .ReadOnly}}
		{{- if eq .ValueType "bitmask"}}
	if !data.{{ .Name }}.IsNull() && !data.{{ .Name }}.IsUnknown() {
		var tmp{{ .Name }} []string
		data.{{ .Name }}.ElementsAs(ctx, &tmp{{ .Name }}, false)
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = strings.Join(tmp{{ .Name }}, ",")
	}
		{{- else}}
	if !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsNull() && !data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.IsUnknown(){
		payloadMap["attributes"].(map[string]string)["{{ .PropertyName }}"] = data.{{- if eq .Name "Id"}}{{.ResourceClassName}}{{ .Name }}{{- else}}{{.Name}}{{- end}}.ValueString()
	}
		{{- end}}
	{{- end}}{{- end}}

	payload, err := json.Marshal(map[string]interface{}{"{{.PkgName}}": payloadMap})
	if err != nil {
		diags.AddError(
			"Marshalling of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}

	jsonPayload, err := container.ParseJSON(payload)

	if err != nil {
		diags.AddError(
			"Construction of json payload failed",
			fmt.Sprintf("Err: %s. Please report this issue to the provider developers.", err),
		)
		return nil
	}
	return jsonPayload
}
